<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/ec0a9d078e716e00.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/485ff6fe79292a08.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/0ff121a467c0636f.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-038c2e688b596d0e.js"/><script src="/_next/static/chunks/4bd1b696-20882bf820444624.js" async=""></script><script src="/_next/static/chunks/517-98ed787e5f259f2c.js" async=""></script><script src="/_next/static/chunks/main-app-f33d3e3aed85e21f.js" async=""></script><meta name="next-size-adjust" content=""/><title>front-end</title><meta name="description" content="front-end knowledge"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><main><div class="markdown-body"><h1></h1><article><h1>页面生命周期方法</h1>
<p>HTML 页面的生命周期包含四个重要事件：</p>
<table>
<thead>
<tr>
<th style="text-align:left">事件</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">DOMContentLoaded</td>
<td style="text-align:left">浏览器已完全加载 HTML，并构建了 DOM 树，但诸如 <code>&lt;img&gt;</code> 和样式表之类的外部资源可能尚未加载完成</td>
<td style="text-align:left">DOM 已经就绪，因此处理程序可以查找 DOM 节点，并初始化接口</td>
</tr>
<tr>
<td style="text-align:left">load</td>
<td style="text-align:left">浏览器不仅加载完成了 HTML，还加载完成了所有外部资源</td>
<td style="text-align:left">外部资源已加载完成，样式已被应用，图片大小也已知了</td>
</tr>
<tr>
<td style="text-align:left">beforeunload</td>
<td style="text-align:left">当用户正在离开页面时触发</td>
<td style="text-align:left">用户正在离开，我们可以检查用户是否保存了更改，并询问他是否真的要离开</td>
</tr>
<tr>
<td style="text-align:left">unload</td>
<td style="text-align:left">当用户正在离开页面时触发</td>
<td style="text-align:left">用户几乎已经离开了，但是我们仍然可以启动一些操作，例如发送统计数据</td>
</tr>
</tbody>
</table>
<h2>readyState</h2>
<p>Document.readyState 属性描述了 <code>document</code> 的加载状态。</p>
<ul>
<li><code>loading</code>：正在加载状态，document 仍在加载中</li>
<li><code>interactive</code>：可交互状态，正在加载状态结束，但是诸如图像，样式表和框架之类的子资源仍在加载</li>
<li><code>complete</code>：完成状态，文档和所有子资源已完成加载，表示状态 <code>load</code> 状态的事件即将被触发</li>
</ul>
<h2>readystatechange</h2>
<p><code>readystatechange</code> 事件是跟踪文档加载状态的另一种机制，会在状态发生改变时触发，因此我们可以打印所有这些状态：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 当前状态</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;document.readyState&#x27;</span>);

<span class="hljs-comment">// 状态改变时打印到调试台中</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;readystatechange&#x27;</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">readyState</span>));
</code></pre>
<h2>DOMContentLoaded</h2>
<p>DOMContentLoaded 事件发生在 <code>document</code> 对象上。</p>
<p>我们必须使用 addEventListener 来捕获它：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-function">() =&gt;</span> {});
</code></pre>
<p><strong>示例：</strong></p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript">
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">ready</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;DOM is ready.&#x27;</span>);

    <span class="hljs-keyword">const</span> img = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#img&#x27;</span>);

    <span class="hljs-comment">// 图片目前尚未加载完成（除非已经被缓存），所以图片大小为 0x0</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Image size: <span class="hljs-subst">${img.offsetWidth}</span>x<span class="hljs-subst">${img.offsetHeight}</span>`</span>);
  }

  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, ready);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;img&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://en.js.cx/clipart/train.gif?speed=1&amp;cache=0&quot;</span> /&gt;</span>
</code></pre>
<p>示例中，<code>DOMContentLoaded</code> 处理程序在文档加载完成后触发，所以它可以查看所有元素，包括它下面的 <code>&lt;img&gt;</code> 元素。</p>
<blockquote>
<p>如果我们将 <code>DOMContentLoaded</code> 事件处理程序设置在文档加载完成之后，会发生什么？</p>
</blockquote>
<p>很自然地，它永远不会运行。在某些情况下，我们不确定文档是否已经准备就绪。我们希望我们的函数在 DOM 加载完成时执行，无论现在还是以后。</p>
<h3>与脚本文件的关系</h3>
<p>当浏览器处理一个 HTML 文档，并在文档中遇到 <code>&lt;script&gt;</code> 标签时，就会在继续构建 DOM 之前运行它。这是一种防范措施，因为脚本可能想要修改 DOM，甚至对其执行 <code>document.write</code> 操作，所以 <code>DOMContentLoaded</code> 必须等待脚本执行结束。</p>
<p>因此，DOMContentLoaded 肯定在下面的这些脚本执行结束之后发生：</p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript">
  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;DOM ready!&#x27;</span>);
  });
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript">
  <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Library loaded, inline script executed&#x27;</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>加载输出顺序：</p>
<ol>
<li><code>Library loaded...</code></li>
<li><code>DOM ready!</code></li>
</ol>
<p>不会阻塞 DOMContentLoaded 的脚本：</p>
<ol>
<li>具有 <code>async</code> 特性的脚本不会阻塞 <code>DOMContentLoaded</code></li>
<li>使用 <code>document.createElement('script')</code> 动态生成并添加到网页的脚本也不会阻塞 <code>DOMContentLoaded</code></li>
</ol>
<h3>与样式文件的关系</h3>
<p>外部样式表不会影响 DOM，因此 DOMContentLoaded 不会等待它们。</p>
<p>但这里有一个陷阱。如果在样式后面有一个脚本，那么该脚本必须等待样式表加载完成：</p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;style.css&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript">
  <span class="hljs-comment">// 在样式表加载完成之前，脚本都不会执行</span>
  <span class="hljs-title function_">alert</span>(<span class="hljs-title function_">getComputedStyle</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>).<span class="hljs-property">marginTop</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>原因是，脚本可能想要获取元素的坐标和其他与样式相关的属性，如上例所示。因此，它必须等待样式加载完成。</p>
<p>当 <code>DOMContentLoaded</code> 等待脚本时，它现在也在等待脚本前面的样式。</p>
<h3>浏览器内置的自动填充</h3>
<p>Firefox，Chrome 和 Opera 都会在 <code>DOMContentLoaded</code> 中自动填充表单。</p>
<p>例如，如果页面有一个带有登录名和密码的表单，并且浏览器记住了这些值，那么在 <code>DOMContentLoaded</code> 上，浏览器会尝试自动填充它们（如果得到了用户允许）。</p>
<p>因此，如果 <code>DOMContentLoaded</code> 被需要加载很长时间的脚本延迟触发，那么自动填充也会等待。你可能在某些网站上看到过（如果你使用浏览器自动填充）—— 登录名/密码字段不会立即自动填充，而是在页面被完全加载前会延迟填充。这实际上是 <code>DOMContentLoaded</code> 事件之前的延迟。</p>
<h2>window.onload</h2>
<p>当整个页面，包括样式、图片和其他资源被加载完成时，会触发 <code>window</code> 对象上的 <code>load</code> 事件。可以通过 <code>onload</code> 属性获取此事件。</p>
<p>下面的这个示例正确显示了图片大小，因为 <code>window.onload</code> 会等待所有图片加载完毕：</p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript">
  <span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;Page loaded&#x27;</span>);

    <span class="hljs-comment">// 此时图片已经加载完成</span>
    <span class="hljs-title function_">alert</span>(<span class="hljs-string">`Image size: <span class="hljs-subst">${img.offsetWidth}</span>x<span class="hljs-subst">${img.offsetHeight}</span>`</span>);
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;img&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://en.js.cx/clipart/train.gif?speed=1&amp;cache=0&quot;</span> /&gt;</span>
</code></pre>
<h2>window.onbeforeunload</h2>
<p>如果访问者触发了离开页面的导航（navigation）或试图关闭窗口，<code>beforeunload</code> 处理程序将要求进行更多确认。</p>
<p>如果我们要取消事件，浏览器会询问用户是否确定。</p>
<p>你可以通过运行下面这段代码，然后重新加载页面来进行尝试：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onbeforeunload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
};
</code></pre>
<p>由于历史原因，返回非空字符串也被视为取消事件。在以前，浏览器曾经将其显示为消息，但是根据 <a href="https://html.spec.whatwg.org/#unloading-documents" target="_blank" rel="noopener noreferrer nofollow">现代规范</a> 所述，它们不应该这样。</p>
<p>这里有个例子：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-variable language_">window</span>.<span class="hljs-property">onbeforeunload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;There are unsaved changes. Leave now?&#x27;</span>;
};
</code></pre>
<p>它的行为已经改变了，因为有些站长通过显示误导性和恶意信息滥用了此事件处理程序。所以，目前一些旧的浏览器可能仍将其显示为消息，但除此之外无法自定义显示给用户的消息。</p>
<h2>window.onunload</h2>
<p>当访问者离开页面时，<code>window</code> 对象上的 <code>unload</code> 事件就会被触发。我们可以在那里做一些 <strong>不涉及延迟</strong> 的操作，例如关闭相关的弹出窗口。</p>
<p>有一个值得注意的特殊情况是发送分析数据。</p>
<p>假设我们收集有关页面使用情况的数据：鼠标点击、滚动、被查看的页面区域等。</p>
<p>自然地，当用户要离开的时候，我们希望通过 <code>unload</code> 事件将数据保存到我们的服务器上。</p>
<p>有一个特殊的 <code>navigator.sendBeacon(url, data)</code> 方法可以满足这种需求，详见规范 <a href="https://w3c.github.io/beacon/" target="_blank" rel="noopener noreferrer nofollow">https://w3c.github.io/beacon/</a>。</p>
<p>它在后台发送数据，转换到另外一个页面不会有延迟：浏览器离开页面，但仍然在执行 sendBeacon。</p>
<p>使用方式如下：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> analyticsData = {
  <span class="hljs-comment">// 带有收集的数据的对象</span>
};

<span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;unload&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  navigator.<span class="hljs-title function_">sendBeacon</span>(<span class="hljs-string">&#x27;/analytics&#x27;</span>, <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(analyticsData));
};
</code></pre>
<ul>
<li>请求以 POST 方式发送</li>
<li>我们不仅能发送字符串，还能发送表单以及其他格式的数据，在 Fetch 一章有详细讲解，但通常它是一个字符串化的对象</li>
<li>数据大小限制在 64kb</li>
</ul>
<p>当 <code>sendBeacon</code> 请求完成时，浏览器可能已经离开了文档，所以就无法获取服务器响应（对于分析数据来说通常为空）</p>
<p>还有一个 <code>keep-alive</code> 标志，该标志用于在 <code>fetch</code> 方法中为通用的网络请求执行此类 <strong>离开页面后</strong> 的请求。你可以在 Fetch API 一章中找到更多相关信息。</p>
<p>如果我们要取消跳转到另一页面的操作，在这里做不到。但是我们可以使用另一个事件 <code>onbeforeunload</code>。</p>
<h2>总结</h2>
<p>文档加载的生命周期：</p>
<ol>
<li>文档加载中状态 document.raedyState -&gt; loading</li>
<li>可交互状态 readystatechange -&gt; <code>document.readyState = interactive</code></li>
<li>DOMContentLoaded</li>
<li>iframe onload</li>
<li>img onload</li>
<li>文档加载完成状态 document.readyState -&gt; complete</li>
<li>window.onload</li>
</ol>
<p>在 <code>DOMContentLoaded</code> 之前，<code>document.readyState</code> 会立即变成 <code>interactive</code>。它们俩的意义实际上是相同的。</p>
<p>当所有资源（<code>iframe</code> 和 <code>img</code>）都加载完成后，<code>document.readyState</code> 变成 <code>complete</code>。这里我们可以发现，它与 <code>img.onload</code>（<code>img</code> 是最后一个资源）和 <code>window.onload</code> 几乎同时发生。转换到 <code>complete</code> 状态的意义与 <code>window.onload</code> 相同。区别在于 <code>window.onload</code> 始终在所有其他 <code>load</code> 处理程序之后运行。</p>
</article></div></main><script src="/_next/static/chunks/webpack-038c2e688b596d0e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5244,[],\"\"]\n3:I[3866,[],\"\"]\n5:I[6213,[],\"OutletBoundary\"]\n7:I[6213,[],\"MetadataBoundary\"]\n9:I[6213,[],\"ViewportBoundary\"]\nb:I[4835,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/ec0a9d078e716e00.css\",\"style\"]\n:HL[\"/_next/static/css/485ff6fe79292a08.css\",\"style\"]\n:HL[\"/_next/static/css/0ff121a467c0636f.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"ToCgoFiTXvECVEVLCeZww\",\"p\":\"\",\"c\":[\"\",\"front-end\",\"browser-object-model\",\"web-event\",\"lifecycle\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"front-end\",{\"children\":[[\"slug\",\"browser-object-model/web-event/lifecycle\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/ec0a9d078e716e00.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"front-end\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/485ff6fe79292a08.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0ff121a467c0636f.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"main\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[[\"slug\",\"browser-object-model/web-event/lifecycle\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"pvbmwyW9xz4OHvvraFRef\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:T4264,"])</script><script>self.__next_f.push([1,"\u003ch1\u003e页面生命周期方法\u003c/h1\u003e\n\u003cp\u003eHTML 页面的生命周期包含四个重要事件：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e事件\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e说明\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e应用场景\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eDOMContentLoaded\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e浏览器已完全加载 HTML，并构建了 DOM 树，但诸如 \u003ccode\u003e\u0026lt;img\u0026gt;\u003c/code\u003e 和样式表之类的外部资源可能尚未加载完成\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eDOM 已经就绪，因此处理程序可以查找 DOM 节点，并初始化接口\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eload\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e浏览器不仅加载完成了 HTML，还加载完成了所有外部资源\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e外部资源已加载完成，样式已被应用，图片大小也已知了\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003ebeforeunload\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e当用户正在离开页面时触发\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e用户正在离开，我们可以检查用户是否保存了更改，并询问他是否真的要离开\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eunload\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e当用户正在离开页面时触发\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e用户几乎已经离开了，但是我们仍然可以启动一些操作，例如发送统计数据\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2\u003ereadyState\u003c/h2\u003e\n\u003cp\u003eDocument.readyState 属性描述了 \u003ccode\u003edocument\u003c/code\u003e 的加载状态。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eloading\u003c/code\u003e：正在加载状态，document 仍在加载中\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003einteractive\u003c/code\u003e：可交互状态，正在加载状态结束，但是诸如图像，样式表和框架之类的子资源仍在加载\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ecomplete\u003c/code\u003e：完成状态，文档和所有子资源已完成加载，表示状态 \u003ccode\u003eload\u003c/code\u003e 状态的事件即将被触发\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003ereadystatechange\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003ereadystatechange\u003c/code\u003e 事件是跟踪文档加载状态的另一种机制，会在状态发生改变时触发，因此我们可以打印所有这些状态：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 当前状态\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;document.readyState\u0026#x27;\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 状态改变时打印到调试台中\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;readystatechange\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ereadyState\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eDOMContentLoaded\u003c/h2\u003e\n\u003cp\u003eDOMContentLoaded 事件发生在 \u003ccode\u003edocument\u003c/code\u003e 对象上。\u003c/p\u003e\n\u003cp\u003e我们必须使用 addEventListener 来捕获它：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;DOMContentLoaded\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"language-javascript\"\u003e\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eready\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;DOM is ready.\u0026#x27;\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e img = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003equerySelector\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;#img\u0026#x27;\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 图片目前尚未加载完成（除非已经被缓存），所以图片大小为 0x0\u003c/span\u003e\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Image size: \u003cspan class=\"hljs-subst\"\u003e${img.offsetWidth}\u003c/span\u003ex\u003cspan class=\"hljs-subst\"\u003e${img.offsetHeight}\u003c/span\u003e`\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;DOMContentLoaded\u0026#x27;\u003c/span\u003e, ready);\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;img\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;https://en.js.cx/clipart/train.gif?speed=1\u0026amp;cache=0\u0026quot;\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e示例中，\u003ccode\u003eDOMContentLoaded\u003c/code\u003e 处理程序在文档加载完成后触发，所以它可以查看所有元素，包括它下面的 \u003ccode\u003e\u0026lt;img\u0026gt;\u003c/code\u003e 元素。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e如果我们将 \u003ccode\u003eDOMContentLoaded\u003c/code\u003e 事件处理程序设置在文档加载完成之后，会发生什么？\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e很自然地，它永远不会运行。在某些情况下，我们不确定文档是否已经准备就绪。我们希望我们的函数在 DOM 加载完成时执行，无论现在还是以后。\u003c/p\u003e\n\u003ch3\u003e与脚本文件的关系\u003c/h3\u003e\n\u003cp\u003e当浏览器处理一个 HTML 文档，并在文档中遇到 \u003ccode\u003e\u0026lt;script\u0026gt;\u003c/code\u003e 标签时，就会在继续构建 DOM 之前运行它。这是一种防范措施，因为脚本可能想要修改 DOM，甚至对其执行 \u003ccode\u003edocument.write\u003c/code\u003e 操作，所以 \u003ccode\u003eDOMContentLoaded\u003c/code\u003e 必须等待脚本执行结束。\u003c/p\u003e\n\u003cp\u003e因此，DOMContentLoaded 肯定在下面的这些脚本执行结束之后发生：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"language-javascript\"\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;DOMContentLoaded\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-title function_\"\u003ealert\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;DOM ready!\u0026#x27;\u003c/span\u003e);\n  });\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.3.0/lodash.js\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"language-javascript\"\u003e\n  \u003cspan class=\"hljs-title function_\"\u003ealert\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Library loaded, inline script executed\u0026#x27;\u003c/span\u003e);\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e加载输出顺序：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003ccode\u003eLibrary loaded...\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eDOM ready!\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e不会阻塞 DOMContentLoaded 的脚本：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e具有 \u003ccode\u003easync\u003c/code\u003e 特性的脚本不会阻塞 \u003ccode\u003eDOMContentLoaded\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e使用 \u003ccode\u003edocument.createElement('script')\u003c/code\u003e 动态生成并添加到网页的脚本也不会阻塞 \u003ccode\u003eDOMContentLoaded\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e与样式文件的关系\u003c/h3\u003e\n\u003cp\u003e外部样式表不会影响 DOM，因此 DOMContentLoaded 不会等待它们。\u003c/p\u003e\n\u003cp\u003e但这里有一个陷阱。如果在样式后面有一个脚本，那么该脚本必须等待样式表加载完成：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003elink\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/css\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003erel\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;stylesheet\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;style.css\u0026quot;\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"language-javascript\"\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 在样式表加载完成之前，脚本都不会执行\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003ealert\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003egetComputedStyle\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e).\u003cspan class=\"hljs-property\"\u003emarginTop\u003c/span\u003e);\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e原因是，脚本可能想要获取元素的坐标和其他与样式相关的属性，如上例所示。因此，它必须等待样式加载完成。\u003c/p\u003e\n\u003cp\u003e当 \u003ccode\u003eDOMContentLoaded\u003c/code\u003e 等待脚本时，它现在也在等待脚本前面的样式。\u003c/p\u003e\n\u003ch3\u003e浏览器内置的自动填充\u003c/h3\u003e\n\u003cp\u003eFirefox，Chrome 和 Opera 都会在 \u003ccode\u003eDOMContentLoaded\u003c/code\u003e 中自动填充表单。\u003c/p\u003e\n\u003cp\u003e例如，如果页面有一个带有登录名和密码的表单，并且浏览器记住了这些值，那么在 \u003ccode\u003eDOMContentLoaded\u003c/code\u003e 上，浏览器会尝试自动填充它们（如果得到了用户允许）。\u003c/p\u003e\n\u003cp\u003e因此，如果 \u003ccode\u003eDOMContentLoaded\u003c/code\u003e 被需要加载很长时间的脚本延迟触发，那么自动填充也会等待。你可能在某些网站上看到过（如果你使用浏览器自动填充）—— 登录名/密码字段不会立即自动填充，而是在页面被完全加载前会延迟填充。这实际上是 \u003ccode\u003eDOMContentLoaded\u003c/code\u003e 事件之前的延迟。\u003c/p\u003e\n\u003ch2\u003ewindow.onload\u003c/h2\u003e\n\u003cp\u003e当整个页面，包括样式、图片和其他资源被加载完成时，会触发 \u003ccode\u003ewindow\u003c/code\u003e 对象上的 \u003ccode\u003eload\u003c/code\u003e 事件。可以通过 \u003ccode\u003eonload\u003c/code\u003e 属性获取此事件。\u003c/p\u003e\n\u003cp\u003e下面的这个示例正确显示了图片大小，因为 \u003ccode\u003ewindow.onload\u003c/code\u003e 会等待所有图片加载完毕：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"language-javascript\"\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eonload\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003ealert\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Page loaded\u0026#x27;\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 此时图片已经加载完成\u003c/span\u003e\n    \u003cspan class=\"hljs-title function_\"\u003ealert\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`Image size: \u003cspan class=\"hljs-subst\"\u003e${img.offsetWidth}\u003c/span\u003ex\u003cspan class=\"hljs-subst\"\u003e${img.offsetHeight}\u003c/span\u003e`\u003c/span\u003e);\n  };\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;img\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;https://en.js.cx/clipart/train.gif?speed=1\u0026amp;cache=0\u0026quot;\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003ewindow.onbeforeunload\u003c/h2\u003e\n\u003cp\u003e如果访问者触发了离开页面的导航（navigation）或试图关闭窗口，\u003ccode\u003ebeforeunload\u003c/code\u003e 处理程序将要求进行更多确认。\u003c/p\u003e\n\u003cp\u003e如果我们要取消事件，浏览器会询问用户是否确定。\u003c/p\u003e\n\u003cp\u003e你可以通过运行下面这段代码，然后重新加载页面来进行尝试：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eonbeforeunload\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e由于历史原因，返回非空字符串也被视为取消事件。在以前，浏览器曾经将其显示为消息，但是根据 \u003ca href=\"https://html.spec.whatwg.org/#unloading-documents\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e现代规范\u003c/a\u003e 所述，它们不应该这样。\u003c/p\u003e\n\u003cp\u003e这里有个例子：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eonbeforeunload\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;There are unsaved changes. Leave now?\u0026#x27;\u003c/span\u003e;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e它的行为已经改变了，因为有些站长通过显示误导性和恶意信息滥用了此事件处理程序。所以，目前一些旧的浏览器可能仍将其显示为消息，但除此之外无法自定义显示给用户的消息。\u003c/p\u003e\n\u003ch2\u003ewindow.onunload\u003c/h2\u003e\n\u003cp\u003e当访问者离开页面时，\u003ccode\u003ewindow\u003c/code\u003e 对象上的 \u003ccode\u003eunload\u003c/code\u003e 事件就会被触发。我们可以在那里做一些 \u003cstrong\u003e不涉及延迟\u003c/strong\u003e 的操作，例如关闭相关的弹出窗口。\u003c/p\u003e\n\u003cp\u003e有一个值得注意的特殊情况是发送分析数据。\u003c/p\u003e\n\u003cp\u003e假设我们收集有关页面使用情况的数据：鼠标点击、滚动、被查看的页面区域等。\u003c/p\u003e\n\u003cp\u003e自然地，当用户要离开的时候，我们希望通过 \u003ccode\u003eunload\u003c/code\u003e 事件将数据保存到我们的服务器上。\u003c/p\u003e\n\u003cp\u003e有一个特殊的 \u003ccode\u003enavigator.sendBeacon(url, data)\u003c/code\u003e 方法可以满足这种需求，详见规范 \u003ca href=\"https://w3c.github.io/beacon/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003ehttps://w3c.github.io/beacon/\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e它在后台发送数据，转换到另外一个页面不会有延迟：浏览器离开页面，但仍然在执行 sendBeacon。\u003c/p\u003e\n\u003cp\u003e使用方式如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e analyticsData = {\n  \u003cspan class=\"hljs-comment\"\u003e// 带有收集的数据的对象\u003c/span\u003e\n};\n\n\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;unload\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  navigator.\u003cspan class=\"hljs-title function_\"\u003esendBeacon\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;/analytics\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e(analyticsData));\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e请求以 POST 方式发送\u003c/li\u003e\n\u003cli\u003e我们不仅能发送字符串，还能发送表单以及其他格式的数据，在 Fetch 一章有详细讲解，但通常它是一个字符串化的对象\u003c/li\u003e\n\u003cli\u003e数据大小限制在 64kb\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e当 \u003ccode\u003esendBeacon\u003c/code\u003e 请求完成时，浏览器可能已经离开了文档，所以就无法获取服务器响应（对于分析数据来说通常为空）\u003c/p\u003e\n\u003cp\u003e还有一个 \u003ccode\u003ekeep-alive\u003c/code\u003e 标志，该标志用于在 \u003ccode\u003efetch\u003c/code\u003e 方法中为通用的网络请求执行此类 \u003cstrong\u003e离开页面后\u003c/strong\u003e 的请求。你可以在 Fetch API 一章中找到更多相关信息。\u003c/p\u003e\n\u003cp\u003e如果我们要取消跳转到另一页面的操作，在这里做不到。但是我们可以使用另一个事件 \u003ccode\u003eonbeforeunload\u003c/code\u003e。\u003c/p\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e文档加载的生命周期：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e文档加载中状态 document.raedyState -\u0026gt; loading\u003c/li\u003e\n\u003cli\u003e可交互状态 readystatechange -\u0026gt; \u003ccode\u003edocument.readyState = interactive\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eDOMContentLoaded\u003c/li\u003e\n\u003cli\u003eiframe onload\u003c/li\u003e\n\u003cli\u003eimg onload\u003c/li\u003e\n\u003cli\u003e文档加载完成状态 document.readyState -\u0026gt; complete\u003c/li\u003e\n\u003cli\u003ewindow.onload\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在 \u003ccode\u003eDOMContentLoaded\u003c/code\u003e 之前，\u003ccode\u003edocument.readyState\u003c/code\u003e 会立即变成 \u003ccode\u003einteractive\u003c/code\u003e。它们俩的意义实际上是相同的。\u003c/p\u003e\n\u003cp\u003e当所有资源（\u003ccode\u003eiframe\u003c/code\u003e 和 \u003ccode\u003eimg\u003c/code\u003e）都加载完成后，\u003ccode\u003edocument.readyState\u003c/code\u003e 变成 \u003ccode\u003ecomplete\u003c/code\u003e。这里我们可以发现，它与 \u003ccode\u003eimg.onload\u003c/code\u003e（\u003ccode\u003eimg\u003c/code\u003e 是最后一个资源）和 \u003ccode\u003ewindow.onload\u003c/code\u003e 几乎同时发生。转换到 \u003ccode\u003ecomplete\u003c/code\u003e 状态的意义与 \u003ccode\u003ewindow.onload\u003c/code\u003e 相同。区别在于 \u003ccode\u003ewindow.onload\u003c/code\u003e 始终在所有其他 \u003ccode\u003eload\u003c/code\u003e 处理程序之后运行。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"markdown-body\",\"children\":[[\"$\",\"h1\",null,{\"children\":\"$undefined\"}],[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"front-end\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"front-end knowledge\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>