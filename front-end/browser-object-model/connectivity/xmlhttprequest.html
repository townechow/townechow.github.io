<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/d4dd73d504c89c58.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/485ff6fe79292a08.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/0ff121a467c0636f.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-53834dba86d90934.js"/><script src="/_next/static/chunks/4bd1b696-20882bf820444624.js" async=""></script><script src="/_next/static/chunks/517-98ed787e5f259f2c.js" async=""></script><script src="/_next/static/chunks/main-app-f33d3e3aed85e21f.js" async=""></script><meta name="next-size-adjust" content=""/><title>front-end</title><meta name="description" content="front-end knowledge"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><main><div class="markdown-body"><article><h1>XMLHttpRequest API</h1>
<p>使用 XMLHttpRequest（XHR） 对象可以与服务器交互。您可以从 URL 获取数据，而无需让整个的页面刷新。</p>
<p><strong>Ajax</strong>（Asynchronous JavaScript and XML）是一系列 Web 开发技术的集合，使用很多的 Web 技术在客户端开发异步 Web 应用。利用 Ajax，Web 应用可以异步的发送数据获取数据，而不干扰现有页面的显示和行为。通过解耦数据接口层和展现层，Ajax 允许 Web 页面或者其他扩展的 Web 应用动态的改变数据而不用重新加载整个页面。实现通常选择 JSON 代替 XML，因为更接近 JavaScript。</p>
<pre class="hljs"><code>EventTarget &lt;- XMLHttpRequestEventTarget &lt;- XMLHttpRequest
</code></pre>
<h2>基本用法</h2>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
</code></pre>
<h2>原型属性</h2>
<p>此接口继承了 <code>XMLHttpRequestEventTarget</code> 和 <code>EventTarget</code> 的属性。</p>
<table>
<thead>
<tr>
<th style="text-align:left">属性</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>onreadystatechange</code></td>
<td style="text-align:left">当 <code>readyState</code> 属性发生改变时，设定的回调函数会被调用</td>
<td style="text-align:left">Function</td>
</tr>
<tr>
<td style="text-align:left"><code>readyState</code></td>
<td style="text-align:left">（只读） 用于表示请求的五种状态</td>
<td style="text-align:left">unsigned short</td>
</tr>
<tr>
<td style="text-align:left"><code>response</code></td>
<td style="text-align:left">（只读） 用于获取整个响应实体，响应体的类型由 <code>responseType</code> 来指定</td>
<td style="text-align:left">Blob&lt;br/&gt;ArrayBuffer&lt;br/&gt;Document&lt;br/&gt;JSON&lt;br/&gt;String&lt;br/&gt;null（请求未完成或失败）</td>
</tr>
<tr>
<td style="text-align:left"><code>responseText</code></td>
<td style="text-align:left">（只读） 用于获取请求的响应文本</td>
<td style="text-align:left">DOMString&lt;br/&gt;null（请求未完成或失败）</td>
</tr>
<tr>
<td style="text-align:left"><code>responseType</code></td>
<td style="text-align:left">用于设置该值能够改变响应类型</td>
<td style="text-align:left">XMLHttpRequestResponseType</td>
</tr>
<tr>
<td style="text-align:left"><code>status</code></td>
<td style="text-align:left">（只读）用于获取请求的 <strong>响应状态码</strong></td>
<td style="text-align:left">unsigned short</td>
</tr>
<tr>
<td style="text-align:left"><code>statusText</code></td>
<td style="text-align:left">（只读）用于获取请求的 <strong>响应状态信息</strong>，包含一个状态码和消息文本</td>
<td style="text-align:left">DOMString</td>
</tr>
<tr>
<td style="text-align:left"><code>timeout</code></td>
<td style="text-align:left">用于表示请求 <strong>最大请求时间</strong>（毫秒），若超出该时间，请求会自动终止</td>
<td style="text-align:left">unsigned long</td>
</tr>
<tr>
<td style="text-align:left"><code>upload</code></td>
<td style="text-align:left">（只读） 用于在 <code>upload</code> 上添加一个 <strong>事件监听</strong> 来跟踪上传过程</td>
<td style="text-align:left">XMLHttpRequestUpload</td>
</tr>
<tr>
<td style="text-align:left"><code>withCredentials</code></td>
<td style="text-align:left">用于指定跨域 <code>Access-Control</code> 请求是否应当带有授权信息，如 Cookie 或授权首部字段</td>
<td style="text-align:left">Boolean</td>
</tr>
</tbody>
</table>
<h3>onreadystatechange</h3>
<p>使用示例：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://developer.mozilla.org/&#x27;</span>, <span class="hljs-literal">true</span>);
xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">if</span> (xhr.<span class="hljs-property">readyState</span> === <span class="hljs-title class_">XMLHttpRequest</span>.<span class="hljs-property">DONE</span> &amp;&amp; xhr.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(xhr.<span class="hljs-property">responseText</span>);
  }
};
xhr.<span class="hljs-title function_">send</span>();
</code></pre>
<h3>readyState</h3>
<table>
<thead>
<tr>
<th style="text-align:left">值</th>
<th style="text-align:left">状态</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left"><code>UNSENT</code></td>
<td style="text-align:left">请求代表被创建，但尚未调用 <code>open</code> 方法</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left"><code>OPENED</code></td>
<td style="text-align:left"><code>open</code> 方法已经被调用</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left"><code>HEADERS_RECEIVED</code></td>
<td style="text-align:left"><code>send</code> 方法已被调用，并且头部和状态已经可访问</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><code>LOADING</code></td>
<td style="text-align:left">下载中（<code>responseText</code> 属性已经包含部分数据）</td>
</tr>
<tr>
<td style="text-align:left">4</td>
<td style="text-align:left"><code>DONE</code></td>
<td style="text-align:left">下载操作已完成</td>
</tr>
</tbody>
</table>
<h2>原型方法</h2>
<p>下列原型方法按照请求的生命周期设定：</p>
<ul>
<li>请求发送前
<ul>
<li><a href="/front-end/browser-object-model/connectivity/#open">open</a></li>
<li><a href="/front-end/browser-object-model/connectivity/#set-request-header">setRequestHeader</a></li>
<li><a href="/front-end/browser-object-model/connectivity/#override-mime-type">overrideMimeType</a></li>
</ul>
</li>
<li>发送请求
<ul>
<li><a href="/front-end/browser-object-model/connectivity/#send">send</a></li>
</ul>
</li>
<li>请求发送后
<ul>
<li><a href="/front-end/browser-object-model/connectivity/#abort">abort</a></li>
</ul>
</li>
<li>
<h2>接收响应后</h2>
</li>
</ul>
<h3>open</h3>
<p><code>XMLHttpRequest.open</code> 方法用于初始化一个请求，。</p>
<p>语法：</p>
<pre class="hljs"><code class="language-js">xhr.<span class="hljs-title function_">open</span>(method, url);
xhr.<span class="hljs-title function_">open</span>(method, url, <span class="hljs-keyword">async</span>);
xhr.<span class="hljs-title function_">open</span>(method, url, <span class="hljs-keyword">async</span>, user);
xhr.<span class="hljs-title function_">open</span>(method, url, <span class="hljs-keyword">async</span>, user, password);
</code></pre>
<p>参数：</p>
<ul>
<li><code>method</code>：请求方法，如 GET、POST、PUT、DELETE</li>
<li><code>url</code>：请求的 URL 地址</li>
<li><code>async</code>：一个可选的布尔值参数，默认值为 <code>true</code>，表示执行异步操作。如果值为 <code>false</code>，则 <code>send</code> 方法不会返回任何东西，直到接收到了服务器的返回数据</li>
<li><code>user</code>：用户名（可选参数），用于授权。默认参数为空字符串</li>
<li><code>password</code>：密码（可选参数），用于授权。默认参数为空字符串</li>
</ul>
<p>使用方法：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();

xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://example.com/user&#x27;</span>);
</code></pre>
<p>注意事项：</p>
<ul>
<li>如果 <code>method</code> 不是有效的 HTTP 方法或 URL 地址不能被成功解析，将会抛出 <code>SyntaxError</code> 异常</li>
<li>如果请求方法（不区分大小写）为 <code>CONNECT</code>、<code>TRACE</code> 或 <code>TRACK</code> 将会抛出 <code>SecurityError</code> 异常</li>
</ul>
<h3>setRequestHeader</h3>
<p><code>XMLHttpRequest.sentRequestHeader</code> 方法用于设置 HTTP 请求头信息。</p>
<blockquote>
<p>⚠️ 注意：在这之前，你必须确认已经调用了 <code>open</code> 方法打开了一个 URL</p>
</blockquote>
<p>语法：</p>
<pre class="hljs"><code class="language-js">xhr.<span class="hljs-title function_">setRequestHeader</span>(header, value);
</code></pre>
<p>参数：</p>
<ul>
<li><code>header</code>：请求头名称</li>
<li><code>value</code>：请求头值</li>
</ul>
<h3>overrideMimeType</h3>
<p><code>XMLHttpRequest.overrideMimeType</code> 方法用于重写由服务器返回的 MIME 类型，使服务端响应信息中传输的数据按照指定 MIME 类型处理。</p>
<p>例如，可以用于强制把响应流当做  <code>text/xml</code>  来解析，即使服务器没有指明数据是这个类型。</p>
<blockquote>
<p>⚠️ 注意：这个方法必须在 <code>send</code> 之前被调用</p>
</blockquote>
<h3>send</h3>
<p><code>XMLHttpRequest.send</code> 方法用于发起网络请求。</p>
<ul>
<li>如果该请求是异步模式（默认），该方法会立即返回。</li>
<li>相反，如果请求是同步模式，则直到请求的响应完全接受以后，该方法才会返回。</li>
</ul>
<blockquote>
<p>⚠️ 注意：所有相关的事件绑定必须在调用 <code>send</code> 方法之前进行</p>
</blockquote>
<p>语法：</p>
<pre class="hljs"><code class="language-js">xhr.<span class="hljs-title function_">send</span>(body);
</code></pre>
<p>参数：</p>
<ul>
<li><code>body</code>：在 XHR 请求中要发送的数据体，可以是以下其中某种类型
<ul>
<li>ArrayBuffer</li>
<li>Blob</li>
<li>Document</li>
<li>DOMString</li>
<li>FormData</li>
<li>URLSearchParams</li>
<li>USVString</li>
<li>null</li>
</ul>
</li>
</ul>
<p>使用方法：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;/server&#x27;</span>, <span class="hljs-literal">true</span>);

xhr.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 请求结束后处理</span>
};

xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);
<span class="hljs-comment">// xhr.send(&#x27;Hello world!&#x27;)</span>
<span class="hljs-comment">// xhr.send(new Blob())</span>
<span class="hljs-comment">// xhr.send(new Int8Array())</span>
<span class="hljs-comment">// xhr.send({ form: &#x27;data&#x27; })</span>
<span class="hljs-comment">// xhr.send(document)</span>
</code></pre>
<h3>abort</h3>
<p><code>XMLHttpRequest.abort</code> 用于当请求已发送后立刻中止请求。当该方法执行后，<code>readyState</code> 将会被置为 <code>XMLHttpRequest.UNSENT</code>，并且请求的 <code>status</code> 属性置为 0。</p>
<h3>getRequestHeader</h3>
<p><code>XMLHttpRequest.getRequestHeader</code> 方法用于获取指定响应头的值，如果响应头还没有被接收，或该响应头不存在，则返回 <code>null</code>。</p>
<p>注意：使用该方法获取某些响应头时，浏览器会抛出异常，具体原因如下</p>
<ul>
<li>W3C 的 XHR 标准中做了限制，规定客户端无法获取 <code>response</code> 中的 <code>Set-Cookie</code>、<code>Set-Cookie2</code> 这 2 个字段，无论是同域还是跨域请求</li>
<li>W3C 的 CORS 标准对于跨域请求也做了限制，规定对于跨域请求，客户端允许获取的响应头首部字段只限于简单的响应首部字段（常见的响应首部字段如下）
<ul>
<li>Expires</li>
<li>Cache-Control</li>
<li>Last-Modified</li>
<li>Pragma</li>
<li>Access-Control-Expose-Headers</li>
<li>Content-Language</li>
<li>Content-Type</li>
</ul>
</li>
</ul>
<h3>getAllRequestHeaders</h3>
<p><code>XMLHttpRequest.getAllResquestHeaders</code> 方法用于获取所有响应头信息（响应头名和值），如果响应头还没有接收，则返回 <code>null</code>。</p>
<blockquote>
<p>⚠️ 注意：使用该方法获取的响应头首部字段与在开发者工具 Network 面板中看到的响应头不一致。</p>
</blockquote>
<h2>原型事件</h2>
<table>
<thead>
<tr>
<th style="text-align:left">事件名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>loadstart</code></td>
<td style="text-align:left">用于当网络请求发送后触发，即调用 <code>XMLHttpRequest.send</code> 方法后触发，若未被调用则不会触发</td>
</tr>
<tr>
<td style="text-align:left"><code>load</code></td>
<td style="text-align:left">用于当请求完成时触发，此时 <code>readyState</code> 值为 <code>DONE</code>（4）</td>
</tr>
<tr>
<td style="text-align:left"><code>loaded</code></td>
<td style="text-align:left">用于当某个资源的加载进度停止后触发，例如已经触发 <code>abort</code>、<code>error</code>、<code>load</code> 事件之后</td>
</tr>
<tr>
<td style="text-align:left"><code>progress</code></td>
<td style="text-align:left">用于当请求接收到数据的时候被周期性触发。</td>
</tr>
<tr>
<td style="text-align:left"><code>abort</code></td>
<td style="text-align:left">用于当请求被暂停时触发。</td>
</tr>
<tr>
<td style="text-align:left"><code>timeout</code></td>
<td style="text-align:left">用于当请求超出最大时间时触发。</td>
</tr>
<tr>
<td style="text-align:left"><code>error</code></td>
<td style="text-align:left">用于当请求遭遇异常时触发</td>
</tr>
</tbody>
</table>
<p>事件执行顺序：</p>
<ul>
<li>状态变更时触发
<ul>
<li><code>readystatechange</code>：<code>readyState</code> 状态变更时触发</li>
</ul>
</li>
<li>请求发送前
<ul>
<li><code>xhr.loadstart</code></li>
</ul>
</li>
<li>请求发送阶段
<ul>
<li><code>xhr.upload.onloadstart</code></li>
<li><code>xhr.upload.onprogress</code></li>
<li><code>xhr.upload.onload</code></li>
<li><code>xhr.upload.onloadend</code></li>
</ul>
</li>
<li>请求发送结束，开始加载资源后
<ul>
<li><code>xhr.onprogress</code></li>
<li><code>xhr.onload</code></li>
<li><code>xhr.onloadend</code></li>
</ul>
</li>
<li>异常处理
<ul>
<li><code>xhr.onabort</code></li>
<li><code>xhr.timeout</code></li>
<li><code>xhr.error</code></li>
</ul>
</li>
</ul>
<h2>应用示例</h2>
<h3>上传数据</h3>
<h3>下载数据</h3>
<h3>传输进度</h3>
<p>XMLHttpRequest 对象传送数据的时，通过 <code>progress</code> 事件可以获取传输进度信息。</p>
<p>它分成上传和下载两种情况：</p>
<ul>
<li>下载的 <code>progress</code> 事件属于 XMLHttpRequest 对象</li>
<li>上传的 <code>progress</code> 事件属于 XMLHttpRequest.upload 对象</li>
</ul>
<p>我们先定义 <code>progress</code> 事件的回调函数：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">updateProgress</span>(<span class="hljs-params">event</span>) {
  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">lengthComputable</span>) {
    <span class="hljs-keyword">var</span> percentComplete = event.<span class="hljs-property">loaded</span> / event.<span class="hljs-property">total</span>;
  }
}

xhr.<span class="hljs-property">onprogress</span> = updateProgress;
xhr.<span class="hljs-property">upload</span>.<span class="hljs-property">onprogress</span> = updateProgress;
</code></pre>
<p>上面的代码中，<code>event.total</code> 是需要传输的总字节，<code>event.loaded</code> 是已经传输的字节。如果 event.lengthComputable 不为真，则 <code>event.total</code> 等于 0。</p>
<h3>定时轮询</h3>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/xhr/long.svg&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;长轮询&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{520}</span> /&gt;</span></span>;
</code></pre>
<p>定时轮询的基本思路就是浏览器每隔一段时间向浏览器发送 HTTP 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。</p>
<p>这种方式的优点是比较简单，易于理解，实现起来也没有什么技术难点。缺点是显而易见的，这种方式由于需要不断的建立 HTTP 连接，严重浪费了服务器端和客户端的资源。尤其是在客户端，距离来说，如果有数量级想对比较大的人同时位于基于短轮询的应用中，那么每一个用户的客户端都会疯狂的向服务器端发送 HTTP 请求，而且不会间断。人数越多，服务器端压力越大，这是很不合理的。</p>
<p>因此短轮询不适用于那些同时在线用户数量比较大，并且很注重性能的 Web 应用。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();

<span class="hljs-comment">// 每 1000 毫秒向服务器发送一次轮询请求</span>
<span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;/server&#x27;</span>);
  xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {};
  xhr.<span class="hljs-title function_">send</span>();
}, <span class="hljs-number">1000</span>);
</code></pre>
<h3>长轮询</h3>
<p>当服务器收到客户端发来的请求后,服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制(服务器端设置)才返回。 。 客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。</p>
<p>长轮询和短轮询比起来，明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkUpdate</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();
  xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;/user&#x27;</span>);
  xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    <span class="hljs-title function_">checkUpdate</span>();
  };
  xhr.<span class="hljs-title function_">send</span>();
}
</code></pre>
<p>实现思路：</p>
<ol>
<li>处理接收到的数据并启动下一轮检测更新</li>
<li>启动下一轮检测更新</li>
<li>发起首次更新请求</li>
</ol>
<p>轮询与长轮询都是基于 HTTP 的，两者本身存在着缺陷：</p>
<ul>
<li>轮询需要更快的处理速度；</li>
<li>长轮询则更要求处理并发的能力；</li>
</ul>
<p>两者都是 <strong>被动型服务器</strong> 的体现：服务器不会主动推送信息，而是在客户端发送 AJAX 请求后进行返回的响应。而理想的模型是在服务器端数据有了变化后，可以主动推送给客户端，这种 <strong>主动型</strong> 服务器是解决这类问题的很好的方案。Web Sockets 就是这样的方案。</p>
<blockquote>
<p>那么长轮询总是比定期轮询更好的选择？</p>
</blockquote>
<p>除非消息到达率已知且不变，否则长轮询将始终提供更短的消息延迟。</p>
<p>另一方面，开销讨论需要更细微的观点。首先，请注意，每个传递的消息仍然引起相同的 HTTP 开销；每个新消息都是独立的 HTTP 请求。但是，如果消息到达率高，那么长时间轮询会比定期轮询发出更多的 XHR 请求！</p>
<p>长轮询通过最小化消息延迟来动态地适应消息到达速率，这是您可能想要的或可能不需要的行为。如果对消息延迟要求不高的话，则定时轮询可能是更有效的传输方式。例如，如果消息更新速率较高，则定时轮询提供简单的”消息聚合“机制（即合并一定时间内的消息），这可以减少请求数量并提高移动设备的电池寿命。</p>
<p>四种前端即时通讯技术比较：</p>
<ul>
<li>从兼容性考虑：<code>短轮询 &gt; 长轮询 &gt; 长连接 SSE &gt; WebSocket</code></li>
<li>从性能方面考虑：<code>WebSocket &gt; 长连接 SSE &gt; 长轮询 &gt; 短轮询</code></li>
</ul>
<h3>长连接</h3>
<hr>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://juejin.im/post/58e4a174ac502e006c1e18f4" target="_blank" rel="noopener noreferrer nofollow">你不知道的 XMLHttpRequest</a></li>
<li><a href="https://juejin.im/entry/5839848b67f356006ba4d453" target="_blank" rel="noopener noreferrer nofollow">前端必备 HTTP 技能之 Ajax 技术</a></li>
</ul>
</article></div></main><script src="/_next/static/chunks/webpack-53834dba86d90934.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5244,[],\"\"]\n3:I[3866,[],\"\"]\n5:I[6213,[],\"OutletBoundary\"]\n7:I[6213,[],\"MetadataBoundary\"]\n9:I[6213,[],\"ViewportBoundary\"]\nb:I[4835,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/d4dd73d504c89c58.css\",\"style\"]\n:HL[\"/_next/static/css/485ff6fe79292a08.css\",\"style\"]\n:HL[\"/_next/static/css/0ff121a467c0636f.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"1zJy3VHENUSg9vzcRvJ6P\",\"p\":\"\",\"c\":[\"\",\"front-end\",\"browser-object-model\",\"connectivity\",\"xmlhttprequest\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"front-end\",{\"children\":[[\"slug\",\"browser-object-model/connectivity/xmlhttprequest\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d4dd73d504c89c58.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"front-end\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/485ff6fe79292a08.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0ff121a467c0636f.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"main\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[[\"slug\",\"browser-object-model/connectivity/xmlhttprequest\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"cToRlKle6I7cvQRnLBdUX\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:T5a22,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eXMLHttpRequest API\u003c/h1\u003e\n\u003cp\u003e使用 XMLHttpRequest（XHR） 对象可以与服务器交互。您可以从 URL 获取数据，而无需让整个的页面刷新。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003eAjax\u003c/strong\u003e（Asynchronous JavaScript and XML）是一系列 Web 开发技术的集合，使用很多的 Web 技术在客户端开发异步 Web 应用。利用 Ajax，Web 应用可以异步的发送数据获取数据，而不干扰现有页面的显示和行为。通过解耦数据接口层和展现层，Ajax 允许 Web 页面或者其他扩展的 Web 应用动态的改变数据而不用重新加载整个页面。实现通常选择 JSON 代替 XML，因为更接近 JavaScript。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003eEventTarget \u0026lt;- XMLHttpRequestEventTarget \u0026lt;- XMLHttpRequest\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e基本用法\u003c/h2\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e xhr = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eXMLHttpRequest\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e原型属性\u003c/h2\u003e\n\u003cp\u003e此接口继承了 \u003ccode\u003eXMLHttpRequestEventTarget\u003c/code\u003e 和 \u003ccode\u003eEventTarget\u003c/code\u003e 的属性。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e属性\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e说明\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e类型\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eonreadystatechange\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e当 \u003ccode\u003ereadyState\u003c/code\u003e 属性发生改变时，设定的回调函数会被调用\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eFunction\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003ereadyState\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e（只读） 用于表示请求的五种状态\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eunsigned short\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eresponse\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e（只读） 用于获取整个响应实体，响应体的类型由 \u003ccode\u003eresponseType\u003c/code\u003e 来指定\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eBlob\u0026lt;br/\u0026gt;ArrayBuffer\u0026lt;br/\u0026gt;Document\u0026lt;br/\u0026gt;JSON\u0026lt;br/\u0026gt;String\u0026lt;br/\u0026gt;null（请求未完成或失败）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eresponseText\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e（只读） 用于获取请求的响应文本\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eDOMString\u0026lt;br/\u0026gt;null（请求未完成或失败）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eresponseType\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e用于设置该值能够改变响应类型\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eXMLHttpRequestResponseType\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003estatus\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e（只读）用于获取请求的 \u003cstrong\u003e响应状态码\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eunsigned short\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003estatusText\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e（只读）用于获取请求的 \u003cstrong\u003e响应状态信息\u003c/strong\u003e，包含一个状态码和消息文本\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eDOMString\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003etimeout\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e用于表示请求 \u003cstrong\u003e最大请求时间\u003c/strong\u003e（毫秒），若超出该时间，请求会自动终止\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eunsigned long\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eupload\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e（只读） 用于在 \u003ccode\u003eupload\u003c/code\u003e 上添加一个 \u003cstrong\u003e事件监听\u003c/strong\u003e 来跟踪上传过程\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eXMLHttpRequestUpload\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003ewithCredentials\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e用于指定跨域 \u003ccode\u003eAccess-Control\u003c/code\u003e 请求是否应当带有授权信息，如 Cookie 或授权首部字段\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eBoolean\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3\u003eonreadystatechange\u003c/h3\u003e\n\u003cp\u003e使用示例：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e xhr = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eXMLHttpRequest\u003c/span\u003e();\nxhr.\u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;GET\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;https://developer.mozilla.org/\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\nxhr.\u003cspan class=\"hljs-property\"\u003eonreadystatechange\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (xhr.\u003cspan class=\"hljs-property\"\u003ereadyState\u003c/span\u003e === \u003cspan class=\"hljs-title class_\"\u003eXMLHttpRequest\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eDONE\u003c/span\u003e \u0026amp;\u0026amp; xhr.\u003cspan class=\"hljs-property\"\u003estatus\u003c/span\u003e === \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(xhr.\u003cspan class=\"hljs-property\"\u003eresponseText\u003c/span\u003e);\n  }\n};\nxhr.\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003ereadyState\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e值\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e状态\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e描述\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e0\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eUNSENT\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e请求代表被创建，但尚未调用 \u003ccode\u003eopen\u003c/code\u003e 方法\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e1\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eOPENED\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eopen\u003c/code\u003e 方法已经被调用\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e2\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eHEADERS_RECEIVED\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003esend\u003c/code\u003e 方法已被调用，并且头部和状态已经可访问\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e3\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eLOADING\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e下载中（\u003ccode\u003eresponseText\u003c/code\u003e 属性已经包含部分数据）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e4\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eDONE\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e下载操作已完成\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2\u003e原型方法\u003c/h2\u003e\n\u003cp\u003e下列原型方法按照请求的生命周期设定：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e请求发送前\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/front-end/browser-object-model/connectivity/#open\"\u003eopen\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/front-end/browser-object-model/connectivity/#set-request-header\"\u003esetRequestHeader\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/front-end/browser-object-model/connectivity/#override-mime-type\"\u003eoverrideMimeType\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e发送请求\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/front-end/browser-object-model/connectivity/#send\"\u003esend\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e请求发送后\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/front-end/browser-object-model/connectivity/#abort\"\u003eabort\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003ch2\u003e接收响应后\u003c/h2\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eopen\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eXMLHttpRequest.open\u003c/code\u003e 方法用于初始化一个请求，。\u003c/p\u003e\n\u003cp\u003e语法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003exhr.\u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(method, url);\nxhr.\u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(method, url, \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e);\nxhr.\u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(method, url, \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e, user);\nxhr.\u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(method, url, \u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e, user, password);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e参数：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003emethod\u003c/code\u003e：请求方法，如 GET、POST、PUT、DELETE\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eurl\u003c/code\u003e：请求的 URL 地址\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003easync\u003c/code\u003e：一个可选的布尔值参数，默认值为 \u003ccode\u003etrue\u003c/code\u003e，表示执行异步操作。如果值为 \u003ccode\u003efalse\u003c/code\u003e，则 \u003ccode\u003esend\u003c/code\u003e 方法不会返回任何东西，直到接收到了服务器的返回数据\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003euser\u003c/code\u003e：用户名（可选参数），用于授权。默认参数为空字符串\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003epassword\u003c/code\u003e：密码（可选参数），用于授权。默认参数为空字符串\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e使用方法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e xhr = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eXMLHttpRequest\u003c/span\u003e();\n\nxhr.\u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;GET\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;https://example.com/user\u0026#x27;\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e注意事项：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果 \u003ccode\u003emethod\u003c/code\u003e 不是有效的 HTTP 方法或 URL 地址不能被成功解析，将会抛出 \u003ccode\u003eSyntaxError\u003c/code\u003e 异常\u003c/li\u003e\n\u003cli\u003e如果请求方法（不区分大小写）为 \u003ccode\u003eCONNECT\u003c/code\u003e、\u003ccode\u003eTRACE\u003c/code\u003e 或 \u003ccode\u003eTRACK\u003c/code\u003e 将会抛出 \u003ccode\u003eSecurityError\u003c/code\u003e 异常\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003esetRequestHeader\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eXMLHttpRequest.sentRequestHeader\u003c/code\u003e 方法用于设置 HTTP 请求头信息。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ 注意：在这之前，你必须确认已经调用了 \u003ccode\u003eopen\u003c/code\u003e 方法打开了一个 URL\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e语法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003exhr.\u003cspan class=\"hljs-title function_\"\u003esetRequestHeader\u003c/span\u003e(header, value);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e参数：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eheader\u003c/code\u003e：请求头名称\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003evalue\u003c/code\u003e：请求头值\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eoverrideMimeType\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eXMLHttpRequest.overrideMimeType\u003c/code\u003e 方法用于重写由服务器返回的 MIME 类型，使服务端响应信息中传输的数据按照指定 MIME 类型处理。\u003c/p\u003e\n\u003cp\u003e例如，可以用于强制把响应流当做  \u003ccode\u003etext/xml\u003c/code\u003e  来解析，即使服务器没有指明数据是这个类型。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ 注意：这个方法必须在 \u003ccode\u003esend\u003c/code\u003e 之前被调用\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003esend\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eXMLHttpRequest.send\u003c/code\u003e 方法用于发起网络请求。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果该请求是异步模式（默认），该方法会立即返回。\u003c/li\u003e\n\u003cli\u003e相反，如果请求是同步模式，则直到请求的响应完全接受以后，该方法才会返回。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ 注意：所有相关的事件绑定必须在调用 \u003ccode\u003esend\u003c/code\u003e 方法之前进行\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e语法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003exhr.\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(body);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e参数：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ebody\u003c/code\u003e：在 XHR 请求中要发送的数据体，可以是以下其中某种类型\n\u003cul\u003e\n\u003cli\u003eArrayBuffer\u003c/li\u003e\n\u003cli\u003eBlob\u003c/li\u003e\n\u003cli\u003eDocument\u003c/li\u003e\n\u003cli\u003eDOMString\u003c/li\u003e\n\u003cli\u003eFormData\u003c/li\u003e\n\u003cli\u003eURLSearchParams\u003c/li\u003e\n\u003cli\u003eUSVString\u003c/li\u003e\n\u003cli\u003enull\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e使用方法：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e xhr = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eXMLHttpRequest\u003c/span\u003e();\nxhr.\u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;GET\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;/server\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e);\n\nxhr.\u003cspan class=\"hljs-property\"\u003eonload\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 请求结束后处理\u003c/span\u003e\n};\n\nxhr.\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// xhr.send(\u0026#x27;Hello world!\u0026#x27;)\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// xhr.send(new Blob())\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// xhr.send(new Int8Array())\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// xhr.send({ form: \u0026#x27;data\u0026#x27; })\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// xhr.send(document)\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eabort\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eXMLHttpRequest.abort\u003c/code\u003e 用于当请求已发送后立刻中止请求。当该方法执行后，\u003ccode\u003ereadyState\u003c/code\u003e 将会被置为 \u003ccode\u003eXMLHttpRequest.UNSENT\u003c/code\u003e，并且请求的 \u003ccode\u003estatus\u003c/code\u003e 属性置为 0。\u003c/p\u003e\n\u003ch3\u003egetRequestHeader\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eXMLHttpRequest.getRequestHeader\u003c/code\u003e 方法用于获取指定响应头的值，如果响应头还没有被接收，或该响应头不存在，则返回 \u003ccode\u003enull\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e注意：使用该方法获取某些响应头时，浏览器会抛出异常，具体原因如下\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eW3C 的 XHR 标准中做了限制，规定客户端无法获取 \u003ccode\u003eresponse\u003c/code\u003e 中的 \u003ccode\u003eSet-Cookie\u003c/code\u003e、\u003ccode\u003eSet-Cookie2\u003c/code\u003e 这 2 个字段，无论是同域还是跨域请求\u003c/li\u003e\n\u003cli\u003eW3C 的 CORS 标准对于跨域请求也做了限制，规定对于跨域请求，客户端允许获取的响应头首部字段只限于简单的响应首部字段（常见的响应首部字段如下）\n\u003cul\u003e\n\u003cli\u003eExpires\u003c/li\u003e\n\u003cli\u003eCache-Control\u003c/li\u003e\n\u003cli\u003eLast-Modified\u003c/li\u003e\n\u003cli\u003ePragma\u003c/li\u003e\n\u003cli\u003eAccess-Control-Expose-Headers\u003c/li\u003e\n\u003cli\u003eContent-Language\u003c/li\u003e\n\u003cli\u003eContent-Type\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003egetAllRequestHeaders\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eXMLHttpRequest.getAllResquestHeaders\u003c/code\u003e 方法用于获取所有响应头信息（响应头名和值），如果响应头还没有接收，则返回 \u003ccode\u003enull\u003c/code\u003e。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ 注意：使用该方法获取的响应头首部字段与在开发者工具 Network 面板中看到的响应头不一致。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e原型事件\u003c/h2\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e事件名\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eloadstart\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e用于当网络请求发送后触发，即调用 \u003ccode\u003eXMLHttpRequest.send\u003c/code\u003e 方法后触发，若未被调用则不会触发\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eload\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e用于当请求完成时触发，此时 \u003ccode\u003ereadyState\u003c/code\u003e 值为 \u003ccode\u003eDONE\u003c/code\u003e（4）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eloaded\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e用于当某个资源的加载进度停止后触发，例如已经触发 \u003ccode\u003eabort\u003c/code\u003e、\u003ccode\u003eerror\u003c/code\u003e、\u003ccode\u003eload\u003c/code\u003e 事件之后\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eprogress\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e用于当请求接收到数据的时候被周期性触发。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eabort\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e用于当请求被暂停时触发。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003etimeout\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e用于当请求超出最大时间时触发。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eerror\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e用于当请求遭遇异常时触发\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e事件执行顺序：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e状态变更时触发\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ereadystatechange\u003c/code\u003e：\u003ccode\u003ereadyState\u003c/code\u003e 状态变更时触发\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e请求发送前\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003exhr.loadstart\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e请求发送阶段\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003exhr.upload.onloadstart\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003exhr.upload.onprogress\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003exhr.upload.onload\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003exhr.upload.onloadend\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e请求发送结束，开始加载资源后\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003exhr.onprogress\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003exhr.onload\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003exhr.onloadend\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e异常处理\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003exhr.onabort\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003exhr.timeout\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003exhr.error\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e应用示例\u003c/h2\u003e\n\u003ch3\u003e上传数据\u003c/h3\u003e\n\u003ch3\u003e下载数据\u003c/h3\u003e\n\u003ch3\u003e传输进度\u003c/h3\u003e\n\u003cp\u003eXMLHttpRequest 对象传送数据的时，通过 \u003ccode\u003eprogress\u003c/code\u003e 事件可以获取传输进度信息。\u003c/p\u003e\n\u003cp\u003e它分成上传和下载两种情况：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e下载的 \u003ccode\u003eprogress\u003c/code\u003e 事件属于 XMLHttpRequest 对象\u003c/li\u003e\n\u003cli\u003e上传的 \u003ccode\u003eprogress\u003c/code\u003e 事件属于 XMLHttpRequest.upload 对象\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e我们先定义 \u003ccode\u003eprogress\u003c/code\u003e 事件的回调函数：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eupdateProgress\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (event.\u003cspan class=\"hljs-property\"\u003elengthComputable\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e percentComplete = event.\u003cspan class=\"hljs-property\"\u003eloaded\u003c/span\u003e / event.\u003cspan class=\"hljs-property\"\u003etotal\u003c/span\u003e;\n  }\n}\n\nxhr.\u003cspan class=\"hljs-property\"\u003eonprogress\u003c/span\u003e = updateProgress;\nxhr.\u003cspan class=\"hljs-property\"\u003eupload\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eonprogress\u003c/span\u003e = updateProgress;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面的代码中，\u003ccode\u003eevent.total\u003c/code\u003e 是需要传输的总字节，\u003ccode\u003eevent.loaded\u003c/code\u003e 是已经传输的字节。如果 event.lengthComputable 不为真，则 \u003ccode\u003eevent.total\u003c/code\u003e 等于 0。\u003c/p\u003e\n\u003ch3\u003e定时轮询\u003c/h3\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e img \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;../../assets/xhr/long.svg\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e () =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;长轮询\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{img}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{520}\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e定时轮询的基本思路就是浏览器每隔一段时间向浏览器发送 HTTP 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。\u003c/p\u003e\n\u003cp\u003e这种方式的优点是比较简单，易于理解，实现起来也没有什么技术难点。缺点是显而易见的，这种方式由于需要不断的建立 HTTP 连接，严重浪费了服务器端和客户端的资源。尤其是在客户端，距离来说，如果有数量级想对比较大的人同时位于基于短轮询的应用中，那么每一个用户的客户端都会疯狂的向服务器端发送 HTTP 请求，而且不会间断。人数越多，服务器端压力越大，这是很不合理的。\u003c/p\u003e\n\u003cp\u003e因此短轮询不适用于那些同时在线用户数量比较大，并且很注重性能的 Web 应用。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e xhr = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eXMLHttpRequest\u003c/span\u003e();\n\n\u003cspan class=\"hljs-comment\"\u003e// 每 1000 毫秒向服务器发送一次轮询请求\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003esetInterval\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  xhr.\u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;GET\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;/server\u0026#x27;\u003c/span\u003e);\n  xhr.\u003cspan class=\"hljs-property\"\u003eonreadystatechange\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {};\n  xhr.\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e();\n}, \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e长轮询\u003c/h3\u003e\n\u003cp\u003e当服务器收到客户端发来的请求后,服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制(服务器端设置)才返回。 。 客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。\u003c/p\u003e\n\u003cp\u003e长轮询和短轮询比起来，明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003echeckUpdate\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e xhr = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eXMLHttpRequest\u003c/span\u003e();\n  xhr.\u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;GET\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;/user\u0026#x27;\u003c/span\u003e);\n  xhr.\u003cspan class=\"hljs-property\"\u003eonreadystatechange\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003echeckUpdate\u003c/span\u003e();\n  };\n  xhr.\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e();\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e实现思路：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e处理接收到的数据并启动下一轮检测更新\u003c/li\u003e\n\u003cli\u003e启动下一轮检测更新\u003c/li\u003e\n\u003cli\u003e发起首次更新请求\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e轮询与长轮询都是基于 HTTP 的，两者本身存在着缺陷：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e轮询需要更快的处理速度；\u003c/li\u003e\n\u003cli\u003e长轮询则更要求处理并发的能力；\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e两者都是 \u003cstrong\u003e被动型服务器\u003c/strong\u003e 的体现：服务器不会主动推送信息，而是在客户端发送 AJAX 请求后进行返回的响应。而理想的模型是在服务器端数据有了变化后，可以主动推送给客户端，这种 \u003cstrong\u003e主动型\u003c/strong\u003e 服务器是解决这类问题的很好的方案。Web Sockets 就是这样的方案。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e那么长轮询总是比定期轮询更好的选择？\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e除非消息到达率已知且不变，否则长轮询将始终提供更短的消息延迟。\u003c/p\u003e\n\u003cp\u003e另一方面，开销讨论需要更细微的观点。首先，请注意，每个传递的消息仍然引起相同的 HTTP 开销；每个新消息都是独立的 HTTP 请求。但是，如果消息到达率高，那么长时间轮询会比定期轮询发出更多的 XHR 请求！\u003c/p\u003e\n\u003cp\u003e长轮询通过最小化消息延迟来动态地适应消息到达速率，这是您可能想要的或可能不需要的行为。如果对消息延迟要求不高的话，则定时轮询可能是更有效的传输方式。例如，如果消息更新速率较高，则定时轮询提供简单的”消息聚合“机制（即合并一定时间内的消息），这可以减少请求数量并提高移动设备的电池寿命。\u003c/p\u003e\n\u003cp\u003e四种前端即时通讯技术比较：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e从兼容性考虑：\u003ccode\u003e短轮询 \u0026gt; 长轮询 \u0026gt; 长连接 SSE \u0026gt; WebSocket\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e从性能方面考虑：\u003ccode\u003eWebSocket \u0026gt; 长连接 SSE \u0026gt; 长轮询 \u0026gt; 短轮询\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e长连接\u003c/h3\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e参考资料：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.im/post/58e4a174ac502e006c1e18f4\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e你不知道的 XMLHttpRequest\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.im/entry/5839848b67f356006ba4d453\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e前端必备 HTTP 技能之 Ajax 技术\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"markdown-body\",\"children\":[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"front-end\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"front-end knowledge\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>