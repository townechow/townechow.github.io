<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/d4dd73d504c89c58.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/485ff6fe79292a08.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/0ff121a467c0636f.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-53834dba86d90934.js"/><script src="/_next/static/chunks/4bd1b696-20882bf820444624.js" async=""></script><script src="/_next/static/chunks/517-98ed787e5f259f2c.js" async=""></script><script src="/_next/static/chunks/main-app-f33d3e3aed85e21f.js" async=""></script><meta name="next-size-adjust" content=""/><title>front-end</title><meta name="description" content="front-end knowledge"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><main><div class="markdown-body"><article><h1>Service Worker</h1>
<p>Service Worker 也称服务工作线程，是浏览器在后台独立网页运行的脚本，也算作是 JavaScript 工作线程。它无法直接访问 DOM，因此，如果你需要操作页面的 DOM 节点的话，可以通过  <a href="https://html.spec.whatwg.org/multipage/workers.html#dom-worker-postmessage" target="_blank" rel="noopener noreferrer nofollow">postMessage</a>  来跟想控制的页面进行通信。 Service Worker 中的 API 大量采用 Promise 方式设计，因此代码比较友好。</p>
<p>在兼容性方面， Chrome Firefox Opera 都已经支持， Microsoft Edge 现在也表示公开支持。而之前 Safari 因为不计划支持被很多开发者吐槽，认为它将会是下一代 IE 。迫于压力下，现 Safari 也<a href="https://trac.webkit.org/wiki/FiveYearPlanFall2015" target="_blank" rel="noopener noreferrer nofollow">暗示未来会进行开发</a>。</p>
<p>如果网站要使用 Service Worker ，传输协议必须为 HTTPS 。因为 Service Worker 中会涉及到请求拦截，所以必须使用 HTTPS 协议来保证安全。 另外，如果需要本地调试 Service Worker 的话， <code>localhost</code>  是被支持的。</p>
<h2>概述</h2>
<p>若想理解 Service Workers 相关的一切，你首先应该阅读一下之前发布的有关 <a href="https://github.com/Troland/how-javascript-works/blob/master/worker" target="_blank" rel="noopener noreferrer nofollow">Web Workers</a> 的文章。</p>
<p>大体上，Service Worker 是一种 Web Worker，更准确地说，它更像是一个 <a href="https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker" target="_blank" rel="noopener noreferrer nofollow">Shared Worker</a>。</p>
<ul>
<li>Service Worker 运行在其全局脚本上下文中</li>
<li>不指定和某个网页绑定</li>
<li>不能够访问 DOM</li>
</ul>
<p>Service Worker 接口之所以让人感到兴奋的原因之一即它支持网络应用离线运行，这使得开发者能够完全控制网络应用的行为。</p>
<h2>生命周期</h2>
<p>Service Worker 的生命周期和网页完全不相关。它由以下几个步骤：</p>
<ul>
<li>下载（Download）</li>
<li>安装（Install）</li>
<li>激活（Activate）</li>
</ul>
<h3>下载</h3>
<p>这发生于浏览器下载包含 Service Worker 相关代码的  <code>.js</code>  文件。</p>
<h3>安装</h3>
<p>为了在网络应用中使用 Service Worker，首先得在 JavaScript 代码中对其进行注册。当 Service Worker 注册的时候，它会让浏览器在后台开始安装 Service Worker 的步骤。</p>
<p>当你的应用之前未注册过 Service Worker 的话，那么第一步将会是注册环节。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;serviceWorker&#x27;</span> <span class="hljs-keyword">in</span> navigator) {
  <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
    navigator.<span class="hljs-property">serviceWorker</span>
      .<span class="hljs-title function_">register</span>(<span class="hljs-string">&#x27;/sw.js&#x27;</span>)
      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">registeration</span> =&gt;</span> {
        <span class="hljs-comment">// success</span>
      })
      .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> {
        <span class="hljs-comment">// error</span>
      });
  });
}
</code></pre>
<p>请注意，以上 <code>'/sw.js'</code> 代表 Service Worker 作用域的范围为根域（也就是 Service Worker 脚本的位置），也就是说，即使你的页面在 <code>'/example/a.html'</code> 中也属于该 Service Worker 的控制范围。</p>
<p>Chrome 浏览器下，可以在  <code>chrome://inspect /#service-workers</code>  中，查看服务工作线程是否已经注册。如果调试的话，用隐身模式打开窗口会非常方便，因为从隐身窗口创建的任何注册和缓存在该窗口关闭后均将被清除。</p>
<p>除此之外，以上代码有几点需要注意：</p>
<ul>
<li>需要进行特性检测，判断浏览器是否支持。</li>
<li>最好在页面所有资源都已经加载完毕后，这个时候去加载 Service Worker 是一个非常好的时间点。因为在移动端，页面打开首屏时间非常关键。</li>
</ul>
<p>在安装阶段，最好加载和缓存一些静态资源。一旦静态资源缓存成功，Service Worker 的安装也就完成了。倘若加载失败－Service Worker 将会重试。一旦安装成功，静态资源也就缓存成功了。</p>
<p>假设用户第一次访问网络应用。现在还没有注册 Service Worker，而且浏览器无法事先知晓是否会最终安装它。如果进行安装，则浏览器将会为增加的线程开辟额外的 CPU 和内存，而这些资源原本是用来渲染网页的。</p>
<p><code>load</code> 事件会加载完所有的资源比如图片，样式之后触发。</p>
<p>最终的结果即是如果在页面中安装 Service Worker，将有可能导致页面延迟加载和渲染－不能够让用户尽快地访问网页。</p>
<p>需要注意的是这只会发生在第一次访问页面的时候。后续的页面访问不会被 Service Worker 的安装所影响。一旦在首次访问页面的时候激活了 Service Worker ，它就可以处理后续的页面访问所触发的页面加载/缓存事件。这是正确的，Service Worker 需要加载好以处理有限的网络带宽。</p>
<h3>激活</h3>
<p>安装完之后下一步即激活。该步骤是操作之前缓存资源的绝佳时机。</p>
<p>一旦激活，Service Worker 就可以开始控制在其作用域内的所有页面。一个有趣的事实即：注册了 Service Worker 的页面直到再次加载的时候才会被 Service Worker 进行处理。当 Service Worker 开始进行控制，它有以下几种状态：</p>
<ul>
<li>处理来自页面的网络或者消息请求所触发的 fetch 及 message 事件</li>
<li>中止以节约内存</li>
</ul>
<p>以下即其生命周期：</p>
<p><img src="/front-end/Users/mrsingsing/Desktop/9ffdbf83-64b9-4a9f-a15c-44282fe47d5e.png" alt="ServiceWorker生命周期-激活"></p>
<h2>处理 Service Worker 内部的安装过程</h2>
<p>在受控页面运行注册 Service Worker 的过程中，让我们来看看 Service Worker 脚本中发生的事情，它监听 Service Worker 实例的  <code>install</code>  事件。</p>
<p>以下为处理 <code>install</code> 安装事件所需要执行的步骤：</p>
<ul>
<li>打开缓存空间</li>
<li>缓存文件</li>
<li>确认是否所有的静态资源已缓存</li>
</ul>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">CACHE_NAME</span> = <span class="hljs-string">&#x27;my-web-app-cache&#x27;</span>;
<span class="hljs-keyword">const</span> urlsToCache = [<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-string">&#x27;/styles/base.css&#x27;</span>, <span class="hljs-string">&#x27;/dist/bundle.js&#x27;</span>];

self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;install&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
  <span class="hljs-comment">// 开始缓存文件</span>
  <span class="hljs-comment">// event.waitUntil使用promise来获得安装时长及安装是否失败</span>
  event.<span class="hljs-title function_">waitUntil</span>(
    caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">CACHE_NAME</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">cache</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;成功打开缓存空间&#x27;</span>);
      <span class="hljs-keyword">return</span> cache.<span class="hljs-title function_">addAll</span>(urlsToCache);
    })
  );
});
</code></pre>
<p>请注意，这里面有个缓存空间的概念，也即 <code>caches.open</code> 里的参数。因为每个页面对应的缓存空间可能不相同，有了缓存空间后也能更好的对缓存进行控制。打开缓存空间后，之后再调用 <code>cache.addAll()</code> 并传入文件数组进行缓存。</p>
<p>上述中，所有的文件都成功缓存才算成功，如果有任何文件下载失败，那么安装步骤就会失败。所以如果缓存列表过长的话，将会增加缓存失败的几率。</p>
<p>如果 <code>sw.js</code> 一直都不变化的话，那么 <code>install</code> 安装事件只有在首次安装的时候才会调用。</p>
<p>处理  <code>install</code>  事件完全是可选，当不进行处理的时候，跳过以上几个步骤即可。</p>
<h2>缓存运行时请求</h2>
<p>该部分才是干货。在这里可以看到如何拦截请求然后返回已创建的缓存（以及创建新的缓存）。</p>
<p>当 Service Worker 安装完成之后，用户会导航到另一个页面或者刷新当前页面，Service Worker 将会触发 fetch 事件。这里有一个演示了如何返回缓存的静态资源或执行一个新的请求并缓存返回结果的过程的示例：</p>
<pre class="hljs"><code class="language-js">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {
  event.<span class="hljs-title function_">respondWith</span>(
    <span class="hljs-comment">// 该方法查询请求然后返回Service Worker创建的任何缓存数据</span>
    caches.<span class="hljs-title function_">match</span>(event.<span class="hljs-property">request</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) {
      <span class="hljs-comment">// 若有缓存,则返回</span>
      <span class="hljs-keyword">if</span> (response) {
        <span class="hljs-keyword">return</span> response;
      }

      <span class="hljs-comment">// 复制请求。请求是一个流且只能被使用一次。因为之前已经通过缓存使用过一次了，所以为了在浏览器中使用fetch,需要复制下该请求</span>
      <span class="hljs-keyword">const</span> fetchRequest = event.<span class="hljs-property">request</span>.<span class="hljs-title function_">clone</span>();

      <span class="hljs-comment">// 没有找到缓存。所以我们需要执行fetch以发起请求并返回请求数据</span>
      <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(fetchRequest).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">response</span>) {
        <span class="hljs-comment">// 检测返回数据是否有效</span>
        <span class="hljs-keyword">if</span> (!response || response.<span class="hljs-property">status</span> !== <span class="hljs-number">200</span> || !response.<span class="hljs-property">type</span> !== <span class="hljs-string">&#x27;basic&#x27;</span>) {
          <span class="hljs-keyword">return</span> response;
        }

        <span class="hljs-comment">// 复制返回数据,因为它也是流。因为我们想要浏览器和缓存一样使用返回数据,所以必须复制它。这样就有两个流</span>
        <span class="hljs-keyword">const</span> responseToCache = response.<span class="hljs-title function_">clone</span>();

        caches.<span class="hljs-title function_">open</span>(<span class="hljs-variable constant_">CACHE_NAME</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">cache</span>) {
          <span class="hljs-comment">// 把请求添加到缓存中以备之后的查询用</span>
          cache.<span class="hljs-title function_">put</span>(event.<span class="hljs-property">request</span>, responseToCache);
        });

        <span class="hljs-keyword">return</span> response;
      });
    })
  );
});
</code></pre>
<p>上述是一个简单的例子：有缓存的话直接返回缓存文件，没缓存的话获取源文件并返回。如果做的好的话，可以在发现没缓存的时候，把它先缓存下来，再进行返回。</p>
<p>大概的流程如下：</p>
<ul>
<li><code>event.respondWith()</code> 会决定如何响应 <code>fetch</code> 事件。 <code>caches.match()</code> 查询请求然后返回之前创建的缓存中的任意缓存数据并返回 promise。</li>
<li>如果有，则返回该缓存数据。</li>
<li>否则，执行 <code>fetch</code> 。</li>
<li>检查返回的状态码是否是 <code>200</code>。同时检查响应类型是否为 basic，即检查请求是否同域。当前场景不缓存第三方资源的请求。</li>
<li>把返回数据添加到缓存中。</li>
</ul>
<p>因为请求和响应都是流而流数据只能被使用一次，所以必须进行复制。而且由于缓存和浏览器都需要使用它们，所以必须进行复制。</p>
<h2>更新 Service Worker</h2>
<p>当用户访问网络应用的时候，浏览器会在后台试图重新下载 Service Worker 文件。</p>
<p>浏览器一旦判断到新的服务工作线程文件与其当前所用文件存在<strong>字节差异</strong>，则将其视为“新服务工作线程”。接下来就会做以下事情：</p>
<ol>
<li>新的服务工作线程启动，并触发 <code>install</code> 安装事件。</li>
<li>此时，旧服务工作线程仍控制着当前页面，因此新服务工作线程将进入 <code>waiting</code> 等待状态。</li>
<li>当网站上当前打开的页面关闭时，旧服务工作线程将会被终止，新服务工作线程将会取得控制权。</li>
<li>新服务工作线程取得控制权后，将会触发其 <code>activate</code> 激活事件。</li>
</ol>
<p>通常在 <code>activate</code> 激活事件中，我们会清除旧版本的缓存。</p>
<p>为什么所有这一切是必须的呢？这是为了避免在不同选项卡中同时运行不同版本的的网络应用所造成的问题，一些在网页中实际存在的问题且有可能会产生新的 BUG（比如当在浏览器中本地存储数据的时候却拥有不同的数据库结构）。</p>
<h2>从缓存中删除数据</h2>
<p><code>activate</code> 回调中最为常见的步骤即缓存管理。因为若想删除安装步骤中老旧的缓存，而这又会导致 Service Workers 无法获取该缓存中的文件数据，所以，这时候需要进行缓存管理。</p>
<p>这里有一个示例演示如何把未在白名单中的缓存删除（该情况下，以 <code>page-1</code> 或者 <code>page-2</code> 来进行命名）：</p>
<pre class="hljs"><code class="language-js">self.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;activate&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {
  <span class="hljs-keyword">const</span> cacheWhitelist = [<span class="hljs-string">&#x27;page-1&#x27;</span>, <span class="hljs-string">&#x27;page-2&#x27;</span>];

  event.<span class="hljs-title function_">waitUntil</span>(
    <span class="hljs-comment">// 获得缓存中所有键</span>
    caches.<span class="hljs-title function_">keys</span>().<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">cacheNames</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(
        <span class="hljs-comment">// 遍历所有的缓存文件</span>
        cacheNames.<span class="hljs-title function_">map</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">cacheName</span>) {
          <span class="hljs-comment">// 若缓存文件不在白名单中，删除之</span>
          <span class="hljs-keyword">if</span> (cacheWhitelist.<span class="hljs-title function_">indexOf</span>(cacheName) === -<span class="hljs-number">1</span>) {
            <span class="hljs-keyword">return</span> caches.<span class="hljs-title function_">delete</span>(cacheName);
          }
        })
      );
    })
  );
});
</code></pre>
<h2>注意事项</h2>
<h3>Cookie 设置</h3>
<p>在 Service Worker 中使用 <code>fetch</code> 的时候，请求头中默认不包含 Cookie，如果要添加 Cookie 的话，需要增加 <code>credentials</code> 参数。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-title function_">fetch</span>(url, {
  <span class="hljs-attr">credentials</span>: <span class="hljs-string">&#x27;include&#x27;</span>,
});
</code></pre>
<h3>HTTPS 要求</h3>
<p>当处于开发阶段的时候，可以通过 localhost 来使用 Service Workers ，但当处于发布环境的时候，必须部署好 HTTPS（这也是使用 HTTPS 的最后一个原因了）。</p>
<p>可以利用 Service Worker 劫持网络连接和伪造响应数据。如果不使用 HTTPS，网络应用会容易遭受<a href="https://en.wikipedia.org/wiki/Man-in-the-middle_attack" target="_blank" rel="noopener noreferrer nofollow">中间人</a> 攻击。</p>
<p>为了保证安全，必须通过 HTTPS 在页面上注册 Service Workers，这样就可以保证浏览器接收到的 Service Worker 没有在传输过程中被篡改。</p>
<h2>应用场景</h2>
<p>以下罗列了几点当前以及将来 Service Worker 能做的事情：</p>
<ul>
<li>拦截网络</li>
<li>离线缓存：可以将 H5 应用中不变化的资源或者很少变化的资源长久的存储在客户端，提升加载速度、降低流量消耗、降低服务器压力。如中重度的 H5 游戏、框架数据独立的 Web 资讯客户端、Web 邮件客户端等。</li>
<li>消息推送：激活沉睡的用户，推送即时信息、公告通告，激发更新等。如 Web 资讯客户端、Web 即时通讯工具、H5 游戏等运营产品。</li>
<li>事件同步：确保 Web 端产生的任务即使在用户关闭了 Web 页面也可以顺利完成。如 Web 邮件客户端、Web 即时通讯工具等。</li>
<li>定时同步（未来支持）：周期性的触发 Service Worker 脚本中的定时同步事件，可借助它提前刷新缓存内容。如 Web 资讯客户端。</li>
<li>地理围栏（未来支持）：地理围栏（Geo-fencing）是 LBS 的一种新应用，就是用一个虚拟的栅栏围出一个虚拟地理边界。当手机进入、离开某个特定地理区域，或在该区域内活动时，手机可以接收自动通知和警告。</li>
</ul>
<h2>浏览器支持情况</h2>
<p>Service Workers 拥有良好的浏览器兼容性。</p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/service-worker/server-worker-compatibility.png&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Service Workers 浏览器兼容性&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{800}</span> /&gt;</span></span>;
</code></pre>
<h2>总结</h2>
<p>除了离线缓存外，利用 Service Worker 还可以做很多令人兴奋的功能。比如：</p>
<ul>
<li>客户端编译（把原来本地/服务端 Webpack 打包编译的事情放在 <code>client</code> 中）</li>
<li>预请求 Prefetch（SSR 框架 next.js 提供了 Link 组件来实现预请求渲染）</li>
</ul>
<p>利用 Service Worker 能大大提升 Progress Web App（PWA） 的体验，现在各大厂商都表示支持，也代表了未来的趋势。另外， Google 提供了一套 Service Worker 库，可以消除服务工作线程样板文件代码，从而简化开发工作。</p>
<ul>
<li><a href="https://github.com/GoogleChrome/sw-precache/" target="_blank" rel="noopener noreferrer nofollow">sw-precache</a>—与构建流程集成，以生成服务工作线程，用于预缓存静态资产，例如 Application Shell。</li>
<li><a href="https://github.com/GoogleChrome/sw-toolbox/" target="_blank" rel="noopener noreferrer nofollow">sw-toolbox</a>—实现常见运行时缓存模式，例如动态内容、API 调用以及第三方资源，实现方法就像编写 README 一样简单。</li>
<li>sw-offline-google-analytics—临时保留并重试 Analytics 请求，以避免请求因网络断开连接而丢失。</li>
</ul>
<hr>
<p><strong>参考文档：</strong></p>
<ul>
<li><a href="https://www.w3.org/TR/service-workers" target="_blank" rel="noopener noreferrer nofollow">官方英文文档：Service Worker</a></li>
<li><a href="https://github.com/Leslie2014/blog/issues/1" target="_blank" rel="noopener noreferrer nofollow">初识 Service Worker 及简单应用</a></li>
<li><a href="https://x5.tencent.com/product/service-worker.html" target="_blank" rel="noopener noreferrer nofollow">腾讯浏览器服务：Service Worker 简介</a></li>
<li><a href="http://www.fly63.com/article/detial/234" target="_blank" rel="noopener noreferrer nofollow">ServiceWorker 的生命周期</a></li>
<li><a href="https://github.com/neal1991/articles-translator/blob/master/Service%20worker%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener noreferrer nofollow">Github：Service Worker Explained</a></li>
<li><a href="https://blog.csdn.net/ztguang/article/details/53750479" target="_blank" rel="noopener noreferrer nofollow">CSDN：Service Worker 入门 - PWA 强依赖于 Service Worker</a></li>
<li><a href="https://github.com/delapuente/service-workers-101" target="_blank" rel="noopener noreferrer nofollow">📍Github：Service Worker 101</a></li>
<li><a href="https://jakearchibald.com/2014/service-worker-first-draft/" target="_blank" rel="noopener noreferrer nofollow">Service Worker - first draft published</a></li>
</ul>
</article></div></main><script src="/_next/static/chunks/webpack-53834dba86d90934.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5244,[],\"\"]\n3:I[3866,[],\"\"]\n5:I[6213,[],\"OutletBoundary\"]\n7:I[6213,[],\"MetadataBoundary\"]\n9:I[6213,[],\"ViewportBoundary\"]\nb:I[4835,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/d4dd73d504c89c58.css\",\"style\"]\n:HL[\"/_next/static/css/485ff6fe79292a08.css\",\"style\"]\n:HL[\"/_next/static/css/0ff121a467c0636f.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"1zJy3VHENUSg9vzcRvJ6P\",\"p\":\"\",\"c\":[\"\",\"front-end\",\"browser-object-model\",\"offline-and-storage\",\"service-worker\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"front-end\",{\"children\":[[\"slug\",\"browser-object-model/offline-and-storage/service-worker\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d4dd73d504c89c58.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"front-end\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/485ff6fe79292a08.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0ff121a467c0636f.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"main\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[[\"slug\",\"browser-object-model/offline-and-storage/service-worker\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"6BJsEhMJC9U5C2KciZYvk\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:T592f,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eService Worker\u003c/h1\u003e\n\u003cp\u003eService Worker 也称服务工作线程，是浏览器在后台独立网页运行的脚本，也算作是 JavaScript 工作线程。它无法直接访问 DOM，因此，如果你需要操作页面的 DOM 节点的话，可以通过  \u003ca href=\"https://html.spec.whatwg.org/multipage/workers.html#dom-worker-postmessage\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003epostMessage\u003c/a\u003e  来跟想控制的页面进行通信。 Service Worker 中的 API 大量采用 Promise 方式设计，因此代码比较友好。\u003c/p\u003e\n\u003cp\u003e在兼容性方面， Chrome Firefox Opera 都已经支持， Microsoft Edge 现在也表示公开支持。而之前 Safari 因为不计划支持被很多开发者吐槽，认为它将会是下一代 IE 。迫于压力下，现 Safari 也\u003ca href=\"https://trac.webkit.org/wiki/FiveYearPlanFall2015\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e暗示未来会进行开发\u003c/a\u003e。\u003c/p\u003e\n\u003cp\u003e如果网站要使用 Service Worker ，传输协议必须为 HTTPS 。因为 Service Worker 中会涉及到请求拦截，所以必须使用 HTTPS 协议来保证安全。 另外，如果需要本地调试 Service Worker 的话， \u003ccode\u003elocalhost\u003c/code\u003e  是被支持的。\u003c/p\u003e\n\u003ch2\u003e概述\u003c/h2\u003e\n\u003cp\u003e若想理解 Service Workers 相关的一切，你首先应该阅读一下之前发布的有关 \u003ca href=\"https://github.com/Troland/how-javascript-works/blob/master/worker\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003eWeb Workers\u003c/a\u003e 的文章。\u003c/p\u003e\n\u003cp\u003e大体上，Service Worker 是一种 Web Worker，更准确地说，它更像是一个 \u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/API/SharedWorker\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003eShared Worker\u003c/a\u003e。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eService Worker 运行在其全局脚本上下文中\u003c/li\u003e\n\u003cli\u003e不指定和某个网页绑定\u003c/li\u003e\n\u003cli\u003e不能够访问 DOM\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eService Worker 接口之所以让人感到兴奋的原因之一即它支持网络应用离线运行，这使得开发者能够完全控制网络应用的行为。\u003c/p\u003e\n\u003ch2\u003e生命周期\u003c/h2\u003e\n\u003cp\u003eService Worker 的生命周期和网页完全不相关。它由以下几个步骤：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e下载（Download）\u003c/li\u003e\n\u003cli\u003e安装（Install）\u003c/li\u003e\n\u003cli\u003e激活（Activate）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e下载\u003c/h3\u003e\n\u003cp\u003e这发生于浏览器下载包含 Service Worker 相关代码的  \u003ccode\u003e.js\u003c/code\u003e  文件。\u003c/p\u003e\n\u003ch3\u003e安装\u003c/h3\u003e\n\u003cp\u003e为了在网络应用中使用 Service Worker，首先得在 JavaScript 代码中对其进行注册。当 Service Worker 注册的时候，它会让浏览器在后台开始安装 Service Worker 的步骤。\u003c/p\u003e\n\u003cp\u003e当你的应用之前未注册过 Service Worker 的话，那么第一步将会是注册环节。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-string\"\u003e\u0026#x27;serviceWorker\u0026#x27;\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003ein\u003c/span\u003e navigator) {\n  \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;load\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    navigator.\u003cspan class=\"hljs-property\"\u003eserviceWorker\u003c/span\u003e\n      .\u003cspan class=\"hljs-title function_\"\u003eregister\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;/sw.js\u0026#x27;\u003c/span\u003e)\n      .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eregisteration\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// success\u003c/span\u003e\n      })\n      .\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n        \u003cspan class=\"hljs-comment\"\u003e// error\u003c/span\u003e\n      });\n  });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e请注意，以上 \u003ccode\u003e'/sw.js'\u003c/code\u003e 代表 Service Worker 作用域的范围为根域（也就是 Service Worker 脚本的位置），也就是说，即使你的页面在 \u003ccode\u003e'/example/a.html'\u003c/code\u003e 中也属于该 Service Worker 的控制范围。\u003c/p\u003e\n\u003cp\u003eChrome 浏览器下，可以在  \u003ccode\u003echrome://inspect /#service-workers\u003c/code\u003e  中，查看服务工作线程是否已经注册。如果调试的话，用隐身模式打开窗口会非常方便，因为从隐身窗口创建的任何注册和缓存在该窗口关闭后均将被清除。\u003c/p\u003e\n\u003cp\u003e除此之外，以上代码有几点需要注意：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e需要进行特性检测，判断浏览器是否支持。\u003c/li\u003e\n\u003cli\u003e最好在页面所有资源都已经加载完毕后，这个时候去加载 Service Worker 是一个非常好的时间点。因为在移动端，页面打开首屏时间非常关键。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e在安装阶段，最好加载和缓存一些静态资源。一旦静态资源缓存成功，Service Worker 的安装也就完成了。倘若加载失败－Service Worker 将会重试。一旦安装成功，静态资源也就缓存成功了。\u003c/p\u003e\n\u003cp\u003e假设用户第一次访问网络应用。现在还没有注册 Service Worker，而且浏览器无法事先知晓是否会最终安装它。如果进行安装，则浏览器将会为增加的线程开辟额外的 CPU 和内存，而这些资源原本是用来渲染网页的。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eload\u003c/code\u003e 事件会加载完所有的资源比如图片，样式之后触发。\u003c/p\u003e\n\u003cp\u003e最终的结果即是如果在页面中安装 Service Worker，将有可能导致页面延迟加载和渲染－不能够让用户尽快地访问网页。\u003c/p\u003e\n\u003cp\u003e需要注意的是这只会发生在第一次访问页面的时候。后续的页面访问不会被 Service Worker 的安装所影响。一旦在首次访问页面的时候激活了 Service Worker ，它就可以处理后续的页面访问所触发的页面加载/缓存事件。这是正确的，Service Worker 需要加载好以处理有限的网络带宽。\u003c/p\u003e\n\u003ch3\u003e激活\u003c/h3\u003e\n\u003cp\u003e安装完之后下一步即激活。该步骤是操作之前缓存资源的绝佳时机。\u003c/p\u003e\n\u003cp\u003e一旦激活，Service Worker 就可以开始控制在其作用域内的所有页面。一个有趣的事实即：注册了 Service Worker 的页面直到再次加载的时候才会被 Service Worker 进行处理。当 Service Worker 开始进行控制，它有以下几种状态：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e处理来自页面的网络或者消息请求所触发的 fetch 及 message 事件\u003c/li\u003e\n\u003cli\u003e中止以节约内存\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e以下即其生命周期：\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/front-end/Users/mrsingsing/Desktop/9ffdbf83-64b9-4a9f-a15c-44282fe47d5e.png\" alt=\"ServiceWorker生命周期-激活\"\u003e\u003c/p\u003e\n\u003ch2\u003e处理 Service Worker 内部的安装过程\u003c/h2\u003e\n\u003cp\u003e在受控页面运行注册 Service Worker 的过程中，让我们来看看 Service Worker 脚本中发生的事情，它监听 Service Worker 实例的  \u003ccode\u003einstall\u003c/code\u003e  事件。\u003c/p\u003e\n\u003cp\u003e以下为处理 \u003ccode\u003einstall\u003c/code\u003e 安装事件所需要执行的步骤：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e打开缓存空间\u003c/li\u003e\n\u003cli\u003e缓存文件\u003c/li\u003e\n\u003cli\u003e确认是否所有的静态资源已缓存\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eCACHE_NAME\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;my-web-app-cache\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e urlsToCache = [\u003cspan class=\"hljs-string\"\u003e\u0026#x27;/\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;/styles/base.css\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;/dist/bundle.js\u0026#x27;\u003c/span\u003e];\n\nself.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;install\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-comment\"\u003e// 开始缓存文件\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// event.waitUntil使用promise来获得安装时长及安装是否失败\u003c/span\u003e\n  event.\u003cspan class=\"hljs-title function_\"\u003ewaitUntil\u003c/span\u003e(\n    caches.\u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eCACHE_NAME\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecache\u003c/span\u003e) {\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;成功打开缓存空间\u0026#x27;\u003c/span\u003e);\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e cache.\u003cspan class=\"hljs-title function_\"\u003eaddAll\u003c/span\u003e(urlsToCache);\n    })\n  );\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e请注意，这里面有个缓存空间的概念，也即 \u003ccode\u003ecaches.open\u003c/code\u003e 里的参数。因为每个页面对应的缓存空间可能不相同，有了缓存空间后也能更好的对缓存进行控制。打开缓存空间后，之后再调用 \u003ccode\u003ecache.addAll()\u003c/code\u003e 并传入文件数组进行缓存。\u003c/p\u003e\n\u003cp\u003e上述中，所有的文件都成功缓存才算成功，如果有任何文件下载失败，那么安装步骤就会失败。所以如果缓存列表过长的话，将会增加缓存失败的几率。\u003c/p\u003e\n\u003cp\u003e如果 \u003ccode\u003esw.js\u003c/code\u003e 一直都不变化的话，那么 \u003ccode\u003einstall\u003c/code\u003e 安装事件只有在首次安装的时候才会调用。\u003c/p\u003e\n\u003cp\u003e处理  \u003ccode\u003einstall\u003c/code\u003e  事件完全是可选，当不进行处理的时候，跳过以上几个步骤即可。\u003c/p\u003e\n\u003ch2\u003e缓存运行时请求\u003c/h2\u003e\n\u003cp\u003e该部分才是干货。在这里可以看到如何拦截请求然后返回已创建的缓存（以及创建新的缓存）。\u003c/p\u003e\n\u003cp\u003e当 Service Worker 安装完成之后，用户会导航到另一个页面或者刷新当前页面，Service Worker 将会触发 fetch 事件。这里有一个演示了如何返回缓存的静态资源或执行一个新的请求并缓存返回结果的过程的示例：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003eself.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;fetch\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) {\n  event.\u003cspan class=\"hljs-title function_\"\u003erespondWith\u003c/span\u003e(\n    \u003cspan class=\"hljs-comment\"\u003e// 该方法查询请求然后返回Service Worker创建的任何缓存数据\u003c/span\u003e\n    caches.\u003cspan class=\"hljs-title function_\"\u003ematch\u003c/span\u003e(event.\u003cspan class=\"hljs-property\"\u003erequest\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e) {\n      \u003cspan class=\"hljs-comment\"\u003e// 若有缓存,则返回\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (response) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response;\n      }\n\n      \u003cspan class=\"hljs-comment\"\u003e// 复制请求。请求是一个流且只能被使用一次。因为之前已经通过缓存使用过一次了，所以为了在浏览器中使用fetch,需要复制下该请求\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fetchRequest = event.\u003cspan class=\"hljs-property\"\u003erequest\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eclone\u003c/span\u003e();\n\n      \u003cspan class=\"hljs-comment\"\u003e// 没有找到缓存。所以我们需要执行fetch以发起请求并返回请求数据\u003c/span\u003e\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(fetchRequest).\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eresponse\u003c/span\u003e) {\n        \u003cspan class=\"hljs-comment\"\u003e// 检测返回数据是否有效\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!response || response.\u003cspan class=\"hljs-property\"\u003estatus\u003c/span\u003e !== \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e || !response.\u003cspan class=\"hljs-property\"\u003etype\u003c/span\u003e !== \u003cspan class=\"hljs-string\"\u003e\u0026#x27;basic\u0026#x27;\u003c/span\u003e) {\n          \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response;\n        }\n\n        \u003cspan class=\"hljs-comment\"\u003e// 复制返回数据,因为它也是流。因为我们想要浏览器和缓存一样使用返回数据,所以必须复制它。这样就有两个流\u003c/span\u003e\n        \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e responseToCache = response.\u003cspan class=\"hljs-title function_\"\u003eclone\u003c/span\u003e();\n\n        caches.\u003cspan class=\"hljs-title function_\"\u003eopen\u003c/span\u003e(\u003cspan class=\"hljs-variable constant_\"\u003eCACHE_NAME\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecache\u003c/span\u003e) {\n          \u003cspan class=\"hljs-comment\"\u003e// 把请求添加到缓存中以备之后的查询用\u003c/span\u003e\n          cache.\u003cspan class=\"hljs-title function_\"\u003eput\u003c/span\u003e(event.\u003cspan class=\"hljs-property\"\u003erequest\u003c/span\u003e, responseToCache);\n        });\n\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e response;\n      });\n    })\n  );\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上述是一个简单的例子：有缓存的话直接返回缓存文件，没缓存的话获取源文件并返回。如果做的好的话，可以在发现没缓存的时候，把它先缓存下来，再进行返回。\u003c/p\u003e\n\u003cp\u003e大概的流程如下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eevent.respondWith()\u003c/code\u003e 会决定如何响应 \u003ccode\u003efetch\u003c/code\u003e 事件。 \u003ccode\u003ecaches.match()\u003c/code\u003e 查询请求然后返回之前创建的缓存中的任意缓存数据并返回 promise。\u003c/li\u003e\n\u003cli\u003e如果有，则返回该缓存数据。\u003c/li\u003e\n\u003cli\u003e否则，执行 \u003ccode\u003efetch\u003c/code\u003e 。\u003c/li\u003e\n\u003cli\u003e检查返回的状态码是否是 \u003ccode\u003e200\u003c/code\u003e。同时检查响应类型是否为 basic，即检查请求是否同域。当前场景不缓存第三方资源的请求。\u003c/li\u003e\n\u003cli\u003e把返回数据添加到缓存中。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e因为请求和响应都是流而流数据只能被使用一次，所以必须进行复制。而且由于缓存和浏览器都需要使用它们，所以必须进行复制。\u003c/p\u003e\n\u003ch2\u003e更新 Service Worker\u003c/h2\u003e\n\u003cp\u003e当用户访问网络应用的时候，浏览器会在后台试图重新下载 Service Worker 文件。\u003c/p\u003e\n\u003cp\u003e浏览器一旦判断到新的服务工作线程文件与其当前所用文件存在\u003cstrong\u003e字节差异\u003c/strong\u003e，则将其视为“新服务工作线程”。接下来就会做以下事情：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e新的服务工作线程启动，并触发 \u003ccode\u003einstall\u003c/code\u003e 安装事件。\u003c/li\u003e\n\u003cli\u003e此时，旧服务工作线程仍控制着当前页面，因此新服务工作线程将进入 \u003ccode\u003ewaiting\u003c/code\u003e 等待状态。\u003c/li\u003e\n\u003cli\u003e当网站上当前打开的页面关闭时，旧服务工作线程将会被终止，新服务工作线程将会取得控制权。\u003c/li\u003e\n\u003cli\u003e新服务工作线程取得控制权后，将会触发其 \u003ccode\u003eactivate\u003c/code\u003e 激活事件。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e通常在 \u003ccode\u003eactivate\u003c/code\u003e 激活事件中，我们会清除旧版本的缓存。\u003c/p\u003e\n\u003cp\u003e为什么所有这一切是必须的呢？这是为了避免在不同选项卡中同时运行不同版本的的网络应用所造成的问题，一些在网页中实际存在的问题且有可能会产生新的 BUG（比如当在浏览器中本地存储数据的时候却拥有不同的数据库结构）。\u003c/p\u003e\n\u003ch2\u003e从缓存中删除数据\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003eactivate\u003c/code\u003e 回调中最为常见的步骤即缓存管理。因为若想删除安装步骤中老旧的缓存，而这又会导致 Service Workers 无法获取该缓存中的文件数据，所以，这时候需要进行缓存管理。\u003c/p\u003e\n\u003cp\u003e这里有一个示例演示如何把未在白名单中的缓存删除（该情况下，以 \u003ccode\u003epage-1\u003c/code\u003e 或者 \u003ccode\u003epage-2\u003c/code\u003e 来进行命名）：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003eself.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;activate\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e cacheWhitelist = [\u003cspan class=\"hljs-string\"\u003e\u0026#x27;page-1\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;page-2\u0026#x27;\u003c/span\u003e];\n\n  event.\u003cspan class=\"hljs-title function_\"\u003ewaitUntil\u003c/span\u003e(\n    \u003cspan class=\"hljs-comment\"\u003e// 获得缓存中所有键\u003c/span\u003e\n    caches.\u003cspan class=\"hljs-title function_\"\u003ekeys\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecacheNames\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e(\n        \u003cspan class=\"hljs-comment\"\u003e// 遍历所有的缓存文件\u003c/span\u003e\n        cacheNames.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ecacheName\u003c/span\u003e) {\n          \u003cspan class=\"hljs-comment\"\u003e// 若缓存文件不在白名单中，删除之\u003c/span\u003e\n          \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (cacheWhitelist.\u003cspan class=\"hljs-title function_\"\u003eindexOf\u003c/span\u003e(cacheName) === -\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e caches.\u003cspan class=\"hljs-title function_\"\u003edelete\u003c/span\u003e(cacheName);\n          }\n        })\n      );\n    })\n  );\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e注意事项\u003c/h2\u003e\n\u003ch3\u003eCookie 设置\u003c/h3\u003e\n\u003cp\u003e在 Service Worker 中使用 \u003ccode\u003efetch\u003c/code\u003e 的时候，请求头中默认不包含 Cookie，如果要添加 Cookie 的话，需要增加 \u003ccode\u003ecredentials\u003c/code\u003e 参数。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(url, {\n  \u003cspan class=\"hljs-attr\"\u003ecredentials\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;include\u0026#x27;\u003c/span\u003e,\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eHTTPS 要求\u003c/h3\u003e\n\u003cp\u003e当处于开发阶段的时候，可以通过 localhost 来使用 Service Workers ，但当处于发布环境的时候，必须部署好 HTTPS（这也是使用 HTTPS 的最后一个原因了）。\u003c/p\u003e\n\u003cp\u003e可以利用 Service Worker 劫持网络连接和伪造响应数据。如果不使用 HTTPS，网络应用会容易遭受\u003ca href=\"https://en.wikipedia.org/wiki/Man-in-the-middle_attack\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e中间人\u003c/a\u003e 攻击。\u003c/p\u003e\n\u003cp\u003e为了保证安全，必须通过 HTTPS 在页面上注册 Service Workers，这样就可以保证浏览器接收到的 Service Worker 没有在传输过程中被篡改。\u003c/p\u003e\n\u003ch2\u003e应用场景\u003c/h2\u003e\n\u003cp\u003e以下罗列了几点当前以及将来 Service Worker 能做的事情：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e拦截网络\u003c/li\u003e\n\u003cli\u003e离线缓存：可以将 H5 应用中不变化的资源或者很少变化的资源长久的存储在客户端，提升加载速度、降低流量消耗、降低服务器压力。如中重度的 H5 游戏、框架数据独立的 Web 资讯客户端、Web 邮件客户端等。\u003c/li\u003e\n\u003cli\u003e消息推送：激活沉睡的用户，推送即时信息、公告通告，激发更新等。如 Web 资讯客户端、Web 即时通讯工具、H5 游戏等运营产品。\u003c/li\u003e\n\u003cli\u003e事件同步：确保 Web 端产生的任务即使在用户关闭了 Web 页面也可以顺利完成。如 Web 邮件客户端、Web 即时通讯工具等。\u003c/li\u003e\n\u003cli\u003e定时同步（未来支持）：周期性的触发 Service Worker 脚本中的定时同步事件，可借助它提前刷新缓存内容。如 Web 资讯客户端。\u003c/li\u003e\n\u003cli\u003e地理围栏（未来支持）：地理围栏（Geo-fencing）是 LBS 的一种新应用，就是用一个虚拟的栅栏围出一个虚拟地理边界。当手机进入、离开某个特定地理区域，或在该区域内活动时，手机可以接收自动通知和警告。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e浏览器支持情况\u003c/h2\u003e\n\u003cp\u003eService Workers 拥有良好的浏览器兼容性。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e img \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;../../assets/service-worker/server-worker-compatibility.png\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e () =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;Service Workers 浏览器兼容性\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{img}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{800}\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e总结\u003c/h2\u003e\n\u003cp\u003e除了离线缓存外，利用 Service Worker 还可以做很多令人兴奋的功能。比如：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e客户端编译（把原来本地/服务端 Webpack 打包编译的事情放在 \u003ccode\u003eclient\u003c/code\u003e 中）\u003c/li\u003e\n\u003cli\u003e预请求 Prefetch（SSR 框架 next.js 提供了 Link 组件来实现预请求渲染）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e利用 Service Worker 能大大提升 Progress Web App（PWA） 的体验，现在各大厂商都表示支持，也代表了未来的趋势。另外， Google 提供了一套 Service Worker 库，可以消除服务工作线程样板文件代码，从而简化开发工作。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/GoogleChrome/sw-precache/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003esw-precache\u003c/a\u003e—与构建流程集成，以生成服务工作线程，用于预缓存静态资产，例如 Application Shell。\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/GoogleChrome/sw-toolbox/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003esw-toolbox\u003c/a\u003e—实现常见运行时缓存模式，例如动态内容、API 调用以及第三方资源，实现方法就像编写 README 一样简单。\u003c/li\u003e\n\u003cli\u003esw-offline-google-analytics—临时保留并重试 Analytics 请求，以避免请求因网络断开连接而丢失。\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e参考文档：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.w3.org/TR/service-workers\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e官方英文文档：Service Worker\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/Leslie2014/blog/issues/1\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e初识 Service Worker 及简单应用\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://x5.tencent.com/product/service-worker.html\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e腾讯浏览器服务：Service Worker 简介\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.fly63.com/article/detial/234\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003eServiceWorker 的生命周期\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/neal1991/articles-translator/blob/master/Service%20worker%E4%BB%8B%E7%BB%8D\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003eGithub：Service Worker Explained\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://blog.csdn.net/ztguang/article/details/53750479\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003eCSDN：Service Worker 入门 - PWA 强依赖于 Service Worker\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/delapuente/service-workers-101\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📍Github：Service Worker 101\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://jakearchibald.com/2014/service-worker-first-draft/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003eService Worker - first draft published\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"markdown-body\",\"children\":[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"front-end\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"front-end knowledge\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>