1:"$Sreact.fragment"
2:I[5244,[],""]
3:I[3866,[],""]
5:I[6213,[],"OutletBoundary"]
7:I[6213,[],"MetadataBoundary"]
9:I[6213,[],"ViewportBoundary"]
b:I[4835,[],""]
:HL["/_next/static/media/569ce4b8f30dc480-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/ec0a9d078e716e00.css","style"]
:HL["/_next/static/css/485ff6fe79292a08.css","style"]
:HL["/_next/static/css/0ff121a467c0636f.css","style"]
0:{"P":null,"b":"ToCgoFiTXvECVEVLCeZww","p":"","c":["","front-end","browser-object-model","offline-and-storage","web-workers"],"i":false,"f":[[["",{"children":["front-end",{"children":[["slug","browser-object-model/offline-and-storage/web-workers","oc"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/ec0a9d078e716e00.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__variable_4d318d __variable_ea5f4b antialiased","children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[],[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]]}],{"children":["front-end",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/485ff6fe79292a08.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/0ff121a467c0636f.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","main",null,{"children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","front-end","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]}]]}],{"children":[["slug","browser-object-model/offline-and-storage/web-workers","oc"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","front-end","children","$0:f:0:1:2:children:2:children:0","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L4",null,["$","$L5",null,{"children":"$L6"}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","_OeqdgTs1Lx3bu4i_gjUC",{"children":[["$","$L7",null,{"children":"$L8"}],["$","$L9",null,{"children":"$La"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}]]}],false]],"m":"$undefined","G":["$b","$undefined"],"s":false,"S":true}
c:T777b,<h1>Web Workers</h1>
<p>JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出現，单线程带来很大的不变，无法充分发挥计算机的计算能力。</p>
<p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务，被 Worker 线程负担了，主线程（通常负责 UI 交互）就会很流畅，不会被阻塞或拖慢。</p>
<p>Worker 线程一旦创建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p>
<p>Worker 使用构造函数 <code>WebWorker</code> 运行一个命名的 JavaScript 文件，这个文件包含将在工作线程中运行的代码。Worker 运行在另一个全局上下文中，不同与当前的 <code>window</code>。因此，使用 <code>window</code> 快捷方式获取当前全局范围在一个 Worker 内将返回错误。</p>
<p>在 Worker 线程中你可以运行任何代码，不过有一些例外情况。比如：在 Worker 内，不能直接操作 DOM 节点，也不能使用 <code>window</code> 对象的默认方法和属性。然而你可以使用大量 <code>window</code> 对象之下的东西，包括 WebSockets，IndexDB 以及 FIreFox OS 专用的 Data Store API 等数据存储机制。</p>
<p>Workers 和主线程间的数据传递通过这样的消息机制进行，双方都使用 <code>postMessage()</code> 方法发送各自的消息，使用 <code>onmessage</code> 事件处理函数来响应消息（消息被包含在 <code>Message</code> 事件的 <code>data</code> 属性中）。这个过程中数据并不是被共享而是被复制。</p>
<p>Web Worker 有以下几个使用注意点：</p>
<ul>
<li>同源限制：分配给 Web Worker 线程运行的脚本文件，必须与主线程的脚本文件同源</li>
<li>DOM 限制：Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用 document、window、parent 这些对象。但是，Worker 线程可以访问 navigator 对象和 location 对象。</li>
<li>通信联系：Worker 线程和主线程不再同一个上下文环境，它们不能直接通信，必须通过消息完成。</li>
<li>脚本限制：Worker 线程不能执行 <code>alert()</code> 和 <code>confirm()</code> 方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求</li>
<li>文件限制：Worker 线程无法读取本地文件，即不能打开本地的文件系统（<code>file://</code>） ，它所加载的脚本，必须来自网络</li>
</ul>
<h2>基本用法</h2>
<h3>主线程</h3>
<p>主线程调用构造函数 Worker 创建一个 Worker 线程，构造函数参数是一个 URL。创建方式分为脚本文件和字符串形式。</p>
<p><strong>脚本文件形式</strong></p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;https:// ~.js&#x27;</span>);
</code></pre>
<p>Worker 限制</p>
<ul>
<li>
<p>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</p>
</li>
<li>
<p>Worker 不能读取本地的文件（不能打开本机的文件系统 <code>file://</code>），它所加载的脚本必须来自网络。</p>
</li>
</ul>
<p><strong>字符串形式</strong></p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> data = <span class="hljs-string">`
	// worker 线程 do something
`</span>;
<span class="hljs-comment">// 转成二进制对象</span>
<span class="hljs-keyword">const</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([data]);
<span class="hljs-comment">// 生成URL</span>
<span class="hljs-keyword">const</span> url = <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob);
<span class="hljs-comment">// 加载URL</span>
<span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(url);
</code></pre>
<p>Worker 构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络，如果下载没有成功（比如 404 错误），Worker 就会默默地失败。</p>
<p>然后，<strong>主线程</strong>调用 <code>worker.postMessage()</code> 方法，向 Worker 发消息。</p>
<pre class="hljs"><code class="language-js">worker.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;Hello world!&#x27;</span>);
worker.<span class="hljs-title function_">postMessage</span>({ <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;echo&#x27;</span>, <span class="hljs-attr">args</span>: [<span class="hljs-string">&#x27;Work&#x27;</span>] });
</code></pre>
<p><code>worker.postMessage()</code> 方法的参数，就是<strong>主线程</strong>传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。</p>
<p>接着，<strong>主线程</strong>通过 <code>worker.onmessage()</code> 指定监听函数，接收 Worker 线程发回来的消息。</p>
<pre class="hljs"><code class="language-js">worker.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Received message &#x27;</span> + event.<span class="hljs-property">data</span>);
  <span class="hljs-title function_">doSomthing</span>();
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">doSomething</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 执行任务</span>
  worker.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;Work done!&#x27;</span>);
}
</code></pre>
<p>上面代码中，事件对象的 <code>data</code> 属性可以获取 Worker 发来的数据。</p>
<p>Worker 完成任务以后，主线程就可以把它关掉了。</p>
<pre class="hljs"><code class="language-js">worker.<span class="hljs-title function_">terminate</span>();
</code></pre>
<h2>Worker 线程</h2>
<p>Worker 线程内部需要有一个监听函数，监听 <code>message</code> 事件。</p>
<pre class="hljs"><code class="language-js">self.<span class="hljs-title function_">addEventListener</span>(
  <span class="hljs-string">&#x27;message&#x27;</span>,
  <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) {
    self.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;You said: &#x27;</span> + e.<span class="hljs-property">data</span>);
  },
  <span class="hljs-literal">false</span>
);
</code></pre>
<p>上面代码，<code>self</code> 代表 Worker 线程本身，即 Worker 线程的全局对象。因此，等同于以下两种写法：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 写法一</span>
<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">addEventListener</span>(
  <span class="hljs-string">&#x27;message&#x27;</span>,
  <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) {
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;You said: &#x27;</span> + e.<span class="hljs-property">data</span>);
  },
  <span class="hljs-literal">false</span>
);

<span class="hljs-comment">// 写法二</span>
<span class="hljs-title function_">addEventListener</span>(
  <span class="hljs-string">&#x27;message&#x27;</span>,
  <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) {
    <span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;You said: &#x27;</span> + e.<span class="hljs-property">data</span>);
  }.<span class="hljs-property">false</span>
);
</code></pre>
<p>除了使用 <code>self.addEventListener()</code> 指定监听函数，也可以使用 <code>self.onmessage</code> 指定。监听函数的参数是一个事件对象，它的 <code>data</code> 属性包含主线程发来的数据。<code>self.postMessage()</code> 方法用来向主线程发送消息。</p>
<p>根据主线程发来的数据，Worker 线程可以调用不同的方法，下面是一个例子：</p>
<pre class="hljs"><code class="language-js">self.<span class="hljs-title function_">addEventListener</span>(
  <span class="hljs-string">&#x27;message&#x27;</span>,
  <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) {
    <span class="hljs-keyword">var</span> data = e.<span class="hljs-property">data</span>;
    <span class="hljs-keyword">switch</span> (data.<span class="hljs-property">cmd</span>) {
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;start&#x27;</span>:
        self.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;WORKER STARTED: &#x27;</span> + data.<span class="hljs-property">msg</span>);
        <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;stop&#x27;</span>:
        self.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;WORKER STOPPED: &#x27;</span> + data.<span class="hljs-property">msg</span>);
        self.<span class="hljs-title function_">close</span>(); <span class="hljs-comment">// Terminates the worker.</span>
        <span class="hljs-keyword">break</span>;
      <span class="hljs-attr">default</span>:
        self.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;Unknown command: &#x27;</span> + data.<span class="hljs-property">msg</span>);
    }
  },
  <span class="hljs-literal">false</span>
);
</code></pre>
<p>上面代码中，<code>self.close()</code> 用于在 Worker 内部关闭自身。</p>
<h3>终止</h3>
<p>如果需要从主线程中立刻终止一个运行中的 Worker，可以调用 Worker 的 <code>terminate</code> 方法。</p>
<pre class="hljs"><code class="language-js">worker.<span class="hljs-title function_">terminate</span>();
</code></pre>
<p>Worker 线程会被立即杀死，不会有任何机会让它完成自己的操作或清理工作。</p>
<p>而在 Worker 线程中，Workers 也可以调用自己的 <code>close</code> 方法进行关闭。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-title function_">close</span>();
</code></pre>
<h3>加载脚本</h3>
<p>Worker 内部如果要加载其它脚本，有一个专门的方法 <code>importScripts()</code>。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-title function_">importScripts</span>(<span class="hljs-string">&#x27;script1.js&#x27;</span>);
</code></pre>
<p>该方法可以同时加载多个脚本。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-title function_">importScripts</span>(<span class="hljs-string">&#x27;script1.js&#x27;</span>, <span class="hljs-string">&#x27;script2.js&#x27;</span>);
</code></pre>
<h3>错误处理</h3>
<p>主线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的 <code>error</code> 事件。</p>
<pre class="hljs"><code class="language-js">worker.<span class="hljs-title function_">onerror</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([<span class="hljs-string">&#x27;ERROR: Line &#x27;</span>, e.<span class="hljs-property">lineno</span>, <span class="hljs-string">&#x27; in &#x27;</span>, e.<span class="hljs-property">filename</span>, <span class="hljs-string">&#x27;: &#x27;</span>, e.<span class="hljs-property">message</span>].<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>));
});

<span class="hljs-comment">// 或者</span>
worker.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {
  <span class="hljs-comment">// ...</span>
});
</code></pre>
<h2>数据通信</h2>
<p>前面提及，主线程与 Worker 线程之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，现将通信内容串行化，然后把串行化的字符串发给 Worker，后者再将它还原。</p>
<p>主线程与 Worker 线程之间也可以交换二进制数据，比如 File、Blob、ArrayBuffer 等类型，也可以在线程之间发送。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 主线程</span>
<span class="hljs-keyword">var</span> uInt8Array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Uint8Array</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">10</span>));
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; uInt8Array.<span class="hljs-property">length</span>; ++i) {
  uInt8Array[i] = i * <span class="hljs-number">2</span>; <span class="hljs-comment">// [0, 2, 4, 6, 8,...]</span>
}
worker.<span class="hljs-title function_">postMessage</span>(uInt8Array);

<span class="hljs-comment">// Worker 线程</span>
self.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) {
  <span class="hljs-keyword">var</span> uInt8Array = e.<span class="hljs-property">data</span>;
  <span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;Inside worker.js: uInt8Array.toString() = &#x27;</span> + uInt8Array.<span class="hljs-title function_">toString</span>());
  <span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;Inside worker.js: uInt8Array.byteLength = &#x27;</span> + uInt8Array.<span class="hljs-property">byteLength</span>);
};
</code></pre>
<p>但是，拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给 Worker 线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做 Transferable Objects。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便了，不会产生性能负担。</p>
<p>如果要直接转移数据的控制权，就要使用下面的写法：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// Transferable Objects 格式</span>
worker.<span class="hljs-title function_">postMessage</span>(arrayBuffer, [arrayBuffer]);

<span class="hljs-comment">// 例子</span>
<span class="hljs-keyword">var</span> ab = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBuffer</span>(<span class="hljs-number">1</span>);
worker.<span class="hljs-title function_">postMessage</span>(ab, [ab]);
</code></pre>
<h2>同页面的 Web Worker</h2>
<p>通常情况下，Worker 载入的是一个单独的 JavaScript 脚本文件，但是也可以载入与主线程在同一个网页的代码。</p>
<pre class="hljs"><code class="language-html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;worker&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;app/worker&quot;</span>&gt;</span><span class="language-javascript">
      <span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
        <span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;some message&#x27;</span>);
      }, <span class="hljs-literal">false</span>);
    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span>
</code></pre>
<p>上面是一段嵌入网页的脚本，注意必须指定 <code>&lt;script&gt;</code> 标签的 type 属性是一个浏览器不认识的值，上例是 <code>app/worker</code>。</p>
<p>然后，读取这一段嵌入页面的脚本，用 Worker 来处理。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">var</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#worker&#x27;</span>).<span class="hljs-property">textContent</span>]);
<span class="hljs-keyword">var</span> url = <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob);
<span class="hljs-keyword">var</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(url);

worker.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) {
  <span class="hljs-comment">// e.data === &#x27;some message&#x27;</span>
};
</code></pre>
<p>上面代码中，先将嵌入网页的脚本代码，转成一个二进制对象，然后为这个二进制对象生成 URL，再让 Worker 加载这个 URL。这样就做到了，主线程和 Worker 的代码都在同一个网页上面。</p>
<h2>应用场景</h2>
<p>WebWorker 带来后台计算能力，WebWorker 自身是由 Webkit 多线程实现，但它并没有为 JavaScript 语言带来多线程编程特性，我们现在仍然不能在 JavaScript 代码中创建并管理一个线程，或者主动控制线程间的同步与锁等特性。Web Worker 只是浏览器（宿主环境）提供的一个能力 / API。而且它不支持 IE。</p>
<p><strong>使用专用线程进行数学运算</strong>
Web Worker 最简单的应用就是用来做后台计算，而这种计算并不会中断前台用户的操作</p>
<p><strong>图像处理</strong>
通过使用从 Canvas 或者 Video 元素中获取的数据，可以把图像分割成几个不同的区域并且把它们推送给并行的不同 Workers 来做计算</p>
<p><strong>大量数据的检索</strong>
当需要在调用 AJAX 后处理大量的数据，如果处理这些数据所需的时间长短非常重要，可以在 Web Worker 中来做这些，避免冻结 UI 线程。</p>
<p><strong>背景数据分析</strong>
由于在使用 Web Worker 的时候，我们有更多潜在的 CPU 可用时间，我们现在可以考虑一下 JavaScript 中的新应用场景。我们现在可以考虑一下 JavaScript 中的新应用场景。例如，我们可以想像在不影响 UI 体验的情况下实时处理用户输入。利用这样一种可能，我们可以想像一个像 Word（Office Web Apps 套装）一样的应用：当用户打字时后台在词典中进行查找，帮助用户自动纠错等等。</p>
<h2>实例：Worker 线程完成轮询</h2>
<p>有时，浏览器需要轮询服务器状态，以便第一时间得知状态改变。这个工作可以放在 Worker 线程里面完成。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">createWorker</span>(<span class="hljs-params">f</span>) {
  <span class="hljs-keyword">var</span> blob = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Blob</span>([<span class="hljs-string">&#x27;(&#x27;</span> + f.<span class="hljs-title function_">toString</span>() +<span class="hljs-string">&#x27;)()&#x27;</span>]);
  <span class="hljs-keyword">var</span> url = <span class="hljs-variable language_">window</span>.<span class="hljs-property">URL</span>.<span class="hljs-title function_">createObjectURL</span>(blob);
  <span class="hljs-keyword">var</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(url);
  <span class="hljs-keyword">return</span> worker;
}

<span class="hljs-keyword">var</span> pollingWorker = <span class="hljs-title function_">createWorker</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) {
  <span class="hljs-keyword">var</span> cache;

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">compare</span>(<span class="hljs-params"><span class="hljs-keyword">new</span>, old</span>) { ... };

  <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/my-api-endpoint&#x27;</span>).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) {
      <span class="hljs-keyword">var</span> data = res.<span class="hljs-title function_">json</span>();

      <span class="hljs-keyword">if</span> (!<span class="hljs-title function_">compare</span>(data, cache)) {
        cache = data;
        self.<span class="hljs-title function_">postMessage</span>(data);
      }
    })
  }, <span class="hljs-number">1000</span>)
});

pollingWorker.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-comment">// render data</span>
}

pollingWorker.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;init&#x27;</span>);
</code></pre>
<p>上面代码中，Worker 线程每秒钟轮询一次数据，然后跟缓存做比较。如果不一致，就说明服务端有了新的变化，因此就要通知主线程。</p>
<h2>实例：Worker 新建 Worker</h2>
<p>Worker 线程内部还能再新建 Worker 线程（目前只有 Firefox 浏览器支持）。下面的例子是将一个计算密集的任务，分配到 10 个 Worker。</p>
<p>主线程代码如下：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">var</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;worker.js&#x27;</span>);
worker.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) {
  <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;result&#x27;</span>).<span class="hljs-property">textContent</span> = event.<span class="hljs-property">data</span>;
};
</code></pre>
<p><strong>Worker 线程</strong>代码如下：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// worker.js</span>

<span class="hljs-comment">// settings</span>
<span class="hljs-keyword">var</span> num_workers = <span class="hljs-number">10</span>;
<span class="hljs-keyword">var</span> items_per_worker = <span class="hljs-number">1000000</span>;

<span class="hljs-comment">// start the workers</span>
<span class="hljs-keyword">var</span> result = <span class="hljs-number">0</span>;
<span class="hljs-keyword">var</span> pending_workers = num_workers;
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; num_workers; i += <span class="hljs-number">1</span>) {
  <span class="hljs-keyword">var</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;core.js&#x27;</span>);
  worker.<span class="hljs-title function_">postMessage</span>(i * items_per_worker);
  worker.<span class="hljs-title function_">postMessage</span>((i + <span class="hljs-number">1</span>) * items_per_worker);
  worker.<span class="hljs-property">onmessage</span> = storeResult;
}

<span class="hljs-comment">// handle the results</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">storeResult</span>(<span class="hljs-params">event</span>) {
  result += event.<span class="hljs-property">data</span>;
  pending_workers -= <span class="hljs-number">1</span>;
  <span class="hljs-keyword">if</span> (pending_workers &lt;= <span class="hljs-number">0</span>) <span class="hljs-title function_">postMessage</span>(result); <span class="hljs-comment">// finished!</span>
}
</code></pre>
<p>上面代码中，Worker 线程内部新建了 10 个 Worker 线程，并且依次向这 10 个 Worker 发送消息，告知了计算的起点和终点。计算任务脚本的代码如下：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// core.js</span>
<span class="hljs-keyword">var</span> start;
onmessage = getStart;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getStart</span>(<span class="hljs-params">event</span>) {
  start = event.<span class="hljs-property">data</span>;
  onmessage = getEnd;
}

<span class="hljs-keyword">var</span> end;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">getEnd</span>(<span class="hljs-params">event</span>) {
  end = event.<span class="hljs-property">data</span>;
  onmessage = <span class="hljs-literal">null</span>;
  <span class="hljs-title function_">work</span>();
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">work</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> result = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = start; i &lt; end; i += <span class="hljs-number">1</span>) {
    <span class="hljs-comment">// perform some complex calculation here</span>
    result += <span class="hljs-number">1</span>;
  }
  <span class="hljs-title function_">postMessage</span>(result);
  <span class="hljs-title function_">close</span>();
}
</code></pre>
<h2>API</h2>
<h3>主线程</h3>
<p>浏览器原生提供 <code>Worker()</code> 构造函数，用来供主线程生成 Worker 线程。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(url, options);
</code></pre>
<p><code>Worker()</code> 构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵循同源策略），该参数是必须的，且只能区分多个 Worker 线程。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 主线程</span>
<span class="hljs-keyword">var</span> worker = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-string">&#x27;worker.js&#x27;</span>, { <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;worker&#x27;</span> });

<span class="hljs-comment">// Worker 线程</span>
self.<span class="hljs-property">name</span>; <span class="hljs-comment">// worker</span>
</code></pre>
<p>Worker()构造函数返回一个 Worker 线程对象，用来供主线程操作 Worker。Worker 线程对象的属性和方法如下：</p>
<ul>
<li>Worker.onerror：指定 error 事件的监听函数。</li>
<li>Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在 Event.data 属性中。</li>
<li>Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li>
<li>Worker.postMessage()：向 Worker 线程发送消息。</li>
<li>Worker.terminate()：立即终止 Worker 线程。</li>
</ul>
<h3>Worker 线程</h3>
<p>Web Worker 有自己的全局对象，不是主线程的 <code>window</code>，而是一个专门为 Worker 定制的全局对象。因此定义在 <code>window</code> 上面的对象和方法不是全部都可以使用.</p>
<p>orker 线程有一些自己的全局属性和方法：</p>
<ul>
<li><code>self.name</code>： Worker 的名字。该属性只读，由构造函数指定。</li>
<li><code>self.onmessage</code>：指定 message 事件的监听函数。</li>
<li><code>self.onmessageerror</code>：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li>
<li><code>self.close()</code>：关闭 Worker 线程。</li>
<li><code>self.postMessage()</code>：向产生这个 Worker 线程发送消息。</li>
<li><code>self.importScripts()</code>：加载 JS 脚本。</li>
</ul>
<hr>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://segmentfault.com/a/1190000009313491" target="_blank" rel="noopener noreferrer nofollow">聊聊 WebWorker</a></li>
<li><a href="https://juejin.im/post/5b4af72ae51d45198d4b1388" target="_blank" rel="noopener noreferrer nofollow">Web Worker 初探</a></li>
</ul>
4:["$","div",null,{"className":"markdown-body","children":[["$","h1",null,{"children":"Web Workers"}],["$","article",null,{"dangerouslySetInnerHTML":{"__html":"$c"}}]]}]
a:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
8:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"front-end"}],["$","meta","2",{"name":"description","content":"front-end knowledge"}],["$","link","3",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
6:null
