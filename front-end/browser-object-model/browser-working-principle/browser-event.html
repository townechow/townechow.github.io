<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/d498c84e4ab246b3.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/485ff6fe79292a08.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/b9d97b2190475167.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/851cdee6d90716dd.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-78112f590b744806.js"/><script src="/_next/static/chunks/4bd1b696-20882bf820444624.js" async=""></script><script src="/_next/static/chunks/517-98ed787e5f259f2c.js" async=""></script><script src="/_next/static/chunks/main-app-f33d3e3aed85e21f.js" async=""></script><meta name="next-size-adjust" content=""/><title>front-end</title><meta name="description" content="front-end knowledge"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><main><div class="markdown-body"><article><h1>浏览器事件处理</h1>
<h2>输入事件</h2>
<p>听到 <strong>输入事件</strong> 这个字眼，你脑海里闪现的恐怕只是输入文本或点击鼠标。但在浏览器眼中，输入意味着一切用户行为。不单滚动鼠标滑轮是输入事件，触摸屏幕、滑动鼠标同样也是用户输入事件。</p>
<p>诸如触摸屏幕之类用户手势产生时，浏览器进程会率先将其捕获。然而浏览器进程所掌握的信息仅限于行为发生的区域，因为标签页里的内容都由渲染进程负责处理，所以浏览器进程会将事件类型（如 touchstart）及其坐标发送给渲染进程。渲染进程会寻至事件目标，运行其事件监听器，妥善地处理事件。</p>
<img alt="输入事件由浏览器进程发往渲染进程" src="../../assets/browser-working-principle/input-event-from-browser-to-renderer.png" width="520" /><h2>合成器接收输入事件</h2>
<img alt="悬于页面图层的视图窗口" src="../../assets/browser-working-principle/input-event-from-browser-to-renderer.png" width="520" /><p>在上篇文章里，我们探讨了合成器如何通过合成栅格化图层，实现流畅的页面滚动。如果页面上没有添加任何事件监听，合成器线程会创建独立于主线程的新合成帧。但要是页面上添加了事件监听呢？合成器线程又是如何得知事件是否需要处理的？</p>
<h2>理解非立即可滚动区</h2>
<p>因为运行 JavaScript 脚本是主线程的工作，所以页面合成后，合成进程会将页面里添加了事件监听的区域标记为 <strong>非立即可滚动区</strong>。有了这个信息，如果输入事件发生在这一区域，合成进程可以确定应将其发往主线程处理。如输入事件发生在这一区域之外，合成进程则确定无需等待主线程，可继续合成新帧。</p>
<img alt="非立即可滚动区输入描述示意图" src="../../assets/browser-working-principle/non-fast-scrollable-region.png" width="520" /><h3>设置事件处理器时须注意</h3>
<p>Web 开发中常用的事件处理模式是 <strong>事件代理</strong>。因为事件会冒泡，所以你可以在最顶层的元素中添加一个事件处理器，用来代理事件目标产生的任务。下面这样的代码，你可能见过，或许也写过。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;touchstart&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">target</span> === area) {
    event.<span class="hljs-title function_">preventDefault</span>();
  }
});
</code></pre>
<p>这样只需添加一个事件监听器，即可监听所有元素，的确十分省事。然而，如果站在浏览器的角度去考量，这等于把整个页面都标记成了 <strong>非立即可滚动区</strong>，意味着即便你设计的应用本不必理会页面上一些区域的输入行为，合成线程也必须在每次输入事件产生后与主线程通信并等待返回。如此则得不偿失，使原本能保障页面滚动流畅的合成器没了用武之地。</p>
<p>你可以给事件监听添加一个 <code>passive: true</code> 选项 ，将这种负面效果最小化。这会提示浏览器你想继续在主线程中监听事件，但合成器不必停滞等候，可接着创建新的合成帧。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">addEventListener</span>(
  <span class="hljs-string">&#x27;touchstart&#x27;</span>,
  <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
    <span class="hljs-keyword">if</span> (event.<span class="hljs-property">target</span> === area) {
      event.<span class="hljs-title function_">preventDefault</span>();
    }
  },
  {
    <span class="hljs-attr">passive</span>: <span class="hljs-literal">true</span>,
  }
);
</code></pre>
<h2>检查事件是否可撤销</h2>
<img alt="部分区域仅可水平方向滚动的网页" src="../../assets/browser-working-principle/horizontally-scrollable-website.png" width="520" /><p>设想一下这种情形：页面上有一个盒子，你要将其滚动方向限制为水平滚动。</p>
<p>为目标事件设置 <code>passive: true</code> 选项可让页面滚动平滑，但在你使用 <code>preventDefault</code> 以限制滚动方向时，垂直方向滚动可能已经触发。使用 <code>event.cancelable</code> 可以检查并阻止这种情况发生。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;pointermove&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> {
  <span class="hljs-keyword">if</span> (event.<span class="hljs-property">cancelable</span>) {
    event.<span class="hljs-title function_">preventDefault</span>(); <span class="hljs-comment">// 阻止默认的滚动行为</span>
    <span class="hljs-comment">/*
    *  这里设置程序执行任务
    */</span>
  }
}, {<span class="hljs-attr">passive</span>:: <span class="hljs-literal">true</span>});
</code></pre>
<p>或者，你也可以应用 <code>touch-action</code> 这类 CSS 规则，完全地将事件处理器屏蔽掉。</p>
<pre class="hljs language-css"  style=--lang:"css" ><code><span class="hljs-selector-id">#area</span> {
  <span class="hljs-attribute">touch-action</span>: pan-x;
}
</code></pre>
<h2>定位事件目标</h2>
<img alt="主线程检查绘制记录查询坐标X和Y处绘制内容" src="../../assets/browser-working-principle/main-process-check-paint-record.png" width="520" /><p>合成器将输入事件发送至主线程后，首先运行的是命中检测。命中检测会使用渲染进程中产生的绘制记录数据，找出事件发生坐标下的内容。</p>
<h2>降低往主线程发送事件的频率</h2>
<p>之前的文章里，我们探讨了常见显示屏如何以每秒 60 帧的频率刷新，以及我们要怎样与其刷新频率保持步调一致，以营造出流畅的动画效果。而对于用户的输入行为，常见触摸屏设备的事件传输频率为每秒 60~120 次，常见鼠标设备的事件传输频率为每秒 100 次。可见，输入事件有着比显示屏幕更高的保真度。</p>
<p>如果一连串 <code>touchmove</code> 这样的事件以每秒 120 次的频率发送往主线程，那么可能会触发过量的命中检测及 JavaScript 脚本执行。相形而言，我们的屏幕刷新率则低下得多。</p>
<img alt="大量事件涌入合成帧时间轴会造成页面闪烁" src="../../assets/browser-working-principle/massive-event-and-website-flicker.png" width="640" /><p>为了降低往主线程中传递过量调用，Chrome 会合并这些连续事件（如：<code>wheel</code>、<code>mousewheel</code>、<code>mousemove</code>、<code>pointermove</code>、<code>touchmove</code> 等），并将其延迟至下一次 <code>requestAnimationFrame</code> 前发送。</p>
<img alt="相同的时间轴下事件被合并且延迟发送" src="../../assets/browser-working-principle/same-timeline-composite-event.png" width="640" /><p>所有独立的事件，如: <code>keydown</code>、<code>keyup</code>、<code>mouseup</code>、<code>mousedown</code>、<code>touchstart</code> 及 <code>touchend</code> 则会立即发往主线程。</p>
<h2>帧内事件</h2>
<p>事件合并可帮助大多数 Web 应用构建良好的用户体验。然而，如果你开发的是一个绘图类应用，需要基于 <code>touchmove</code> 事件的坐标绘制线路，那么在你试图画下一根光滑的线条时，区间内的一些坐标点也可能会因事件合并而丢失。这时，你可以使用目标事件的 <code>getCoalescedEvents</code> 方法获取事件合并后的信息。</p>
<img alt="左为流畅的触摸手势路径、右为事件合并后的有限路径" src="../../assets/browser-working-principle/touch-gesture-and-coalesced-event.png" width="520" /><p>&lt;br /&gt;</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;pointermove&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event</span>) =&gt;</span> {
  <span class="hljs-keyword">const</span> events = event.<span class="hljs-title function_">getCoalescedEvents</span>();
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> event <span class="hljs-keyword">of</span> events) {
    <span class="hljs-keyword">const</span> x = event.<span class="hljs-property">pageX</span>;
    <span class="hljs-keyword">const</span> y = event.<span class="hljs-property">pageY</span>;
    <span class="hljs-comment">// 使用 x、y 坐标画线</span>
  }
});
</code></pre>
<h2>参考资料</h2>
<ul>
<li><a href="https://developers.google.com/web/updates/2018/09/inside-browser-part4" target="_blank" rel="noopener noreferrer nofollow">📝 英语原文：Inside look at modern web browser（Part 4）</a></li>
<li><a href="https://juejin.im/post/6844903695600058375" target="_blank" rel="noopener noreferrer nofollow">📝 现代浏览器内部揭秘（Part 4）</a></li>
</ul>
</article></div></main><script src="/_next/static/chunks/webpack-78112f590b744806.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5244,[],\"\"]\n3:I[3866,[],\"\"]\n5:I[6213,[],\"OutletBoundary\"]\n7:I[6213,[],\"MetadataBoundary\"]\n9:I[6213,[],\"ViewportBoundary\"]\nb:I[4835,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/d498c84e4ab246b3.css\",\"style\"]\n:HL[\"/_next/static/css/485ff6fe79292a08.css\",\"style\"]\n:HL[\"/_next/static/css/b9d97b2190475167.css\",\"style\"]\n:HL[\"/_next/static/css/851cdee6d90716dd.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"NFjmtHF2up8B2PpbDjLiS\",\"p\":\"\",\"c\":[\"\",\"front-end\",\"browser-object-model\",\"browser-working-principle\",\"browser-event\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"front-end\",{\"children\":[[\"slug\",\"browser-object-model/browser-working-principle/browser-event\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d498c84e4ab246b3.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/485ff6fe79292a08.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/b9d97b2190475167.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"front-end\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/851cdee6d90716dd.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"main\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[[\"slug\",\"browser-object-model/browser-working-principle/browser-event\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"zEegiotaJvKHcBHYNoHrn\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:T2620,"])</script><script>self.__next_f.push([1,"\u003ch1\u003e浏览器事件处理\u003c/h1\u003e\n\u003ch2\u003e输入事件\u003c/h2\u003e\n\u003cp\u003e听到 \u003cstrong\u003e输入事件\u003c/strong\u003e 这个字眼，你脑海里闪现的恐怕只是输入文本或点击鼠标。但在浏览器眼中，输入意味着一切用户行为。不单滚动鼠标滑轮是输入事件，触摸屏幕、滑动鼠标同样也是用户输入事件。\u003c/p\u003e\n\u003cp\u003e诸如触摸屏幕之类用户手势产生时，浏览器进程会率先将其捕获。然而浏览器进程所掌握的信息仅限于行为发生的区域，因为标签页里的内容都由渲染进程负责处理，所以浏览器进程会将事件类型（如 touchstart）及其坐标发送给渲染进程。渲染进程会寻至事件目标，运行其事件监听器，妥善地处理事件。\u003c/p\u003e\n\u003cimg alt=\"输入事件由浏览器进程发往渲染进程\" src=\"../../assets/browser-working-principle/input-event-from-browser-to-renderer.png\" width=\"520\" /\u003e\u003ch2\u003e合成器接收输入事件\u003c/h2\u003e\n\u003cimg alt=\"悬于页面图层的视图窗口\" src=\"../../assets/browser-working-principle/input-event-from-browser-to-renderer.png\" width=\"520\" /\u003e\u003cp\u003e在上篇文章里，我们探讨了合成器如何通过合成栅格化图层，实现流畅的页面滚动。如果页面上没有添加任何事件监听，合成器线程会创建独立于主线程的新合成帧。但要是页面上添加了事件监听呢？合成器线程又是如何得知事件是否需要处理的？\u003c/p\u003e\n\u003ch2\u003e理解非立即可滚动区\u003c/h2\u003e\n\u003cp\u003e因为运行 JavaScript 脚本是主线程的工作，所以页面合成后，合成进程会将页面里添加了事件监听的区域标记为 \u003cstrong\u003e非立即可滚动区\u003c/strong\u003e。有了这个信息，如果输入事件发生在这一区域，合成进程可以确定应将其发往主线程处理。如输入事件发生在这一区域之外，合成进程则确定无需等待主线程，可继续合成新帧。\u003c/p\u003e\n\u003cimg alt=\"非立即可滚动区输入描述示意图\" src=\"../../assets/browser-working-principle/non-fast-scrollable-region.png\" width=\"520\" /\u003e\u003ch3\u003e设置事件处理器时须注意\u003c/h3\u003e\n\u003cp\u003eWeb 开发中常用的事件处理模式是 \u003cstrong\u003e事件代理\u003c/strong\u003e。因为事件会冒泡，所以你可以在最顶层的元素中添加一个事件处理器，用来代理事件目标产生的任务。下面这样的代码，你可能见过，或许也写过。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;touchstart\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (event.\u003cspan class=\"hljs-property\"\u003etarget\u003c/span\u003e === area) {\n    event.\u003cspan class=\"hljs-title function_\"\u003epreventDefault\u003c/span\u003e();\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样只需添加一个事件监听器，即可监听所有元素，的确十分省事。然而，如果站在浏览器的角度去考量，这等于把整个页面都标记成了 \u003cstrong\u003e非立即可滚动区\u003c/strong\u003e，意味着即便你设计的应用本不必理会页面上一些区域的输入行为，合成线程也必须在每次输入事件产生后与主线程通信并等待返回。如此则得不偿失，使原本能保障页面滚动流畅的合成器没了用武之地。\u003c/p\u003e\n\u003cp\u003e你可以给事件监听添加一个 \u003ccode\u003epassive: true\u003c/code\u003e 选项 ，将这种负面效果最小化。这会提示浏览器你想继续在主线程中监听事件，但合成器不必停滞等候，可接着创建新的合成帧。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\n  \u003cspan class=\"hljs-string\"\u003e\u0026#x27;touchstart\u0026#x27;\u003c/span\u003e,\n  \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (event.\u003cspan class=\"hljs-property\"\u003etarget\u003c/span\u003e === area) {\n      event.\u003cspan class=\"hljs-title function_\"\u003epreventDefault\u003c/span\u003e();\n    }\n  },\n  {\n    \u003cspan class=\"hljs-attr\"\u003epassive\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n  }\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e检查事件是否可撤销\u003c/h2\u003e\n\u003cimg alt=\"部分区域仅可水平方向滚动的网页\" src=\"../../assets/browser-working-principle/horizontally-scrollable-website.png\" width=\"520\" /\u003e\u003cp\u003e设想一下这种情形：页面上有一个盒子，你要将其滚动方向限制为水平滚动。\u003c/p\u003e\n\u003cp\u003e为目标事件设置 \u003ccode\u003epassive: true\u003c/code\u003e 选项可让页面滚动平滑，但在你使用 \u003ccode\u003epreventDefault\u003c/code\u003e 以限制滚动方向时，垂直方向滚动可能已经触发。使用 \u003ccode\u003eevent.cancelable\u003c/code\u003e 可以检查并阻止这种情况发生。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;pointermove\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (event.\u003cspan class=\"hljs-property\"\u003ecancelable\u003c/span\u003e) {\n    event.\u003cspan class=\"hljs-title function_\"\u003epreventDefault\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 阻止默认的滚动行为\u003c/span\u003e\n    \u003cspan class=\"hljs-comment\"\u003e/*\n    *  这里设置程序执行任务\n    */\u003c/span\u003e\n  }\n}, {\u003cspan class=\"hljs-attr\"\u003epassive\u003c/span\u003e:: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e或者，你也可以应用 \u003ccode\u003etouch-action\u003c/code\u003e 这类 CSS 规则，完全地将事件处理器屏蔽掉。\u003c/p\u003e\n\u003cpre class=\"hljs language-css\"  style=--lang:\"css\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-selector-id\"\u003e#area\u003c/span\u003e {\n  \u003cspan class=\"hljs-attribute\"\u003etouch-action\u003c/span\u003e: pan-x;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e定位事件目标\u003c/h2\u003e\n\u003cimg alt=\"主线程检查绘制记录查询坐标X和Y处绘制内容\" src=\"../../assets/browser-working-principle/main-process-check-paint-record.png\" width=\"520\" /\u003e\u003cp\u003e合成器将输入事件发送至主线程后，首先运行的是命中检测。命中检测会使用渲染进程中产生的绘制记录数据，找出事件发生坐标下的内容。\u003c/p\u003e\n\u003ch2\u003e降低往主线程发送事件的频率\u003c/h2\u003e\n\u003cp\u003e之前的文章里，我们探讨了常见显示屏如何以每秒 60 帧的频率刷新，以及我们要怎样与其刷新频率保持步调一致，以营造出流畅的动画效果。而对于用户的输入行为，常见触摸屏设备的事件传输频率为每秒 60~120 次，常见鼠标设备的事件传输频率为每秒 100 次。可见，输入事件有着比显示屏幕更高的保真度。\u003c/p\u003e\n\u003cp\u003e如果一连串 \u003ccode\u003etouchmove\u003c/code\u003e 这样的事件以每秒 120 次的频率发送往主线程，那么可能会触发过量的命中检测及 JavaScript 脚本执行。相形而言，我们的屏幕刷新率则低下得多。\u003c/p\u003e\n\u003cimg alt=\"大量事件涌入合成帧时间轴会造成页面闪烁\" src=\"../../assets/browser-working-principle/massive-event-and-website-flicker.png\" width=\"640\" /\u003e\u003cp\u003e为了降低往主线程中传递过量调用，Chrome 会合并这些连续事件（如：\u003ccode\u003ewheel\u003c/code\u003e、\u003ccode\u003emousewheel\u003c/code\u003e、\u003ccode\u003emousemove\u003c/code\u003e、\u003ccode\u003epointermove\u003c/code\u003e、\u003ccode\u003etouchmove\u003c/code\u003e 等），并将其延迟至下一次 \u003ccode\u003erequestAnimationFrame\u003c/code\u003e 前发送。\u003c/p\u003e\n\u003cimg alt=\"相同的时间轴下事件被合并且延迟发送\" src=\"../../assets/browser-working-principle/same-timeline-composite-event.png\" width=\"640\" /\u003e\u003cp\u003e所有独立的事件，如: \u003ccode\u003ekeydown\u003c/code\u003e、\u003ccode\u003ekeyup\u003c/code\u003e、\u003ccode\u003emouseup\u003c/code\u003e、\u003ccode\u003emousedown\u003c/code\u003e、\u003ccode\u003etouchstart\u003c/code\u003e 及 \u003ccode\u003etouchend\u003c/code\u003e 则会立即发往主线程。\u003c/p\u003e\n\u003ch2\u003e帧内事件\u003c/h2\u003e\n\u003cp\u003e事件合并可帮助大多数 Web 应用构建良好的用户体验。然而，如果你开发的是一个绘图类应用，需要基于 \u003ccode\u003etouchmove\u003c/code\u003e 事件的坐标绘制线路，那么在你试图画下一根光滑的线条时，区间内的一些坐标点也可能会因事件合并而丢失。这时，你可以使用目标事件的 \u003ccode\u003egetCoalescedEvents\u003c/code\u003e 方法获取事件合并后的信息。\u003c/p\u003e\n\u003cimg alt=\"左为流畅的触摸手势路径、右为事件合并后的有限路径\" src=\"../../assets/browser-working-principle/touch-gesture-and-coalesced-event.png\" width=\"520\" /\u003e\u003cp\u003e\u0026lt;br /\u0026gt;\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;pointermove\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e events = event.\u003cspan class=\"hljs-title function_\"\u003egetCoalescedEvents\u003c/span\u003e();\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e event \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e events) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e x = event.\u003cspan class=\"hljs-property\"\u003epageX\u003c/span\u003e;\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e y = event.\u003cspan class=\"hljs-property\"\u003epageY\u003c/span\u003e;\n    \u003cspan class=\"hljs-comment\"\u003e// 使用 x、y 坐标画线\u003c/span\u003e\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e参考资料\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://developers.google.com/web/updates/2018/09/inside-browser-part4\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 英语原文：Inside look at modern web browser（Part 4）\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.im/post/6844903695600058375\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 现代浏览器内部揭秘（Part 4）\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"markdown-body\",\"children\":[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"front-end\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"front-end knowledge\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>