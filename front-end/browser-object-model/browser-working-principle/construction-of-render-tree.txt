1:"$Sreact.fragment"
2:I[5244,[],""]
3:I[3866,[],""]
5:I[6213,[],"OutletBoundary"]
7:I[6213,[],"MetadataBoundary"]
9:I[6213,[],"ViewportBoundary"]
b:I[4835,[],""]
:HL["/_next/static/media/569ce4b8f30dc480-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/ec0a9d078e716e00.css","style"]
:HL["/_next/static/css/485ff6fe79292a08.css","style"]
:HL["/_next/static/css/0ff121a467c0636f.css","style"]
0:{"P":null,"b":"NW9bMA21iAaih0TqCHqj1","p":"","c":["","front-end","browser-object-model","browser-working-principle","construction-of-render-tree"],"i":false,"f":[[["",{"children":["front-end",{"children":[["slug","browser-object-model/browser-working-principle/construction-of-render-tree","oc"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/ec0a9d078e716e00.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__variable_4d318d __variable_ea5f4b antialiased","children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[],[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]]}],{"children":["front-end",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/485ff6fe79292a08.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/0ff121a467c0636f.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","main",null,{"children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","front-end","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]}]]}],{"children":[["slug","browser-object-model/browser-working-principle/construction-of-render-tree","oc"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","front-end","children","$0:f:0:1:2:children:2:children:0","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L4",null,["$","$L5",null,{"children":"$L6"}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","RIbm8smViJ3vrjurxn9rH",{"children":[["$","$L7",null,{"children":"$L8"}],["$","$L9",null,{"children":"$La"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}]]}],false]],"m":"$undefined","G":["$b","$undefined"],"s":false,"S":true}
c:T3f7a,<h1>渲染树构建</h1>
<p>在 <a href="/front-end/browser-object-model/browser-working-principle/construction-of-the-object-model">构建对象模型</a> 中，我们根据 HTML 和 CSS 输入构建了 DOM 树和 CSSOM 树。 不过，它们都是独立的对象，分别网罗文档不同方面的信息：一个描述内容，另一个则是描述需要对文档应用的样式规则。</p>
<p>DOM 树和 CSSOM 树将合并后在浏览器屏幕上渲染像素</p>
<ul>
<li>DOM 树与 CSSOM 树合并后形成渲染树</li>
<li>渲染树只包含渲染网页所需的节点</li>
<li><a href="/front-end/browser-object-model/browser-working-principle/layout">布局</a> 计算每个对象的精确位置和大小</li>
<li>最后一步是 <a href="/front-end/browser-object-model/browser-working-principle/paint">绘制</a>，使用最终渲染树将像素渲染到屏幕上</li>
</ul>
<h2>构建流程</h2>
<p>浏览器将 DOM 和 CSSOM 合并成一个 <strong>渲染树</strong>，它会网罗网页上所有可见的 DOM 内容，以及每个节点的所有 CSSOM 样式信息。</p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/browser-working-principle/render-tree.png&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;渲染树构建&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{640}</span> /&gt;</span></span>;
</code></pre>
<p>为了构建渲染树，浏览器大体上完成了下列工作：</p>
<ol>
<li>从 DOM 树的根节点开始遍历每个可见节点
<ul>
<li>某些节点不可见（例如脚本标记、元标记等），因为它们不会体现在渲染输出中，所以会被忽略。</li>
<li>某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如，样式设置为 <code>display: none</code> 属性的节点。</li>
</ul>
</li>
<li>对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。</li>
<li>发射可见节点，连同其内容和计算的样式。</li>
</ol>
<h2>遍历文档树</h2>
<p>渲染对象是和 DOM 元素相对应，但这种对应关系并非一一对应。</p>
<h3>非可视化元素</h3>
<p><strong>非可视化的 DOM 元素不会被插入渲染树中。</strong></p>
<p>例如， <code>&lt;head&gt;</code> 标签以及里面的内容，以及 <code>display:none</code> 的元素也会被去除，但是 <code>visibility</code> 属性值为 <code>hidden</code> 的元素仍会显示。</p>
<h3>复杂结构元素</h3>
<p><strong>部分 DOM 元素可对应多个可视化对象。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。</strong></p>
<p>例如， <code>select</code> 元素有 3 个渲染器：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也会作为新的呈现器而添加。</p>
<p>另一个关于多渲染器的例子是格式无效的 HTML。根据 CSS 规范，行内元素只能仅包含块状元素或行内元素中的一种。如果出现了混合内容，则应创建匿名的块状渲染对象，以包裹行内元素。所以我们平时的 <code>inline-block</code> 可以设置宽高。</p>
<h3>脱离文档流</h3>
<p><strong>部分渲染对象对应于 DOM 节点，但树中所在的位置与 DOM 节点不同。</strong></p>
<p>例如，浮动定位和绝对定位的元素处于正常的文本流之外，在两棵树上的位置不同，渲染树上标识出真实的结构，并用一个占位结构标识出它们原来的位置。</p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/browser-working-principle/render-tree-and-dom-tree.png&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;渲染树及对应DOM树&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{640}</span> /&gt;</span></span>;
</code></pre>
<h2>样式计算</h2>
<p>构建渲染树之前，需要计算每一个渲染对象的可视化属性。这是通过计算每个元素的样式属性来完成的。</p>
<p>样式包括来自各种来源的<strong>样式表</strong>、<strong>行内样式元素</strong>和 <strong>HTML 中的可视化属性</strong>。其中后者经过转化以匹配 CSS 样式属性。</p>
<p>样式表的来源包括<strong>浏览器的默认样式表</strong>、<strong>由网页作者提供的样式表</strong>以及由<strong>浏览器用户提供的用户样式表</strong>（浏览器允许您定义自己喜欢的样式。以 Firefox 为例，用户可以将自己喜欢的样式表放在 Firefox Profile 文件夹下）。</p>
<p>样式计算存在以下难点：</p>
<ol>
<li>样式数据是一个超大的结构，存储了无数的样式属性，这可能造成内存问题。</li>
<li>如果不进行优化，为每一个元素查找匹配的规则会造成性能问题。要为每一个元素遍历整个规则列表来寻找匹配规则，这是一项浩大的工程。选择器会具有很复杂的结构，这就会导致某个匹配过程一开始看起来很可能是正确的，但最终发现其实是徒劳的，必须尝试其他匹配路径。</li>
<li>应用规则涉及到相当复杂的层叠规则（用于定义这些规则的层次）</li>
</ol>
<p>&lt;br /&gt;</p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/browser-working-principle/main-process-parsing-css-and-computed-style.png&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;主线程解析CSS以添加计算后样式&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{640}</span> /&gt;</span></span>;
</code></pre>
<h3>共享样式数据</h3>
<p>WebKit 节点会引用样式对象 (RenderStyle)。这些对象在某些情况下可以由不同节点共享。这些节点是同级关系，并且：</p>
<ol>
<li>这些元素必须处于相同的鼠标状态（例如，不允许其中一个是 <code>:hover</code> 状态，而另一个不是）</li>
<li>任何元素都没有 <code>id</code></li>
<li>标记名称应匹配</li>
<li>类属性应匹配</li>
<li>映射属性的集合必须是完全相同的</li>
<li>链接状态必须匹配</li>
<li>焦点状态必须匹配</li>
<li>任何元素都不应受属性选择器的影响，这里所说的“影响”是指在选择器中的任何位置有任何使用了属性选择器的选择器匹配</li>
<li>元素中不能有任何 <code>inline</code> 样式属性</li>
<li>不能使用任何同级选择器。WebCore 在遇到任何同级选择器时，只会引发一个全局开关，并停用整个文档的样式共享（如果存在）。这包括 <code>+</code> 选择器以及 <code>:first-child</code> 和 <code>:last-child</code> 等选择器。</li>
</ol>
<h3>对规则进行处理以简化匹配</h3>
<p>样式规则来源：</p>
<ul>
<li>外部样式表获样式元素中的 CSS 规则</li>
</ul>
<pre class="hljs"><code class="language-css"><span class="hljs-selector-tag">p</span> {
  <span class="hljs-attribute">color</span>: blue;
}
</code></pre>
<ul>
<li>行内样式属性及类似内容</li>
</ul>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: blue&quot;</span> /&gt;</span>
</code></pre>
<ul>
<li>HTML 可视化属性（映射到相关的样式规则）</li>
</ul>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">&quot;blue&quot;</span> /&gt;</span>
</code></pre>
<p>后两种很容易和元素进行匹配，因为元素拥有样式属性，而且 HTML 属性可以使用元素作为键值进行映射。</p>
<p>样式表解析完毕后，系统会根据选择器将 CSS 规则添加到某个哈希表中。这些哈希表的选择器各不相同，包括 ID、类名称、标记名称等，还有一种通用哈希表，适合不属于上述类别的规则。如果是 ID 选择器，规则就会添加到 ID 表中；如果是类选择器，规则就会添加到类表中，以此类推。</p>
<p>这种处理可以大大简化规则匹配。我们无需查看每一条声明，只要从哈希表中提取元素的相关规则即可。这种优化方法可排除掉 95% 以上规则，因此在匹配过程中根本就不用考虑这些规则。</p>
<p>我们以如下的样式规则为例：</p>
<pre class="hljs"><code class="language-css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.error</span> {
  <span class="hljs-attribute">color</span>: red;
}
<span class="hljs-selector-id">#messageDiv</span> {
  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;
}
<span class="hljs-selector-tag">div</span> {
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span>;
}
</code></pre>
<p>第一条规则将插入类表，第二条将插入 ID 表，而第三条将插入标记表。</p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;error&quot;</span>&gt;</span>an error occurred<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;messageDiv&quot;</span>&gt;</span>this is a message<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>我们首先会为 <code>p</code> 元素寻找匹配的规则。类表中有一个 <code>error</code> 键，在下面可以找到 <code>p.error</code> 的规则。<code>div</code> 元素在 <code>id</code> 表（键为 <code>id</code>）和标记表中有相关的规则。剩下的工作就是找出哪些根据键提取的规则是真正匹配的了。</p>
<h3>层叠顺序</h3>
<p>样式对象具有与每个可视化属性一一对应的属性（均为 CSS 属性但更为通用）。如果某个属性未由任何匹配规则所定义，那么部分属性就可由父代元素样式对象继承。其他属性具有默认值。</p>
<p>如果定义不止一个，就会出现问题，需要通过层叠顺序来解决。</p>
<h4>样式表的级联顺序</h4>
<p>某个样式属性的声明可能会出现在多个样式表中，也可能在同一个样式表中出现多次。这意味着应用规则的顺序极为重要。这称为 <strong>层叠</strong> 顺序。根据 CSS2 规范，层叠的顺序为（优先级从低到高）：</p>
<ol>
<li>浏览器声明</li>
<li>用户普通声明</li>
<li>作者普通声明</li>
<li>作者的 <code>important</code> 声明</li>
<li>用户的 <code>important</code> 声明</li>
</ol>
<p>浏览器声明是重要程度最低的，而用户只有将该声明标记为 <code>important</code> 时才会覆盖网页作者的声明。同等级别的声明将根据 <a href="/front-end/browser-object-model/browser-working-principle/#%E7%89%B9%E5%BC%82%E6%80%A7">特异性</a> 以及它们被定义时的顺序进行排序。HTML 可视化属性将被转换为匹配的 CSS 声明，它们被视为最低优先级的作者规则。</p>
<h4>特异性</h4>
<p>选择器的特异性由 CSS2 规范定义：</p>
<ul>
<li>如果声明来自 <code>style</code> 属性，而不是带有选择器的规则，则记为 1，否则记为 0（=a）</li>
<li>记为选择器中 ID 属性的个数（=b）</li>
<li>记为选择器中其他属性和伪类的个数（=c）</li>
<li>记为选择器中元素名称和伪元素的个数（=d）</li>
</ul>
<p>将四个数字按 <code>a-b-c-d</code> 这样连接起来（位于大数进位的数字系统中），构成特异性。</p>
<p>您使用的进取制取决于上述类别中的最高计数。</p>
<p>例如，如果 <code>a = 14</code> ，您可以使用十六进制。如果 <code>a = 17</code>，那么您需要使用十七进制；当然不太可能出现这种情况，除非是存在如下的选择器：<code>html body div div p ...</code>（在选择器中出现了 17 个标记，这样的可能性极低）。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs"><code class="language-css"> *             {}  <span class="hljs-comment">/* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */</span>
 <span class="hljs-selector-tag">li</span>            {}  <span class="hljs-comment">/* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */</span>
 <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first</span>-<span class="hljs-selector-tag">line</span> {}  <span class="hljs-comment">/* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span>
 <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span>         {}  <span class="hljs-comment">/* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span>
 <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">ol</span>+<span class="hljs-selector-tag">li</span>      {}  <span class="hljs-comment">/* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */</span>
 <span class="hljs-selector-tag">h1</span> + *<span class="hljs-selector-attr">[rel=up]</span>{}  <span class="hljs-comment">/* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */</span>
 <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">ol</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.red</span>  {}  <span class="hljs-comment">/* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */</span>
 <span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.red</span><span class="hljs-selector-class">.level</span>  {}  <span class="hljs-comment">/* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */</span>
 <span class="hljs-selector-id">#x34y</span>         {}  <span class="hljs-comment">/* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */</span>
 style=&quot;&quot;          <span class="hljs-comment">/* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */</span>
</code></pre>
<h2>参考资料</h2>
<ul>
<li><a href="https://juejin.im/post/5b0a6f1af265da0ddb63ecd9#heading-4" target="_blank" rel="noopener noreferrer nofollow">📝 掘金：浏览器原理</a></li>
<li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Style_Computation" target="_blank" rel="noopener noreferrer nofollow">📝 浏览器的工作原理：新式网络浏览器幕后揭秘</a></li>
</ul>
4:["$","div",null,{"className":"markdown-body","children":["$","article",null,{"dangerouslySetInnerHTML":{"__html":"$c"}}]}]
a:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
8:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"front-end"}],["$","meta","2",{"name":"description","content":"front-end knowledge"}],["$","link","3",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
6:null
