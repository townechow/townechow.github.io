<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/d4dd73d504c89c58.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/485ff6fe79292a08.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/0ff121a467c0636f.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-53834dba86d90934.js"/><script src="/_next/static/chunks/4bd1b696-20882bf820444624.js" async=""></script><script src="/_next/static/chunks/517-98ed787e5f259f2c.js" async=""></script><script src="/_next/static/chunks/main-app-f33d3e3aed85e21f.js" async=""></script><meta name="next-size-adjust" content=""/><title>front-end</title><meta name="description" content="front-end knowledge"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><main><div class="markdown-body"><article><h1>渲染树构建</h1>
<p>在 <a href="/front-end/browser-object-model/browser-working-principle/construction-of-the-object-model">构建对象模型</a> 中，我们根据 HTML 和 CSS 输入构建了 DOM 树和 CSSOM 树。 不过，它们都是独立的对象，分别网罗文档不同方面的信息：一个描述内容，另一个则是描述需要对文档应用的样式规则。</p>
<p>DOM 树和 CSSOM 树将合并后在浏览器屏幕上渲染像素</p>
<ul>
<li>DOM 树与 CSSOM 树合并后形成渲染树</li>
<li>渲染树只包含渲染网页所需的节点</li>
<li><a href="/front-end/browser-object-model/browser-working-principle/layout">布局</a> 计算每个对象的精确位置和大小</li>
<li>最后一步是 <a href="/front-end/browser-object-model/browser-working-principle/paint">绘制</a>，使用最终渲染树将像素渲染到屏幕上</li>
</ul>
<h2>构建流程</h2>
<p>浏览器将 DOM 和 CSSOM 合并成一个 <strong>渲染树</strong>，它会网罗网页上所有可见的 DOM 内容，以及每个节点的所有 CSSOM 样式信息。</p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/browser-working-principle/render-tree.png&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;渲染树构建&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{640}</span> /&gt;</span></span>;
</code></pre>
<p>为了构建渲染树，浏览器大体上完成了下列工作：</p>
<ol>
<li>从 DOM 树的根节点开始遍历每个可见节点
<ul>
<li>某些节点不可见（例如脚本标记、元标记等），因为它们不会体现在渲染输出中，所以会被忽略。</li>
<li>某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如，样式设置为 <code>display: none</code> 属性的节点。</li>
</ul>
</li>
<li>对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。</li>
<li>发射可见节点，连同其内容和计算的样式。</li>
</ol>
<h2>遍历文档树</h2>
<p>渲染对象是和 DOM 元素相对应，但这种对应关系并非一一对应。</p>
<h3>非可视化元素</h3>
<p><strong>非可视化的 DOM 元素不会被插入渲染树中。</strong></p>
<p>例如， <code>&lt;head&gt;</code> 标签以及里面的内容，以及 <code>display:none</code> 的元素也会被去除，但是 <code>visibility</code> 属性值为 <code>hidden</code> 的元素仍会显示。</p>
<h3>复杂结构元素</h3>
<p><strong>部分 DOM 元素可对应多个可视化对象。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。</strong></p>
<p>例如， <code>select</code> 元素有 3 个渲染器：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也会作为新的呈现器而添加。</p>
<p>另一个关于多渲染器的例子是格式无效的 HTML。根据 CSS 规范，行内元素只能仅包含块状元素或行内元素中的一种。如果出现了混合内容，则应创建匿名的块状渲染对象，以包裹行内元素。所以我们平时的 <code>inline-block</code> 可以设置宽高。</p>
<h3>脱离文档流</h3>
<p><strong>部分渲染对象对应于 DOM 节点，但树中所在的位置与 DOM 节点不同。</strong></p>
<p>例如，浮动定位和绝对定位的元素处于正常的文本流之外，在两棵树上的位置不同，渲染树上标识出真实的结构，并用一个占位结构标识出它们原来的位置。</p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/browser-working-principle/render-tree-and-dom-tree.png&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;渲染树及对应DOM树&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{640}</span> /&gt;</span></span>;
</code></pre>
<h2>样式计算</h2>
<p>构建渲染树之前，需要计算每一个渲染对象的可视化属性。这是通过计算每个元素的样式属性来完成的。</p>
<p>样式包括来自各种来源的<strong>样式表</strong>、<strong>行内样式元素</strong>和 <strong>HTML 中的可视化属性</strong>。其中后者经过转化以匹配 CSS 样式属性。</p>
<p>样式表的来源包括<strong>浏览器的默认样式表</strong>、<strong>由网页作者提供的样式表</strong>以及由<strong>浏览器用户提供的用户样式表</strong>（浏览器允许您定义自己喜欢的样式。以 Firefox 为例，用户可以将自己喜欢的样式表放在 Firefox Profile 文件夹下）。</p>
<p>样式计算存在以下难点：</p>
<ol>
<li>样式数据是一个超大的结构，存储了无数的样式属性，这可能造成内存问题。</li>
<li>如果不进行优化，为每一个元素查找匹配的规则会造成性能问题。要为每一个元素遍历整个规则列表来寻找匹配规则，这是一项浩大的工程。选择器会具有很复杂的结构，这就会导致某个匹配过程一开始看起来很可能是正确的，但最终发现其实是徒劳的，必须尝试其他匹配路径。</li>
<li>应用规则涉及到相当复杂的层叠规则（用于定义这些规则的层次）</li>
</ol>
<p>&lt;br /&gt;</p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/browser-working-principle/main-process-parsing-css-and-computed-style.png&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;主线程解析CSS以添加计算后样式&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{640}</span> /&gt;</span></span>;
</code></pre>
<h3>共享样式数据</h3>
<p>WebKit 节点会引用样式对象 (RenderStyle)。这些对象在某些情况下可以由不同节点共享。这些节点是同级关系，并且：</p>
<ol>
<li>这些元素必须处于相同的鼠标状态（例如，不允许其中一个是 <code>:hover</code> 状态，而另一个不是）</li>
<li>任何元素都没有 <code>id</code></li>
<li>标记名称应匹配</li>
<li>类属性应匹配</li>
<li>映射属性的集合必须是完全相同的</li>
<li>链接状态必须匹配</li>
<li>焦点状态必须匹配</li>
<li>任何元素都不应受属性选择器的影响，这里所说的“影响”是指在选择器中的任何位置有任何使用了属性选择器的选择器匹配</li>
<li>元素中不能有任何 <code>inline</code> 样式属性</li>
<li>不能使用任何同级选择器。WebCore 在遇到任何同级选择器时，只会引发一个全局开关，并停用整个文档的样式共享（如果存在）。这包括 <code>+</code> 选择器以及 <code>:first-child</code> 和 <code>:last-child</code> 等选择器。</li>
</ol>
<h3>对规则进行处理以简化匹配</h3>
<p>样式规则来源：</p>
<ul>
<li>外部样式表获样式元素中的 CSS 规则</li>
</ul>
<pre class="hljs"><code class="language-css"><span class="hljs-selector-tag">p</span> {
  <span class="hljs-attribute">color</span>: blue;
}
</code></pre>
<ul>
<li>行内样式属性及类似内容</li>
</ul>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color: blue&quot;</span> /&gt;</span>
</code></pre>
<ul>
<li>HTML 可视化属性（映射到相关的样式规则）</li>
</ul>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">bgcolor</span>=<span class="hljs-string">&quot;blue&quot;</span> /&gt;</span>
</code></pre>
<p>后两种很容易和元素进行匹配，因为元素拥有样式属性，而且 HTML 属性可以使用元素作为键值进行映射。</p>
<p>样式表解析完毕后，系统会根据选择器将 CSS 规则添加到某个哈希表中。这些哈希表的选择器各不相同，包括 ID、类名称、标记名称等，还有一种通用哈希表，适合不属于上述类别的规则。如果是 ID 选择器，规则就会添加到 ID 表中；如果是类选择器，规则就会添加到类表中，以此类推。</p>
<p>这种处理可以大大简化规则匹配。我们无需查看每一条声明，只要从哈希表中提取元素的相关规则即可。这种优化方法可排除掉 95% 以上规则，因此在匹配过程中根本就不用考虑这些规则。</p>
<p>我们以如下的样式规则为例：</p>
<pre class="hljs"><code class="language-css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-class">.error</span> {
  <span class="hljs-attribute">color</span>: red;
}
<span class="hljs-selector-id">#messageDiv</span> {
  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;
}
<span class="hljs-selector-tag">div</span> {
  <span class="hljs-attribute">margin</span>: <span class="hljs-number">5px</span>;
}
</code></pre>
<p>第一条规则将插入类表，第二条将插入 ID 表，而第三条将插入标记表。</p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;error&quot;</span>&gt;</span>an error occurred<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;messageDiv&quot;</span>&gt;</span>this is a message<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>我们首先会为 <code>p</code> 元素寻找匹配的规则。类表中有一个 <code>error</code> 键，在下面可以找到 <code>p.error</code> 的规则。<code>div</code> 元素在 <code>id</code> 表（键为 <code>id</code>）和标记表中有相关的规则。剩下的工作就是找出哪些根据键提取的规则是真正匹配的了。</p>
<h3>层叠顺序</h3>
<p>样式对象具有与每个可视化属性一一对应的属性（均为 CSS 属性但更为通用）。如果某个属性未由任何匹配规则所定义，那么部分属性就可由父代元素样式对象继承。其他属性具有默认值。</p>
<p>如果定义不止一个，就会出现问题，需要通过层叠顺序来解决。</p>
<h4>样式表的级联顺序</h4>
<p>某个样式属性的声明可能会出现在多个样式表中，也可能在同一个样式表中出现多次。这意味着应用规则的顺序极为重要。这称为 <strong>层叠</strong> 顺序。根据 CSS2 规范，层叠的顺序为（优先级从低到高）：</p>
<ol>
<li>浏览器声明</li>
<li>用户普通声明</li>
<li>作者普通声明</li>
<li>作者的 <code>important</code> 声明</li>
<li>用户的 <code>important</code> 声明</li>
</ol>
<p>浏览器声明是重要程度最低的，而用户只有将该声明标记为 <code>important</code> 时才会覆盖网页作者的声明。同等级别的声明将根据 <a href="/front-end/browser-object-model/browser-working-principle/#%E7%89%B9%E5%BC%82%E6%80%A7">特异性</a> 以及它们被定义时的顺序进行排序。HTML 可视化属性将被转换为匹配的 CSS 声明，它们被视为最低优先级的作者规则。</p>
<h4>特异性</h4>
<p>选择器的特异性由 CSS2 规范定义：</p>
<ul>
<li>如果声明来自 <code>style</code> 属性，而不是带有选择器的规则，则记为 1，否则记为 0（=a）</li>
<li>记为选择器中 ID 属性的个数（=b）</li>
<li>记为选择器中其他属性和伪类的个数（=c）</li>
<li>记为选择器中元素名称和伪元素的个数（=d）</li>
</ul>
<p>将四个数字按 <code>a-b-c-d</code> 这样连接起来（位于大数进位的数字系统中），构成特异性。</p>
<p>您使用的进取制取决于上述类别中的最高计数。</p>
<p>例如，如果 <code>a = 14</code> ，您可以使用十六进制。如果 <code>a = 17</code>，那么您需要使用十七进制；当然不太可能出现这种情况，除非是存在如下的选择器：<code>html body div div p ...</code>（在选择器中出现了 17 个标记，这样的可能性极低）。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs"><code class="language-css"> *             {}  <span class="hljs-comment">/* a=0 b=0 c=0 d=0 -&gt; specificity = 0,0,0,0 */</span>
 <span class="hljs-selector-tag">li</span>            {}  <span class="hljs-comment">/* a=0 b=0 c=0 d=1 -&gt; specificity = 0,0,0,1 */</span>
 <span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first</span>-<span class="hljs-selector-tag">line</span> {}  <span class="hljs-comment">/* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span>
 <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">li</span>         {}  <span class="hljs-comment">/* a=0 b=0 c=0 d=2 -&gt; specificity = 0,0,0,2 */</span>
 <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">ol</span>+<span class="hljs-selector-tag">li</span>      {}  <span class="hljs-comment">/* a=0 b=0 c=0 d=3 -&gt; specificity = 0,0,0,3 */</span>
 <span class="hljs-selector-tag">h1</span> + *<span class="hljs-selector-attr">[rel=up]</span>{}  <span class="hljs-comment">/* a=0 b=0 c=1 d=1 -&gt; specificity = 0,0,1,1 */</span>
 <span class="hljs-selector-tag">ul</span> <span class="hljs-selector-tag">ol</span> <span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.red</span>  {}  <span class="hljs-comment">/* a=0 b=0 c=1 d=3 -&gt; specificity = 0,0,1,3 */</span>
 <span class="hljs-selector-tag">li</span><span class="hljs-selector-class">.red</span><span class="hljs-selector-class">.level</span>  {}  <span class="hljs-comment">/* a=0 b=0 c=2 d=1 -&gt; specificity = 0,0,2,1 */</span>
 <span class="hljs-selector-id">#x34y</span>         {}  <span class="hljs-comment">/* a=0 b=1 c=0 d=0 -&gt; specificity = 0,1,0,0 */</span>
 style=&quot;&quot;          <span class="hljs-comment">/* a=1 b=0 c=0 d=0 -&gt; specificity = 1,0,0,0 */</span>
</code></pre>
<h2>参考资料</h2>
<ul>
<li><a href="https://juejin.im/post/5b0a6f1af265da0ddb63ecd9#heading-4" target="_blank" rel="noopener noreferrer nofollow">📝 掘金：浏览器原理</a></li>
<li><a href="https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Style_Computation" target="_blank" rel="noopener noreferrer nofollow">📝 浏览器的工作原理：新式网络浏览器幕后揭秘</a></li>
</ul>
</article></div></main><script src="/_next/static/chunks/webpack-53834dba86d90934.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5244,[],\"\"]\n3:I[3866,[],\"\"]\n5:I[6213,[],\"OutletBoundary\"]\n7:I[6213,[],\"MetadataBoundary\"]\n9:I[6213,[],\"ViewportBoundary\"]\nb:I[4835,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/d4dd73d504c89c58.css\",\"style\"]\n:HL[\"/_next/static/css/485ff6fe79292a08.css\",\"style\"]\n:HL[\"/_next/static/css/0ff121a467c0636f.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"1zJy3VHENUSg9vzcRvJ6P\",\"p\":\"\",\"c\":[\"\",\"front-end\",\"browser-object-model\",\"browser-working-principle\",\"construction-of-render-tree\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"front-end\",{\"children\":[[\"slug\",\"browser-object-model/browser-working-principle/construction-of-render-tree\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d4dd73d504c89c58.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"front-end\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/485ff6fe79292a08.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0ff121a467c0636f.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"main\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[[\"slug\",\"browser-object-model/browser-working-principle/construction-of-render-tree\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"4fkhGo_r7LgqgZ7bVqx5L\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:T3f7a,"])</script><script>self.__next_f.push([1,"\u003ch1\u003e渲染树构建\u003c/h1\u003e\n\u003cp\u003e在 \u003ca href=\"/front-end/browser-object-model/browser-working-principle/construction-of-the-object-model\"\u003e构建对象模型\u003c/a\u003e 中，我们根据 HTML 和 CSS 输入构建了 DOM 树和 CSSOM 树。 不过，它们都是独立的对象，分别网罗文档不同方面的信息：一个描述内容，另一个则是描述需要对文档应用的样式规则。\u003c/p\u003e\n\u003cp\u003eDOM 树和 CSSOM 树将合并后在浏览器屏幕上渲染像素\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDOM 树与 CSSOM 树合并后形成渲染树\u003c/li\u003e\n\u003cli\u003e渲染树只包含渲染网页所需的节点\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/front-end/browser-object-model/browser-working-principle/layout\"\u003e布局\u003c/a\u003e 计算每个对象的精确位置和大小\u003c/li\u003e\n\u003cli\u003e最后一步是 \u003ca href=\"/front-end/browser-object-model/browser-working-principle/paint\"\u003e绘制\u003c/a\u003e，使用最终渲染树将像素渲染到屏幕上\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e构建流程\u003c/h2\u003e\n\u003cp\u003e浏览器将 DOM 和 CSSOM 合并成一个 \u003cstrong\u003e渲染树\u003c/strong\u003e，它会网罗网页上所有可见的 DOM 内容，以及每个节点的所有 CSSOM 样式信息。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e img \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;../../assets/browser-working-principle/render-tree.png\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e () =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;渲染树构建\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{img}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{640}\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e为了构建渲染树，浏览器大体上完成了下列工作：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e从 DOM 树的根节点开始遍历每个可见节点\n\u003cul\u003e\n\u003cli\u003e某些节点不可见（例如脚本标记、元标记等），因为它们不会体现在渲染输出中，所以会被忽略。\u003c/li\u003e\n\u003cli\u003e某些节点通过 CSS 隐藏，因此在渲染树中也会被忽略，例如，样式设置为 \u003ccode\u003edisplay: none\u003c/code\u003e 属性的节点。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e对于每个可见节点，为其找到适配的 CSSOM 规则并应用它们。\u003c/li\u003e\n\u003cli\u003e发射可见节点，连同其内容和计算的样式。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e遍历文档树\u003c/h2\u003e\n\u003cp\u003e渲染对象是和 DOM 元素相对应，但这种对应关系并非一一对应。\u003c/p\u003e\n\u003ch3\u003e非可视化元素\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e非可视化的 DOM 元素不会被插入渲染树中。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e例如， \u003ccode\u003e\u0026lt;head\u0026gt;\u003c/code\u003e 标签以及里面的内容，以及 \u003ccode\u003edisplay:none\u003c/code\u003e 的元素也会被去除，但是 \u003ccode\u003evisibility\u003c/code\u003e 属性值为 \u003ccode\u003ehidden\u003c/code\u003e 的元素仍会显示。\u003c/p\u003e\n\u003ch3\u003e复杂结构元素\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e部分 DOM 元素可对应多个可视化对象。它们往往是具有复杂结构的元素，无法用单一的矩形来描述。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e例如， \u003ccode\u003eselect\u003c/code\u003e 元素有 3 个渲染器：一个用于显示区域，一个用于下拉列表框，还有一个用于按钮。如果由于宽度不够，文本无法在一行中显示而分为多行，那么新的行也会作为新的呈现器而添加。\u003c/p\u003e\n\u003cp\u003e另一个关于多渲染器的例子是格式无效的 HTML。根据 CSS 规范，行内元素只能仅包含块状元素或行内元素中的一种。如果出现了混合内容，则应创建匿名的块状渲染对象，以包裹行内元素。所以我们平时的 \u003ccode\u003einline-block\u003c/code\u003e 可以设置宽高。\u003c/p\u003e\n\u003ch3\u003e脱离文档流\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e部分渲染对象对应于 DOM 节点，但树中所在的位置与 DOM 节点不同。\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e例如，浮动定位和绝对定位的元素处于正常的文本流之外，在两棵树上的位置不同，渲染树上标识出真实的结构，并用一个占位结构标识出它们原来的位置。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e img \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;../../assets/browser-working-principle/render-tree-and-dom-tree.png\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e () =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;渲染树及对应DOM树\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{img}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{640}\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e样式计算\u003c/h2\u003e\n\u003cp\u003e构建渲染树之前，需要计算每一个渲染对象的可视化属性。这是通过计算每个元素的样式属性来完成的。\u003c/p\u003e\n\u003cp\u003e样式包括来自各种来源的\u003cstrong\u003e样式表\u003c/strong\u003e、\u003cstrong\u003e行内样式元素\u003c/strong\u003e和 \u003cstrong\u003eHTML 中的可视化属性\u003c/strong\u003e。其中后者经过转化以匹配 CSS 样式属性。\u003c/p\u003e\n\u003cp\u003e样式表的来源包括\u003cstrong\u003e浏览器的默认样式表\u003c/strong\u003e、\u003cstrong\u003e由网页作者提供的样式表\u003c/strong\u003e以及由\u003cstrong\u003e浏览器用户提供的用户样式表\u003c/strong\u003e（浏览器允许您定义自己喜欢的样式。以 Firefox 为例，用户可以将自己喜欢的样式表放在 Firefox Profile 文件夹下）。\u003c/p\u003e\n\u003cp\u003e样式计算存在以下难点：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e样式数据是一个超大的结构，存储了无数的样式属性，这可能造成内存问题。\u003c/li\u003e\n\u003cli\u003e如果不进行优化，为每一个元素查找匹配的规则会造成性能问题。要为每一个元素遍历整个规则列表来寻找匹配规则，这是一项浩大的工程。选择器会具有很复杂的结构，这就会导致某个匹配过程一开始看起来很可能是正确的，但最终发现其实是徒劳的，必须尝试其他匹配路径。\u003c/li\u003e\n\u003cli\u003e应用规则涉及到相当复杂的层叠规则（用于定义这些规则的层次）\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u0026lt;br /\u0026gt;\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e img \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;../../assets/browser-working-principle/main-process-parsing-css-and-computed-style.png\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e () =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;主线程解析CSS以添加计算后样式\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{img}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{640}\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e共享样式数据\u003c/h3\u003e\n\u003cp\u003eWebKit 节点会引用样式对象 (RenderStyle)。这些对象在某些情况下可以由不同节点共享。这些节点是同级关系，并且：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e这些元素必须处于相同的鼠标状态（例如，不允许其中一个是 \u003ccode\u003e:hover\u003c/code\u003e 状态，而另一个不是）\u003c/li\u003e\n\u003cli\u003e任何元素都没有 \u003ccode\u003eid\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e标记名称应匹配\u003c/li\u003e\n\u003cli\u003e类属性应匹配\u003c/li\u003e\n\u003cli\u003e映射属性的集合必须是完全相同的\u003c/li\u003e\n\u003cli\u003e链接状态必须匹配\u003c/li\u003e\n\u003cli\u003e焦点状态必须匹配\u003c/li\u003e\n\u003cli\u003e任何元素都不应受属性选择器的影响，这里所说的“影响”是指在选择器中的任何位置有任何使用了属性选择器的选择器匹配\u003c/li\u003e\n\u003cli\u003e元素中不能有任何 \u003ccode\u003einline\u003c/code\u003e 样式属性\u003c/li\u003e\n\u003cli\u003e不能使用任何同级选择器。WebCore 在遇到任何同级选择器时，只会引发一个全局开关，并停用整个文档的样式共享（如果存在）。这包括 \u003ccode\u003e+\u003c/code\u003e 选择器以及 \u003ccode\u003e:first-child\u003c/code\u003e 和 \u003ccode\u003e:last-child\u003c/code\u003e 等选择器。\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch3\u003e对规则进行处理以简化匹配\u003c/h3\u003e\n\u003cp\u003e样式规则来源：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e外部样式表获样式元素中的 CSS 规则\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-css\"\u003e\u003cspan class=\"hljs-selector-tag\"\u003ep\u003c/span\u003e {\n  \u003cspan class=\"hljs-attribute\"\u003ecolor\u003c/span\u003e: blue;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e行内样式属性及类似内容\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;color: blue\u0026quot;\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003eHTML 可视化属性（映射到相关的样式规则）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ebgcolor\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;blue\u0026quot;\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e后两种很容易和元素进行匹配，因为元素拥有样式属性，而且 HTML 属性可以使用元素作为键值进行映射。\u003c/p\u003e\n\u003cp\u003e样式表解析完毕后，系统会根据选择器将 CSS 规则添加到某个哈希表中。这些哈希表的选择器各不相同，包括 ID、类名称、标记名称等，还有一种通用哈希表，适合不属于上述类别的规则。如果是 ID 选择器，规则就会添加到 ID 表中；如果是类选择器，规则就会添加到类表中，以此类推。\u003c/p\u003e\n\u003cp\u003e这种处理可以大大简化规则匹配。我们无需查看每一条声明，只要从哈希表中提取元素的相关规则即可。这种优化方法可排除掉 95% 以上规则，因此在匹配过程中根本就不用考虑这些规则。\u003c/p\u003e\n\u003cp\u003e我们以如下的样式规则为例：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-css\"\u003e\u003cspan class=\"hljs-selector-tag\"\u003ep\u003c/span\u003e\u003cspan class=\"hljs-selector-class\"\u003e.error\u003c/span\u003e {\n  \u003cspan class=\"hljs-attribute\"\u003ecolor\u003c/span\u003e: red;\n}\n\u003cspan class=\"hljs-selector-id\"\u003e#messageDiv\u003c/span\u003e {\n  \u003cspan class=\"hljs-attribute\"\u003eheight\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e50px\u003c/span\u003e;\n}\n\u003cspan class=\"hljs-selector-tag\"\u003ediv\u003c/span\u003e {\n  \u003cspan class=\"hljs-attribute\"\u003emargin\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e5px\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e第一条规则将插入类表，第二条将插入 ID 表，而第三条将插入标记表。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eclass\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;error\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003ean error occurred\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ep\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;messageDiv\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003ethis is a message\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e我们首先会为 \u003ccode\u003ep\u003c/code\u003e 元素寻找匹配的规则。类表中有一个 \u003ccode\u003eerror\u003c/code\u003e 键，在下面可以找到 \u003ccode\u003ep.error\u003c/code\u003e 的规则。\u003ccode\u003ediv\u003c/code\u003e 元素在 \u003ccode\u003eid\u003c/code\u003e 表（键为 \u003ccode\u003eid\u003c/code\u003e）和标记表中有相关的规则。剩下的工作就是找出哪些根据键提取的规则是真正匹配的了。\u003c/p\u003e\n\u003ch3\u003e层叠顺序\u003c/h3\u003e\n\u003cp\u003e样式对象具有与每个可视化属性一一对应的属性（均为 CSS 属性但更为通用）。如果某个属性未由任何匹配规则所定义，那么部分属性就可由父代元素样式对象继承。其他属性具有默认值。\u003c/p\u003e\n\u003cp\u003e如果定义不止一个，就会出现问题，需要通过层叠顺序来解决。\u003c/p\u003e\n\u003ch4\u003e样式表的级联顺序\u003c/h4\u003e\n\u003cp\u003e某个样式属性的声明可能会出现在多个样式表中，也可能在同一个样式表中出现多次。这意味着应用规则的顺序极为重要。这称为 \u003cstrong\u003e层叠\u003c/strong\u003e 顺序。根据 CSS2 规范，层叠的顺序为（优先级从低到高）：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e浏览器声明\u003c/li\u003e\n\u003cli\u003e用户普通声明\u003c/li\u003e\n\u003cli\u003e作者普通声明\u003c/li\u003e\n\u003cli\u003e作者的 \u003ccode\u003eimportant\u003c/code\u003e 声明\u003c/li\u003e\n\u003cli\u003e用户的 \u003ccode\u003eimportant\u003c/code\u003e 声明\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e浏览器声明是重要程度最低的，而用户只有将该声明标记为 \u003ccode\u003eimportant\u003c/code\u003e 时才会覆盖网页作者的声明。同等级别的声明将根据 \u003ca href=\"/front-end/browser-object-model/browser-working-principle/#%E7%89%B9%E5%BC%82%E6%80%A7\"\u003e特异性\u003c/a\u003e 以及它们被定义时的顺序进行排序。HTML 可视化属性将被转换为匹配的 CSS 声明，它们被视为最低优先级的作者规则。\u003c/p\u003e\n\u003ch4\u003e特异性\u003c/h4\u003e\n\u003cp\u003e选择器的特异性由 CSS2 规范定义：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果声明来自 \u003ccode\u003estyle\u003c/code\u003e 属性，而不是带有选择器的规则，则记为 1，否则记为 0（=a）\u003c/li\u003e\n\u003cli\u003e记为选择器中 ID 属性的个数（=b）\u003c/li\u003e\n\u003cli\u003e记为选择器中其他属性和伪类的个数（=c）\u003c/li\u003e\n\u003cli\u003e记为选择器中元素名称和伪元素的个数（=d）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e将四个数字按 \u003ccode\u003ea-b-c-d\u003c/code\u003e 这样连接起来（位于大数进位的数字系统中），构成特异性。\u003c/p\u003e\n\u003cp\u003e您使用的进取制取决于上述类别中的最高计数。\u003c/p\u003e\n\u003cp\u003e例如，如果 \u003ccode\u003ea = 14\u003c/code\u003e ，您可以使用十六进制。如果 \u003ccode\u003ea = 17\u003c/code\u003e，那么您需要使用十七进制；当然不太可能出现这种情况，除非是存在如下的选择器：\u003ccode\u003ehtml body div div p ...\u003c/code\u003e（在选择器中出现了 17 个标记，这样的可能性极低）。\u003c/p\u003e\n\u003cp\u003e🌰 \u003cstrong\u003e代码示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-css\"\u003e *             {}  \u003cspan class=\"hljs-comment\"\u003e/* a=0 b=0 c=0 d=0 -\u0026gt; specificity = 0,0,0,0 */\u003c/span\u003e\n \u003cspan class=\"hljs-selector-tag\"\u003eli\u003c/span\u003e            {}  \u003cspan class=\"hljs-comment\"\u003e/* a=0 b=0 c=0 d=1 -\u0026gt; specificity = 0,0,0,1 */\u003c/span\u003e\n \u003cspan class=\"hljs-selector-tag\"\u003eli\u003c/span\u003e\u003cspan class=\"hljs-selector-pseudo\"\u003e:first\u003c/span\u003e-\u003cspan class=\"hljs-selector-tag\"\u003eline\u003c/span\u003e {}  \u003cspan class=\"hljs-comment\"\u003e/* a=0 b=0 c=0 d=2 -\u0026gt; specificity = 0,0,0,2 */\u003c/span\u003e\n \u003cspan class=\"hljs-selector-tag\"\u003eul\u003c/span\u003e \u003cspan class=\"hljs-selector-tag\"\u003eli\u003c/span\u003e         {}  \u003cspan class=\"hljs-comment\"\u003e/* a=0 b=0 c=0 d=2 -\u0026gt; specificity = 0,0,0,2 */\u003c/span\u003e\n \u003cspan class=\"hljs-selector-tag\"\u003eul\u003c/span\u003e \u003cspan class=\"hljs-selector-tag\"\u003eol\u003c/span\u003e+\u003cspan class=\"hljs-selector-tag\"\u003eli\u003c/span\u003e      {}  \u003cspan class=\"hljs-comment\"\u003e/* a=0 b=0 c=0 d=3 -\u0026gt; specificity = 0,0,0,3 */\u003c/span\u003e\n \u003cspan class=\"hljs-selector-tag\"\u003eh1\u003c/span\u003e + *\u003cspan class=\"hljs-selector-attr\"\u003e[rel=up]\u003c/span\u003e{}  \u003cspan class=\"hljs-comment\"\u003e/* a=0 b=0 c=1 d=1 -\u0026gt; specificity = 0,0,1,1 */\u003c/span\u003e\n \u003cspan class=\"hljs-selector-tag\"\u003eul\u003c/span\u003e \u003cspan class=\"hljs-selector-tag\"\u003eol\u003c/span\u003e \u003cspan class=\"hljs-selector-tag\"\u003eli\u003c/span\u003e\u003cspan class=\"hljs-selector-class\"\u003e.red\u003c/span\u003e  {}  \u003cspan class=\"hljs-comment\"\u003e/* a=0 b=0 c=1 d=3 -\u0026gt; specificity = 0,0,1,3 */\u003c/span\u003e\n \u003cspan class=\"hljs-selector-tag\"\u003eli\u003c/span\u003e\u003cspan class=\"hljs-selector-class\"\u003e.red\u003c/span\u003e\u003cspan class=\"hljs-selector-class\"\u003e.level\u003c/span\u003e  {}  \u003cspan class=\"hljs-comment\"\u003e/* a=0 b=0 c=2 d=1 -\u0026gt; specificity = 0,0,2,1 */\u003c/span\u003e\n \u003cspan class=\"hljs-selector-id\"\u003e#x34y\u003c/span\u003e         {}  \u003cspan class=\"hljs-comment\"\u003e/* a=0 b=1 c=0 d=0 -\u0026gt; specificity = 0,1,0,0 */\u003c/span\u003e\n style=\u0026quot;\u0026quot;          \u003cspan class=\"hljs-comment\"\u003e/* a=1 b=0 c=0 d=0 -\u0026gt; specificity = 1,0,0,0 */\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e参考资料\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.im/post/5b0a6f1af265da0ddb63ecd9#heading-4\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 掘金：浏览器原理\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/#Style_Computation\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 浏览器的工作原理：新式网络浏览器幕后揭秘\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"markdown-body\",\"children\":[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"front-end\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"front-end knowledge\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>