<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/ec0a9d078e716e00.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/485ff6fe79292a08.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/0ff121a467c0636f.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-038c2e688b596d0e.js"/><script src="/_next/static/chunks/4bd1b696-20882bf820444624.js" async=""></script><script src="/_next/static/chunks/517-98ed787e5f259f2c.js" async=""></script><script src="/_next/static/chunks/main-app-f33d3e3aed85e21f.js" async=""></script><meta name="next-size-adjust" content=""/><title>front-end</title><meta name="description" content="front-end knowledge"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><main><div class="markdown-body"><h1>HTTP2</h1><article><h1>HTTP2</h1>
<p>HTTP/2（超文本传输协议第 2 版，最初命名为 HTTP 2.0），简称为 h2（基于 TLS/1.2 或以上版本的加密连接）或 h2c（非加密连接），是 HTTP 协议的的第二个主要版本，使用于万维网。</p>
<h2>旧版本问题</h2>
<ol>
<li><strong>多个 TCP 连接</strong>：虽然 HTTP/1.1 管线化可以支持请求并发，但是浏览器很难实现，主流浏览器厂商都禁用了管线化</li>
<li><strong>队头阻塞</strong>：TCP 连接上只能发送一个请求，由于单连接上的串行请求，前面的请求未完成前，后续的请求都在排队等待</li>
<li><strong>头部冗余</strong>：HTTP/1.x 采用文本格式传输，首部未压缩，无状态特性让每个请求都会带上 Cookie、User-Agent 等重复的信息</li>
<li><strong>不支持服务端主动推送</strong>：HTTP/1.1 不支持服务推送消息，只能使用轮询的方式解决</li>
</ol>
<h2>新特性</h2>
<p>在了解 HTTP/2 新特性前，可以通过 DEMO 直观感受 HTTP/1.1 与 HTTP/2 的差距：</p>
<p><a href="https://http2.akamai.com/demo" target="_blank" rel="noopener noreferrer nofollow">HTTP/2: the Future of the Internet | Akamai</a></p>
<p>主要新特性：</p>
<ul>
<li><strong>传输数据量大量减少</strong>
<ul>
<li><a href="/front-end/computer-networks/http/#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E5%B8%A7">二进制分帧</a></li>
<li><a href="/front-end/computer-networks/http/#%E6%A0%87%E5%A4%B4%E5%8E%8B%E7%BC%A9">标头压缩</a></li>
</ul>
</li>
<li><strong>多路复用及相关功能</strong>
<ul>
<li><a href="/front-end/computer-networks/http/#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">多路复用</a></li>
<li>优先级与依赖性</li>
</ul>
</li>
<li><strong>服务器消息推送</strong>
<ul>
<li><a href="/front-end/computer-networks/http">服务器推送</a></li>
</ul>
</li>
<li>其他
<ul>
<li>重置流</li>
<li>流量控制</li>
<li>HTTPS RFC 规范并没有要求 HTTP2 强制使用 TLS，但是目前世界所有浏览器和- 服务器实现都基于 HTTPS 来实现 HTTP2</li>
</ul>
</li>
</ul>
<h3>二进制分帧</h3>
<p>相比于 HTTP/1.x 基于以换行符作为纯文本的分隔符的解析，HTTP/2 将所有的传输信息分割为更小的消息和帧，并对它们采用 <strong>二进制格式编码</strong>。基于二进制可以使协议有更多的扩展性，例如，引入帧来传输数据和指令。</p>
<p>HTTP/2 所有性能增强的核心在于新的 &lt;strong style=&quot;color:red&quot;&gt;二进制分帧层&lt;/strong&gt;，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输。</p>
<blockquote>
<p>这里所谓的 &lt;strong style=&quot;color:red&quot;&gt;层&lt;/strong&gt;，指的是位于套接字接口与应用可见的高级 HTTP API 之间一个经过优化的新编码机制：HTTP 的语义（包括各种动词、方法、标头）都不受影响，不同的是传输期间对它们的编码方式变了。</p>
</blockquote>
<h4>数据流、消息和帧</h4>
<p>新的二进制分帧机制改变了客户端与服务器之间交换数据的方式。</p>
<p>为了说明这个过程，我们需要了解 HTTP/2 的三个概念：</p>
<ul>
<li><strong>数据流</strong>（Stream）：已建立的连接内的 &lt;u&gt;双向字节流&lt;/u&gt;，可以承载一条或多条消息</li>
<li><strong>消息</strong>（Message）：与逻辑请求或响应消息对应的完整的一系列帧</li>
<li><strong>帧</strong>（Frame）：HTTP/2 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流</li>
</ul>
<p>这些概念的关系总结如下：</p>
<ul>
<li>所有通信都在一个 TCP 连接上完成，此连接 <strong>可以承载任意数量的双向数据流</strong></li>
<li>每个数据流都有一个 <strong>唯一的标识符和可选的优先级信息</strong>，用于承载双向消息</li>
<li>每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧</li>
<li>帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载等等。来自不同数据流的帧可以交错发送，然后根据每个帧头的数据流标识符重新组装。</li>
</ul>
<p>HTTP/2 将 HTTP 协议通信分解为二进制编码帧的交换，这些帧对应着特定数据流中的消息。所有这些都在一个 TCP 连接内复用，这是 HTTP/2 协议所有其他功能和性能优化的基础。</p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/http2/connection.svg&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;HTTP 数据流通信连接&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{640}</span> /&gt;</span></span>;
</code></pre>
<p><strong>消息的组成：HEADERS 帧与 DATA 帧</strong></p>
<ul>
<li>HEADERS frame 头部帧</li>
<li>DATA frame 数据帧</li>
</ul>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/http2/binary-framing.png&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;消息组成&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{640}</span> /&gt;</span></span>;
</code></pre>
<p>更多关于帧定义详解，请查阅 <a href="https://halfrost.com/http2-http-frames-definitions/" target="_blank" rel="noopener noreferrer nofollow">HTTP/2 中的帧定义</a></p>
<h3>标头压缩</h3>
<p>标头压缩（Header compression）：每个 HTTP 传输都承载一组标头，这些标头说明了传输的资源及其属性。 在 HTTP/1.x 中，此元数据始终以纯文本形式，通常会给每个传输增加 500–800 字节的开销。如果使用 HTTP Cookie，增加的开销有时会达到上千字节。</p>
<p>为了减少此开销和提升性能，HTTP/2 使用 &lt;strong style=&quot;color:red&quot;&gt;HPACK&lt;/strong&gt; 压缩格式压缩请求和响应标头元数据，这种格式采用两种简单但是强大的技术：</p>
<ol>
<li>这种格式支持通过静态霍夫曼代码对传输的标头字段进行编码，从而减小了各个传输的大小。</li>
<li>这种格式要求通讯双方 <strong>各自缓存一份头域索引表</strong>，相同的消息头只发送 <strong>索引号</strong>（换句话说，它可以建立一个共享的压缩上下文），此索引表随后会用作参考，对之前传输的值进行有效编码。</li>
</ol>
<p>利用霍夫曼编码（HPACK），可以在传输时对各个值进行压缩，而利用之前传输值的索引列表，我们可以通过传输索引值的方式对重复值进行编码，索引值可用于有效查询和重构完整的标头键值对。</p>
<p><strong>索引表用法示意</strong></p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/http2/headers-compress.jpg&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;索引表用法示意&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{520}</span> /&gt;</span></span>;
</code></pre>
<p>客户端发了两次请求，第一次请求有完整的 HTTP 报文头部，第二次请求的时候只有一个 <code>path</code> 的字段不一样，但是这次报文头它只需要发送一个 <code>path</code> 的字段就好了，这样就大大减少了发送的量。这个的实现要求客户端和服务同时维护一个报文头表。</p>
<h4>HPACK 霍夫曼编码</h4>
<p>HPACK 压缩示意：</p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/http2/hpack-header-compression.png&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;HPACK压缩示意&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{640}</span> /&gt;</span></span>;
</code></pre>
<p>作为一种进一步优化方式，HPACK 压缩上下文包含一个静态字典和一个动态字典：</p>
<ul>
<li><a href="https://httpwg.org/specs/rfc7541.html#static.table.definition" target="_blank" rel="noopener noreferrer nofollow">静态字典</a> 在规范中定义，并提供了一个包含所有连接都可能使用的常用 HTTP 标头字段（例如，有效标头名称）的列表</li>
<li>动态字典最初为空，将根据在特定连接内交换的值进行更新</li>
</ul>
<p>因此，为之前未见过的值采用静态 Huffman 编码，并替换每一侧静态表或动态表中已存在值的索引，可以减小每个请求的大小。</p>
<blockquote>
<p>⚠️ <strong>注意</strong>：在 HTTP/2 中，请求和响应标头字段的定义保持不变，仅有一些微小的差异：所有标头字段名称均为小写，请求行现在拆分成各个 <code>:method</code>、<code>:scheme</code>、<code>:authority</code> 和 <code>:path</code> 伪标头字段。</p>
</blockquote>
<ul>
<li>关于 <a href="https://tools.ietf.org/html/rfc7541" target="_blank" rel="noopener noreferrer nofollow">HPACK 头部压缩标准</a> 的制定</li>
<li><a href="https://httpwg.org/specs/rfc7541.html" target="_blank" rel="noopener noreferrer nofollow">HPACK：Header Compression for HTTP/2</a></li>
</ul>
<h3>多路复用</h3>
<p><strong>多路复用（MultiPlexing）</strong>：通过该功能，在一条连接上，您的浏览器可以同时发起无数个请求，并且响应可以同时响应。另外，多路复用中支持了流的优先级（Stream dependencies）设置，允许客户端告知服务器最优资源，可以优先传输。</p>
<p>当我们打开网站时，浏览器会对每个网页并发的连接进行限制，一般浏览器的 HTTP 请求并发数限制在 6-8 个。但实际上，绝大部分网站首页所需要的资源个数远大于这个限制。所以为了不让资源在下载阶段就被阻塞住，我们往往会把一些静态资源分散到 CDN 或其他服务器上，从而通过多域名的方式突破浏览器对并发连接数的限制，从而使得网站能同时下载尽可能多的资源。</p>
<p>但建立更多的连接也意味更多的开销。每个 HTTP 请求都对应建立 TCP 连接，也许有些资源体积只有几 kb，这些情况下建立连接本身的开销就变得更客观，很可能三次握手的实践比传输时间还长</p>
<p>在 HTTP/2 中，有了二进制分帧之后，HTTP/2 不再依赖 TCP 链接去实现多流并行，而是通过 &lt;strong style=&quot;color:red&quot;&gt;流&lt;/strong&gt; 支持多路复用。</p>
<p>将 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装是 HTTP/2 最重要的一项增强。事实上，这个机制会在整个网络技术栈中引发一系列连锁反应，从而带来巨大的性能提升，让我们可以：</p>
<ul>
<li>并行交错地发送多个请求/响应，请求/响应之间互不影响</li>
<li>不必再为绕过 HTTP/1.x 限制而做很多工作（请参阅 <a href="https://hpbn.co/optimizing-application-delivery/#optimizing-for-http1x" target="_blank" rel="noopener noreferrer nofollow">针对 HTTP/1.x 进行优化</a>，例如级联文件、Image Sprites 和域名分片</li>
<li>消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时间</li>
</ul>
<p>HTTP/2 中的新二进制分帧层解决了 HTTP/1.x 中存在的 <strong>队头阻塞</strong> 问题，也消除了并行处理和发送请求及响应时对多个连接的依赖。</p>
<h3>服务器推送</h3>
<p>服务端推送（Server push）：同 SPDY 一样，HTTP/2 也具有客户端推送功能。目前，大多数网站已经启用 HTTP/2，如淘宝。使用服务器推动，可以提前将资源推送至浏览器缓存。</p>
<p>HTTP/2 中的 Server Push 并不是指类似于现在的 Server Sent Event（SSE） 或者 WebSocket 的推送技术。<strong>它是一种服务器根据客户端以前发送的请求来猜测未来的请求，并提前将未来请求的结果推送给客户端的技术</strong>。</p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/http2/server-push.png&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;服务器推送&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{640}</span> /&gt;</span></span>;
</code></pre>
<blockquote>
<p>为什么在浏览器中需要一种此类机制呢？</p>
</blockquote>
<p>一个典型的网络应用包含多种资源，客户端需要检查服务器提供的文档才能逐个找到它们。 那为什么不让服务器提前推送这些资源，从而减少额外的延迟时间呢？ 服务器已经知道客户端下一步要请求什么资源，这时候服务器推送即可派上用场。</p>
<p>事实上，如果您在网页中内联过 CSS、JavaScript，或者通过数据 URI 内联过其他资产（请参阅 <a href="https://hpbn.co/http1x/#resource-inlining" target="_blank" rel="noopener noreferrer nofollow">资源内联</a>），那么您就已经亲身体验过服务器推送了。 对于将资源手动内联到文档中的过程，我们实际上是在将资源推送给客户端，而不是等待客户端请求。 使用 HTTP/2，我们不仅可以实现相同结果，还会获得其他性能优势。</p>
<p>推送资源可以进行以下处理：</p>
<ul>
<li>由客户端缓存</li>
<li>在不同页面之间重用</li>
<li>与其他资源一起复用</li>
<li>由服务器设定优先级</li>
<li>被客户端拒绝</li>
</ul>
<h4>Nginx 配置实现</h4>
<p>通过 Nginx 配置能主动推送两个 HTML 文档中需要请求的文件：</p>
<pre class="hljs"><code class="language-nginx"><span class="hljs-section">server</span> {
    <span class="hljs-comment"># 设定开启使用 HTTP2</span>
    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl http2;
    <span class="hljs-attribute">server_name</span>  localhost;

    <span class="hljs-attribute">ssl</span>                      <span class="hljs-literal">on</span>;
    <span class="hljs-attribute">ssl_certificate</span>          /etc/nginx/certs/example.crt;
    <span class="hljs-attribute">ssl_certificate_key</span>      /etc/nginx/certs/example.key;

    <span class="hljs-attribute">ssl_session_timeout</span>  <span class="hljs-number">5m</span>;

    <span class="hljs-attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;
    <span class="hljs-attribute">ssl_protocols</span> SSLv3 TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>;
    <span class="hljs-attribute">ssl_prefer_server_ciphers</span>   <span class="hljs-literal">on</span>;

    <span class="hljs-section">location</span> / {
      <span class="hljs-attribute">root</span>   /usr/share/nginx/html;
      <span class="hljs-attribute">index</span>  index.html index.htm;

      <span class="hljs-comment"># 服务器主动推送这两个文件</span>
      <span class="hljs-attribute">http2_push</span> /style.css;
      <span class="hljs-attribute">http2_push</span> /example.png;
    }
</code></pre>
<p>这种方式需要写在服务器配置中，每次修改都要重启服务，而且应用与服务器的配置不应该混在一起。</p>
<h4>服务端实现</h4>
<p>服务器推送还有另一个实现方法，就是后端应用产生 HTTP 响应头信息 <code>Link</code> 命令。服务器发现有这个头信息，就会进行服务器推送。</p>
<pre class="hljs"><code class="language-http"><span class="hljs-attribute">Link</span><span class="hljs-punctuation">: </span>&lt;/styles.css&gt;; rel=preload; as=style
</code></pre>
<p>如果要推送多个资源：</p>
<pre class="hljs"><code class="language-http"><span class="hljs-attribute">Link</span><span class="hljs-punctuation">: </span>&lt;/styles.css&gt;; rel=preload; as=style, &lt;/example.png&gt;; rel=preload; as=image
</code></pre>
<p>这时，Nginx 的配置改成下面这样。</p>
<pre class="hljs"><code class="language-nginx"><span class="hljs-section">server</span> {
    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl http2;

    <span class="hljs-comment"># ...</span>

    <span class="hljs-attribute">root</span> /var/www/html;

    <span class="hljs-section">location</span> = / {
        <span class="hljs-attribute">proxy_pass</span> http://upstream;
        <span class="hljs-attribute">http2_push_preload</span> <span class="hljs-literal">on</span>;
    }
}
</code></pre>
<p>如果服务器或者浏览器不支持 HTTP2，那么浏览器就会按照 <code>preload</code> 来处理这个头信息，预加载指定的资源文件。</p>
<p>事实上，这个头信息就是 <code>preload</code> 标准提出的，它的语法和 <code>as</code> 属性的值都写在了 <a href="https://w3c.github.io/preload/#as-attribute" target="_blank" rel="noopener noreferrer nofollow">标准</a> 里面。</p>
<p>参考 <a href="https://blog.risingstack.com/node-js-http-2-push/" target="_blank" rel="noopener noreferrer nofollow">HTTP/2 Server Push with Node.js</a> 实现。</p>
<h4>缓存问题</h4>
<p>服务器推送有一个很麻烦的问题。所要推送的资源文件，如果浏览器已经有缓存，推送就是浪费带宽。即使推送的文件版本更新，浏览器也会优先使用本地缓存。</p>
<p>一种解决办法是，只对第一次访问的用户开启服务器推送。下面是 Nginx 官方给出的示例，根据 Cookie 判断是否为第一次访问。</p>
<pre class="hljs"><code class="language-nginx"><span class="hljs-section">server</span> {
    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl http2 default_server;

    <span class="hljs-attribute">ssl_certificate</span> ssl/certificate.pem;
    <span class="hljs-attribute">ssl_certificate_key</span> ssl/key.pem;

    <span class="hljs-attribute">root</span> /var/www/html;
    <span class="hljs-attribute">http2_push_preload</span> <span class="hljs-literal">on</span>;

    <span class="hljs-section">location</span> = /demo.html {
        <span class="hljs-attribute">add_header</span> Set-Cookie <span class="hljs-string">&quot;session=1&quot;</span>;
        <span class="hljs-attribute">add_header</span> Link <span class="hljs-variable">$resources</span>;
    }
}


<span class="hljs-attribute">map</span> <span class="hljs-variable">$http_cookie</span> <span class="hljs-variable">$resources</span> {
    &quot;~*session=1&quot; &quot;&quot;;
    <span class="hljs-attribute">default</span> <span class="hljs-string">&quot;&lt;/style.css&gt;; as=style; rel=preload&quot;</span>;
}
</code></pre>
<h3>安全提升</h3>
<blockquote>
<p>HTTP/2 是不是必须基于 TLS/SSL 协议？</p>
</blockquote>
<ul>
<li>IETF 标准不要求必须基于 TLS/SSL 协议 📌</li>
<li>浏览器要求必须基于 TLS/SSL 协议 📌</li>
<li>在 TLS 层 ALPN（Application Layer Protocol Negotiation）扩展做协商，只认 HTTP/1.x 的代理服务器不会干扰 HTTP/2</li>
<li>sheme：<code>http://</code> 和 <code>https://</code> 默认基于 80 和 443 端口</li>
<li>h2：基于 TLS 协议运行的 HTTP/2 被称为 <code>h2</code></li>
<li>h2c：基于 TCP 协议之上运行的 HTTP/2 被称为 <code>h2c</code></li>
</ul>
<h2>参考资料</h2>
<ul>
<li><a href="https://developers.google.com/web/fundamentals/performance/http2/" target="_blank" rel="noopener noreferrer nofollow">📖 Google developers document: Introduction to HTTP/2</a></li>
<li><a href="https://imququ.com/post/http2-resource.html" target="_blank" rel="noopener noreferrer nofollow">📖 HTTP2 资料汇总</a></li>
<li><a href="https://ye11ow.gitbooks.io/http2-explained/content/" target="_blank" rel="noopener noreferrer nofollow">📝 HTTP2 讲解</a></li>
<li><a href="https://segmentfault.com/a/1190000007219256" target="_blank" rel="noopener noreferrer nofollow">📝 深入研究：HTTP2 的真正性能到底如何</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29609078" target="_blank" rel="noopener noreferrer nofollow">📝 怎样把网站升级到 HTTP/2</a></li>
<li><a href="https://juejin.im/post/5c5ada2e6fb9a049dd80be75" target="_blank" rel="noopener noreferrer nofollow">📝 HTTP/2 常见问题解答</a></li>
<li><a href="https://juejin.im/post/5c6a9f85e51d4503831ad4fa" target="_blank" rel="noopener noreferrer nofollow">📝 从理论到实践，全面理解 HTTP/2</a></li>
<li><a href="https://juejin.im/post/5c4e6d11e51d4534dc477f05" target="_blank" rel="noopener noreferrer nofollow">📝 再谈 HTTP2 性能提升之背后原理</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2018/03/http2_server_push.html" target="_blank" rel="noopener noreferrer nofollow">📝 阮一峰：HTTP/2 服务器推送（Server Push）教程</a></li>
<li><a href="https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin/related?hl=zh-CN" target="_blank" rel="noopener noreferrer nofollow">🛠 HTTP/2 and SPDY indicator</a></li>
</ul>
</article></div></main><script src="/_next/static/chunks/webpack-038c2e688b596d0e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5244,[],\"\"]\n3:I[3866,[],\"\"]\n5:I[6213,[],\"OutletBoundary\"]\n7:I[6213,[],\"MetadataBoundary\"]\n9:I[6213,[],\"ViewportBoundary\"]\nb:I[4835,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/ec0a9d078e716e00.css\",\"style\"]\n:HL[\"/_next/static/css/485ff6fe79292a08.css\",\"style\"]\n:HL[\"/_next/static/css/0ff121a467c0636f.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"ToCgoFiTXvECVEVLCeZww\",\"p\":\"\",\"c\":[\"\",\"front-end\",\"computer-networks\",\"http\",\"http2\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"front-end\",{\"children\":[[\"slug\",\"computer-networks/http/http2\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/ec0a9d078e716e00.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"front-end\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/485ff6fe79292a08.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0ff121a467c0636f.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"main\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[[\"slug\",\"computer-networks/http/http2\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"kV9ChTzMNmcHQHy8Ob86g\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:T5cb7,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eHTTP2\u003c/h1\u003e\n\u003cp\u003eHTTP/2（超文本传输协议第 2 版，最初命名为 HTTP 2.0），简称为 h2（基于 TLS/1.2 或以上版本的加密连接）或 h2c（非加密连接），是 HTTP 协议的的第二个主要版本，使用于万维网。\u003c/p\u003e\n\u003ch2\u003e旧版本问题\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e多个 TCP 连接\u003c/strong\u003e：虽然 HTTP/1.1 管线化可以支持请求并发，但是浏览器很难实现，主流浏览器厂商都禁用了管线化\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e队头阻塞\u003c/strong\u003e：TCP 连接上只能发送一个请求，由于单连接上的串行请求，前面的请求未完成前，后续的请求都在排队等待\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e头部冗余\u003c/strong\u003e：HTTP/1.x 采用文本格式传输，首部未压缩，无状态特性让每个请求都会带上 Cookie、User-Agent 等重复的信息\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e不支持服务端主动推送\u003c/strong\u003e：HTTP/1.1 不支持服务推送消息，只能使用轮询的方式解决\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e新特性\u003c/h2\u003e\n\u003cp\u003e在了解 HTTP/2 新特性前，可以通过 DEMO 直观感受 HTTP/1.1 与 HTTP/2 的差距：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://http2.akamai.com/demo\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003eHTTP/2: the Future of the Internet | Akamai\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e主要新特性：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e传输数据量大量减少\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/front-end/computer-networks/http/#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E5%B8%A7\"\u003e二进制分帧\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/front-end/computer-networks/http/#%E6%A0%87%E5%A4%B4%E5%8E%8B%E7%BC%A9\"\u003e标头压缩\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e多路复用及相关功能\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/front-end/computer-networks/http/#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8\"\u003e多路复用\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e优先级与依赖性\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e服务器消息推送\u003c/strong\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/front-end/computer-networks/http\"\u003e服务器推送\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e其他\n\u003cul\u003e\n\u003cli\u003e重置流\u003c/li\u003e\n\u003cli\u003e流量控制\u003c/li\u003e\n\u003cli\u003eHTTPS RFC 规范并没有要求 HTTP2 强制使用 TLS，但是目前世界所有浏览器和- 服务器实现都基于 HTTPS 来实现 HTTP2\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e二进制分帧\u003c/h3\u003e\n\u003cp\u003e相比于 HTTP/1.x 基于以换行符作为纯文本的分隔符的解析，HTTP/2 将所有的传输信息分割为更小的消息和帧，并对它们采用 \u003cstrong\u003e二进制格式编码\u003c/strong\u003e。基于二进制可以使协议有更多的扩展性，例如，引入帧来传输数据和指令。\u003c/p\u003e\n\u003cp\u003eHTTP/2 所有性能增强的核心在于新的 \u0026lt;strong style=\u0026quot;color:red\u0026quot;\u0026gt;二进制分帧层\u0026lt;/strong\u0026gt;，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e这里所谓的 \u0026lt;strong style=\u0026quot;color:red\u0026quot;\u0026gt;层\u0026lt;/strong\u0026gt;，指的是位于套接字接口与应用可见的高级 HTTP API 之间一个经过优化的新编码机制：HTTP 的语义（包括各种动词、方法、标头）都不受影响，不同的是传输期间对它们的编码方式变了。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch4\u003e数据流、消息和帧\u003c/h4\u003e\n\u003cp\u003e新的二进制分帧机制改变了客户端与服务器之间交换数据的方式。\u003c/p\u003e\n\u003cp\u003e为了说明这个过程，我们需要了解 HTTP/2 的三个概念：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e数据流\u003c/strong\u003e（Stream）：已建立的连接内的 \u0026lt;u\u0026gt;双向字节流\u0026lt;/u\u0026gt;，可以承载一条或多条消息\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e消息\u003c/strong\u003e（Message）：与逻辑请求或响应消息对应的完整的一系列帧\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e帧\u003c/strong\u003e（Frame）：HTTP/2 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这些概念的关系总结如下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e所有通信都在一个 TCP 连接上完成，此连接 \u003cstrong\u003e可以承载任意数量的双向数据流\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e每个数据流都有一个 \u003cstrong\u003e唯一的标识符和可选的优先级信息\u003c/strong\u003e，用于承载双向消息\u003c/li\u003e\n\u003cli\u003e每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧\u003c/li\u003e\n\u003cli\u003e帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载等等。来自不同数据流的帧可以交错发送，然后根据每个帧头的数据流标识符重新组装。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHTTP/2 将 HTTP 协议通信分解为二进制编码帧的交换，这些帧对应着特定数据流中的消息。所有这些都在一个 TCP 连接内复用，这是 HTTP/2 协议所有其他功能和性能优化的基础。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e img \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;../../assets/http2/connection.svg\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e () =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;HTTP 数据流通信连接\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{img}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{640}\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e消息的组成：HEADERS 帧与 DATA 帧\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHEADERS frame 头部帧\u003c/li\u003e\n\u003cli\u003eDATA frame 数据帧\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e img \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;../../assets/http2/binary-framing.png\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e () =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;消息组成\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{img}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{640}\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e更多关于帧定义详解，请查阅 \u003ca href=\"https://halfrost.com/http2-http-frames-definitions/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003eHTTP/2 中的帧定义\u003c/a\u003e\u003c/p\u003e\n\u003ch3\u003e标头压缩\u003c/h3\u003e\n\u003cp\u003e标头压缩（Header compression）：每个 HTTP 传输都承载一组标头，这些标头说明了传输的资源及其属性。 在 HTTP/1.x 中，此元数据始终以纯文本形式，通常会给每个传输增加 500–800 字节的开销。如果使用 HTTP Cookie，增加的开销有时会达到上千字节。\u003c/p\u003e\n\u003cp\u003e为了减少此开销和提升性能，HTTP/2 使用 \u0026lt;strong style=\u0026quot;color:red\u0026quot;\u0026gt;HPACK\u0026lt;/strong\u0026gt; 压缩格式压缩请求和响应标头元数据，这种格式采用两种简单但是强大的技术：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e这种格式支持通过静态霍夫曼代码对传输的标头字段进行编码，从而减小了各个传输的大小。\u003c/li\u003e\n\u003cli\u003e这种格式要求通讯双方 \u003cstrong\u003e各自缓存一份头域索引表\u003c/strong\u003e，相同的消息头只发送 \u003cstrong\u003e索引号\u003c/strong\u003e（换句话说，它可以建立一个共享的压缩上下文），此索引表随后会用作参考，对之前传输的值进行有效编码。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e利用霍夫曼编码（HPACK），可以在传输时对各个值进行压缩，而利用之前传输值的索引列表，我们可以通过传输索引值的方式对重复值进行编码，索引值可用于有效查询和重构完整的标头键值对。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e索引表用法示意\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e img \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;../../assets/http2/headers-compress.jpg\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e () =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;索引表用法示意\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{img}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{520}\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e客户端发了两次请求，第一次请求有完整的 HTTP 报文头部，第二次请求的时候只有一个 \u003ccode\u003epath\u003c/code\u003e 的字段不一样，但是这次报文头它只需要发送一个 \u003ccode\u003epath\u003c/code\u003e 的字段就好了，这样就大大减少了发送的量。这个的实现要求客户端和服务同时维护一个报文头表。\u003c/p\u003e\n\u003ch4\u003eHPACK 霍夫曼编码\u003c/h4\u003e\n\u003cp\u003eHPACK 压缩示意：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e img \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;../../assets/http2/hpack-header-compression.png\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e () =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;HPACK压缩示意\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{img}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{640}\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e作为一种进一步优化方式，HPACK 压缩上下文包含一个静态字典和一个动态字典：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://httpwg.org/specs/rfc7541.html#static.table.definition\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e静态字典\u003c/a\u003e 在规范中定义，并提供了一个包含所有连接都可能使用的常用 HTTP 标头字段（例如，有效标头名称）的列表\u003c/li\u003e\n\u003cli\u003e动态字典最初为空，将根据在特定连接内交换的值进行更新\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e因此，为之前未见过的值采用静态 Huffman 编码，并替换每一侧静态表或动态表中已存在值的索引，可以减小每个请求的大小。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e注意\u003c/strong\u003e：在 HTTP/2 中，请求和响应标头字段的定义保持不变，仅有一些微小的差异：所有标头字段名称均为小写，请求行现在拆分成各个 \u003ccode\u003e:method\u003c/code\u003e、\u003ccode\u003e:scheme\u003c/code\u003e、\u003ccode\u003e:authority\u003c/code\u003e 和 \u003ccode\u003e:path\u003c/code\u003e 伪标头字段。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003e关于 \u003ca href=\"https://tools.ietf.org/html/rfc7541\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003eHPACK 头部压缩标准\u003c/a\u003e 的制定\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://httpwg.org/specs/rfc7541.html\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003eHPACK：Header Compression for HTTP/2\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e多路复用\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e多路复用（MultiPlexing）\u003c/strong\u003e：通过该功能，在一条连接上，您的浏览器可以同时发起无数个请求，并且响应可以同时响应。另外，多路复用中支持了流的优先级（Stream dependencies）设置，允许客户端告知服务器最优资源，可以优先传输。\u003c/p\u003e\n\u003cp\u003e当我们打开网站时，浏览器会对每个网页并发的连接进行限制，一般浏览器的 HTTP 请求并发数限制在 6-8 个。但实际上，绝大部分网站首页所需要的资源个数远大于这个限制。所以为了不让资源在下载阶段就被阻塞住，我们往往会把一些静态资源分散到 CDN 或其他服务器上，从而通过多域名的方式突破浏览器对并发连接数的限制，从而使得网站能同时下载尽可能多的资源。\u003c/p\u003e\n\u003cp\u003e但建立更多的连接也意味更多的开销。每个 HTTP 请求都对应建立 TCP 连接，也许有些资源体积只有几 kb，这些情况下建立连接本身的开销就变得更客观，很可能三次握手的实践比传输时间还长\u003c/p\u003e\n\u003cp\u003e在 HTTP/2 中，有了二进制分帧之后，HTTP/2 不再依赖 TCP 链接去实现多流并行，而是通过 \u0026lt;strong style=\u0026quot;color:red\u0026quot;\u0026gt;流\u0026lt;/strong\u0026gt; 支持多路复用。\u003c/p\u003e\n\u003cp\u003e将 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装是 HTTP/2 最重要的一项增强。事实上，这个机制会在整个网络技术栈中引发一系列连锁反应，从而带来巨大的性能提升，让我们可以：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e并行交错地发送多个请求/响应，请求/响应之间互不影响\u003c/li\u003e\n\u003cli\u003e不必再为绕过 HTTP/1.x 限制而做很多工作（请参阅 \u003ca href=\"https://hpbn.co/optimizing-application-delivery/#optimizing-for-http1x\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e针对 HTTP/1.x 进行优化\u003c/a\u003e，例如级联文件、Image Sprites 和域名分片\u003c/li\u003e\n\u003cli\u003e消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时间\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eHTTP/2 中的新二进制分帧层解决了 HTTP/1.x 中存在的 \u003cstrong\u003e队头阻塞\u003c/strong\u003e 问题，也消除了并行处理和发送请求及响应时对多个连接的依赖。\u003c/p\u003e\n\u003ch3\u003e服务器推送\u003c/h3\u003e\n\u003cp\u003e服务端推送（Server push）：同 SPDY 一样，HTTP/2 也具有客户端推送功能。目前，大多数网站已经启用 HTTP/2，如淘宝。使用服务器推动，可以提前将资源推送至浏览器缓存。\u003c/p\u003e\n\u003cp\u003eHTTP/2 中的 Server Push 并不是指类似于现在的 Server Sent Event（SSE） 或者 WebSocket 的推送技术。\u003cstrong\u003e它是一种服务器根据客户端以前发送的请求来猜测未来的请求，并提前将未来请求的结果推送给客户端的技术\u003c/strong\u003e。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e img \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;../../assets/http2/server-push.png\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e () =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;服务器推送\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{img}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{640}\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e为什么在浏览器中需要一种此类机制呢？\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e一个典型的网络应用包含多种资源，客户端需要检查服务器提供的文档才能逐个找到它们。 那为什么不让服务器提前推送这些资源，从而减少额外的延迟时间呢？ 服务器已经知道客户端下一步要请求什么资源，这时候服务器推送即可派上用场。\u003c/p\u003e\n\u003cp\u003e事实上，如果您在网页中内联过 CSS、JavaScript，或者通过数据 URI 内联过其他资产（请参阅 \u003ca href=\"https://hpbn.co/http1x/#resource-inlining\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e资源内联\u003c/a\u003e），那么您就已经亲身体验过服务器推送了。 对于将资源手动内联到文档中的过程，我们实际上是在将资源推送给客户端，而不是等待客户端请求。 使用 HTTP/2，我们不仅可以实现相同结果，还会获得其他性能优势。\u003c/p\u003e\n\u003cp\u003e推送资源可以进行以下处理：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e由客户端缓存\u003c/li\u003e\n\u003cli\u003e在不同页面之间重用\u003c/li\u003e\n\u003cli\u003e与其他资源一起复用\u003c/li\u003e\n\u003cli\u003e由服务器设定优先级\u003c/li\u003e\n\u003cli\u003e被客户端拒绝\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch4\u003eNginx 配置实现\u003c/h4\u003e\n\u003cp\u003e通过 Nginx 配置能主动推送两个 HTML 文档中需要请求的文件：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-nginx\"\u003e\u003cspan class=\"hljs-section\"\u003eserver\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e# 设定开启使用 HTTP2\u003c/span\u003e\n    \u003cspan class=\"hljs-attribute\"\u003elisten\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e443\u003c/span\u003e ssl http2;\n    \u003cspan class=\"hljs-attribute\"\u003eserver_name\u003c/span\u003e  localhost;\n\n    \u003cspan class=\"hljs-attribute\"\u003essl\u003c/span\u003e                      \u003cspan class=\"hljs-literal\"\u003eon\u003c/span\u003e;\n    \u003cspan class=\"hljs-attribute\"\u003essl_certificate\u003c/span\u003e          /etc/nginx/certs/example.crt;\n    \u003cspan class=\"hljs-attribute\"\u003essl_certificate_key\u003c/span\u003e      /etc/nginx/certs/example.key;\n\n    \u003cspan class=\"hljs-attribute\"\u003essl_session_timeout\u003c/span\u003e  \u003cspan class=\"hljs-number\"\u003e5m\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-attribute\"\u003essl_ciphers\u003c/span\u003e HIGH:!aNULL:!MD5;\n    \u003cspan class=\"hljs-attribute\"\u003essl_protocols\u003c/span\u003e SSLv3 TLSv1 TLSv1.\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e TLSv1.\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n    \u003cspan class=\"hljs-attribute\"\u003essl_prefer_server_ciphers\u003c/span\u003e   \u003cspan class=\"hljs-literal\"\u003eon\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-section\"\u003elocation\u003c/span\u003e / {\n      \u003cspan class=\"hljs-attribute\"\u003eroot\u003c/span\u003e   /usr/share/nginx/html;\n      \u003cspan class=\"hljs-attribute\"\u003eindex\u003c/span\u003e  index.html index.htm;\n\n      \u003cspan class=\"hljs-comment\"\u003e# 服务器主动推送这两个文件\u003c/span\u003e\n      \u003cspan class=\"hljs-attribute\"\u003ehttp2_push\u003c/span\u003e /style.css;\n      \u003cspan class=\"hljs-attribute\"\u003ehttp2_push\u003c/span\u003e /example.png;\n    }\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这种方式需要写在服务器配置中，每次修改都要重启服务，而且应用与服务器的配置不应该混在一起。\u003c/p\u003e\n\u003ch4\u003e服务端实现\u003c/h4\u003e\n\u003cp\u003e服务器推送还有另一个实现方法，就是后端应用产生 HTTP 响应头信息 \u003ccode\u003eLink\u003c/code\u003e 命令。服务器发现有这个头信息，就会进行服务器推送。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-http\"\u003e\u003cspan class=\"hljs-attribute\"\u003eLink\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003e\u0026lt;/styles.css\u0026gt;; rel=preload; as=style\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果要推送多个资源：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-http\"\u003e\u003cspan class=\"hljs-attribute\"\u003eLink\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003e\u0026lt;/styles.css\u0026gt;; rel=preload; as=style, \u0026lt;/example.png\u0026gt;; rel=preload; as=image\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这时，Nginx 的配置改成下面这样。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-nginx\"\u003e\u003cspan class=\"hljs-section\"\u003eserver\u003c/span\u003e {\n    \u003cspan class=\"hljs-attribute\"\u003elisten\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e443\u003c/span\u003e ssl http2;\n\n    \u003cspan class=\"hljs-comment\"\u003e# ...\u003c/span\u003e\n\n    \u003cspan class=\"hljs-attribute\"\u003eroot\u003c/span\u003e /var/www/html;\n\n    \u003cspan class=\"hljs-section\"\u003elocation\u003c/span\u003e = / {\n        \u003cspan class=\"hljs-attribute\"\u003eproxy_pass\u003c/span\u003e http://upstream;\n        \u003cspan class=\"hljs-attribute\"\u003ehttp2_push_preload\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003eon\u003c/span\u003e;\n    }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果服务器或者浏览器不支持 HTTP2，那么浏览器就会按照 \u003ccode\u003epreload\u003c/code\u003e 来处理这个头信息，预加载指定的资源文件。\u003c/p\u003e\n\u003cp\u003e事实上，这个头信息就是 \u003ccode\u003epreload\u003c/code\u003e 标准提出的，它的语法和 \u003ccode\u003eas\u003c/code\u003e 属性的值都写在了 \u003ca href=\"https://w3c.github.io/preload/#as-attribute\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e标准\u003c/a\u003e 里面。\u003c/p\u003e\n\u003cp\u003e参考 \u003ca href=\"https://blog.risingstack.com/node-js-http-2-push/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003eHTTP/2 Server Push with Node.js\u003c/a\u003e 实现。\u003c/p\u003e\n\u003ch4\u003e缓存问题\u003c/h4\u003e\n\u003cp\u003e服务器推送有一个很麻烦的问题。所要推送的资源文件，如果浏览器已经有缓存，推送就是浪费带宽。即使推送的文件版本更新，浏览器也会优先使用本地缓存。\u003c/p\u003e\n\u003cp\u003e一种解决办法是，只对第一次访问的用户开启服务器推送。下面是 Nginx 官方给出的示例，根据 Cookie 判断是否为第一次访问。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-nginx\"\u003e\u003cspan class=\"hljs-section\"\u003eserver\u003c/span\u003e {\n    \u003cspan class=\"hljs-attribute\"\u003elisten\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e443\u003c/span\u003e ssl http2 default_server;\n\n    \u003cspan class=\"hljs-attribute\"\u003essl_certificate\u003c/span\u003e ssl/certificate.pem;\n    \u003cspan class=\"hljs-attribute\"\u003essl_certificate_key\u003c/span\u003e ssl/key.pem;\n\n    \u003cspan class=\"hljs-attribute\"\u003eroot\u003c/span\u003e /var/www/html;\n    \u003cspan class=\"hljs-attribute\"\u003ehttp2_push_preload\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003eon\u003c/span\u003e;\n\n    \u003cspan class=\"hljs-section\"\u003elocation\u003c/span\u003e = /demo.html {\n        \u003cspan class=\"hljs-attribute\"\u003eadd_header\u003c/span\u003e Set-Cookie \u003cspan class=\"hljs-string\"\u003e\u0026quot;session=1\u0026quot;\u003c/span\u003e;\n        \u003cspan class=\"hljs-attribute\"\u003eadd_header\u003c/span\u003e Link \u003cspan class=\"hljs-variable\"\u003e$resources\u003c/span\u003e;\n    }\n}\n\n\n\u003cspan class=\"hljs-attribute\"\u003emap\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003e$http_cookie\u003c/span\u003e \u003cspan class=\"hljs-variable\"\u003e$resources\u003c/span\u003e {\n    \u0026quot;~*session=1\u0026quot; \u0026quot;\u0026quot;;\n    \u003cspan class=\"hljs-attribute\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026lt;/style.css\u0026gt;; as=style; rel=preload\u0026quot;\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e安全提升\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eHTTP/2 是不是必须基于 TLS/SSL 协议？\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cul\u003e\n\u003cli\u003eIETF 标准不要求必须基于 TLS/SSL 协议 📌\u003c/li\u003e\n\u003cli\u003e浏览器要求必须基于 TLS/SSL 协议 📌\u003c/li\u003e\n\u003cli\u003e在 TLS 层 ALPN（Application Layer Protocol Negotiation）扩展做协商，只认 HTTP/1.x 的代理服务器不会干扰 HTTP/2\u003c/li\u003e\n\u003cli\u003esheme：\u003ccode\u003ehttp://\u003c/code\u003e 和 \u003ccode\u003ehttps://\u003c/code\u003e 默认基于 80 和 443 端口\u003c/li\u003e\n\u003cli\u003eh2：基于 TLS 协议运行的 HTTP/2 被称为 \u003ccode\u003eh2\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003eh2c：基于 TCP 协议之上运行的 HTTP/2 被称为 \u003ccode\u003eh2c\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e参考资料\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://developers.google.com/web/fundamentals/performance/http2/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📖 Google developers document: Introduction to HTTP/2\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://imququ.com/post/http2-resource.html\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📖 HTTP2 资料汇总\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://ye11ow.gitbooks.io/http2-explained/content/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 HTTP2 讲解\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://segmentfault.com/a/1190000007219256\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 深入研究：HTTP2 的真正性能到底如何\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/29609078\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 怎样把网站升级到 HTTP/2\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.im/post/5c5ada2e6fb9a049dd80be75\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 HTTP/2 常见问题解答\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.im/post/5c6a9f85e51d4503831ad4fa\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 从理论到实践，全面理解 HTTP/2\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.im/post/5c4e6d11e51d4534dc477f05\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 再谈 HTTP2 性能提升之背后原理\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.ruanyifeng.com/blog/2018/03/http2_server_push.html\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 阮一峰：HTTP/2 服务器推送（Server Push）教程\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin/related?hl=zh-CN\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e🛠 HTTP/2 and SPDY indicator\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"markdown-body\",\"children\":[[\"$\",\"h1\",null,{\"children\":\"HTTP2\"}],[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"front-end\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"front-end knowledge\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>