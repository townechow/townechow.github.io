1:"$Sreact.fragment"
2:I[5244,[],""]
3:I[3866,[],""]
5:I[6213,[],"OutletBoundary"]
7:I[6213,[],"MetadataBoundary"]
9:I[6213,[],"ViewportBoundary"]
b:I[4835,[],""]
:HL["/_next/static/media/569ce4b8f30dc480-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/ec0a9d078e716e00.css","style"]
:HL["/_next/static/css/485ff6fe79292a08.css","style"]
:HL["/_next/static/css/0ff121a467c0636f.css","style"]
0:{"P":null,"b":"NW9bMA21iAaih0TqCHqj1","p":"","c":["","front-end","computer-networks","http","http2"],"i":false,"f":[[["",{"children":["front-end",{"children":[["slug","computer-networks/http/http2","oc"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/ec0a9d078e716e00.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__variable_4d318d __variable_ea5f4b antialiased","children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[],[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]]}],{"children":["front-end",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/485ff6fe79292a08.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/0ff121a467c0636f.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","main",null,{"children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","front-end","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]}]]}],{"children":[["slug","computer-networks/http/http2","oc"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","front-end","children","$0:f:0:1:2:children:2:children:0","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L4",null,["$","$L5",null,{"children":"$L6"}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","NZq2dYHuN-Y5ru69HFN6q",{"children":[["$","$L7",null,{"children":"$L8"}],["$","$L9",null,{"children":"$La"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}]]}],false]],"m":"$undefined","G":["$b","$undefined"],"s":false,"S":true}
c:T5cb7,<h1>HTTP2</h1>
<p>HTTP/2（超文本传输协议第 2 版，最初命名为 HTTP 2.0），简称为 h2（基于 TLS/1.2 或以上版本的加密连接）或 h2c（非加密连接），是 HTTP 协议的的第二个主要版本，使用于万维网。</p>
<h2>旧版本问题</h2>
<ol>
<li><strong>多个 TCP 连接</strong>：虽然 HTTP/1.1 管线化可以支持请求并发，但是浏览器很难实现，主流浏览器厂商都禁用了管线化</li>
<li><strong>队头阻塞</strong>：TCP 连接上只能发送一个请求，由于单连接上的串行请求，前面的请求未完成前，后续的请求都在排队等待</li>
<li><strong>头部冗余</strong>：HTTP/1.x 采用文本格式传输，首部未压缩，无状态特性让每个请求都会带上 Cookie、User-Agent 等重复的信息</li>
<li><strong>不支持服务端主动推送</strong>：HTTP/1.1 不支持服务推送消息，只能使用轮询的方式解决</li>
</ol>
<h2>新特性</h2>
<p>在了解 HTTP/2 新特性前，可以通过 DEMO 直观感受 HTTP/1.1 与 HTTP/2 的差距：</p>
<p><a href="https://http2.akamai.com/demo" target="_blank" rel="noopener noreferrer nofollow">HTTP/2: the Future of the Internet | Akamai</a></p>
<p>主要新特性：</p>
<ul>
<li><strong>传输数据量大量减少</strong>
<ul>
<li><a href="/front-end/computer-networks/http/#%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%88%86%E5%B8%A7">二进制分帧</a></li>
<li><a href="/front-end/computer-networks/http/#%E6%A0%87%E5%A4%B4%E5%8E%8B%E7%BC%A9">标头压缩</a></li>
</ul>
</li>
<li><strong>多路复用及相关功能</strong>
<ul>
<li><a href="/front-end/computer-networks/http/#%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">多路复用</a></li>
<li>优先级与依赖性</li>
</ul>
</li>
<li><strong>服务器消息推送</strong>
<ul>
<li><a href="/front-end/computer-networks/http">服务器推送</a></li>
</ul>
</li>
<li>其他
<ul>
<li>重置流</li>
<li>流量控制</li>
<li>HTTPS RFC 规范并没有要求 HTTP2 强制使用 TLS，但是目前世界所有浏览器和- 服务器实现都基于 HTTPS 来实现 HTTP2</li>
</ul>
</li>
</ul>
<h3>二进制分帧</h3>
<p>相比于 HTTP/1.x 基于以换行符作为纯文本的分隔符的解析，HTTP/2 将所有的传输信息分割为更小的消息和帧，并对它们采用 <strong>二进制格式编码</strong>。基于二进制可以使协议有更多的扩展性，例如，引入帧来传输数据和指令。</p>
<p>HTTP/2 所有性能增强的核心在于新的 &lt;strong style=&quot;color:red&quot;&gt;二进制分帧层&lt;/strong&gt;，它定义了如何封装 HTTP 消息并在客户端与服务器之间传输。</p>
<blockquote>
<p>这里所谓的 &lt;strong style=&quot;color:red&quot;&gt;层&lt;/strong&gt;，指的是位于套接字接口与应用可见的高级 HTTP API 之间一个经过优化的新编码机制：HTTP 的语义（包括各种动词、方法、标头）都不受影响，不同的是传输期间对它们的编码方式变了。</p>
</blockquote>
<h4>数据流、消息和帧</h4>
<p>新的二进制分帧机制改变了客户端与服务器之间交换数据的方式。</p>
<p>为了说明这个过程，我们需要了解 HTTP/2 的三个概念：</p>
<ul>
<li><strong>数据流</strong>（Stream）：已建立的连接内的 &lt;u&gt;双向字节流&lt;/u&gt;，可以承载一条或多条消息</li>
<li><strong>消息</strong>（Message）：与逻辑请求或响应消息对应的完整的一系列帧</li>
<li><strong>帧</strong>（Frame）：HTTP/2 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流</li>
</ul>
<p>这些概念的关系总结如下：</p>
<ul>
<li>所有通信都在一个 TCP 连接上完成，此连接 <strong>可以承载任意数量的双向数据流</strong></li>
<li>每个数据流都有一个 <strong>唯一的标识符和可选的优先级信息</strong>，用于承载双向消息</li>
<li>每条消息都是一条逻辑 HTTP 消息（例如请求或响应），包含一个或多个帧</li>
<li>帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载等等。来自不同数据流的帧可以交错发送，然后根据每个帧头的数据流标识符重新组装。</li>
</ul>
<p>HTTP/2 将 HTTP 协议通信分解为二进制编码帧的交换，这些帧对应着特定数据流中的消息。所有这些都在一个 TCP 连接内复用，这是 HTTP/2 协议所有其他功能和性能优化的基础。</p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/http2/connection.svg&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;HTTP 数据流通信连接&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{640}</span> /&gt;</span></span>;
</code></pre>
<p><strong>消息的组成：HEADERS 帧与 DATA 帧</strong></p>
<ul>
<li>HEADERS frame 头部帧</li>
<li>DATA frame 数据帧</li>
</ul>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/http2/binary-framing.png&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;消息组成&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{640}</span> /&gt;</span></span>;
</code></pre>
<p>更多关于帧定义详解，请查阅 <a href="https://halfrost.com/http2-http-frames-definitions/" target="_blank" rel="noopener noreferrer nofollow">HTTP/2 中的帧定义</a></p>
<h3>标头压缩</h3>
<p>标头压缩（Header compression）：每个 HTTP 传输都承载一组标头，这些标头说明了传输的资源及其属性。 在 HTTP/1.x 中，此元数据始终以纯文本形式，通常会给每个传输增加 500–800 字节的开销。如果使用 HTTP Cookie，增加的开销有时会达到上千字节。</p>
<p>为了减少此开销和提升性能，HTTP/2 使用 &lt;strong style=&quot;color:red&quot;&gt;HPACK&lt;/strong&gt; 压缩格式压缩请求和响应标头元数据，这种格式采用两种简单但是强大的技术：</p>
<ol>
<li>这种格式支持通过静态霍夫曼代码对传输的标头字段进行编码，从而减小了各个传输的大小。</li>
<li>这种格式要求通讯双方 <strong>各自缓存一份头域索引表</strong>，相同的消息头只发送 <strong>索引号</strong>（换句话说，它可以建立一个共享的压缩上下文），此索引表随后会用作参考，对之前传输的值进行有效编码。</li>
</ol>
<p>利用霍夫曼编码（HPACK），可以在传输时对各个值进行压缩，而利用之前传输值的索引列表，我们可以通过传输索引值的方式对重复值进行编码，索引值可用于有效查询和重构完整的标头键值对。</p>
<p><strong>索引表用法示意</strong></p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/http2/headers-compress.jpg&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;索引表用法示意&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{520}</span> /&gt;</span></span>;
</code></pre>
<p>客户端发了两次请求，第一次请求有完整的 HTTP 报文头部，第二次请求的时候只有一个 <code>path</code> 的字段不一样，但是这次报文头它只需要发送一个 <code>path</code> 的字段就好了，这样就大大减少了发送的量。这个的实现要求客户端和服务同时维护一个报文头表。</p>
<h4>HPACK 霍夫曼编码</h4>
<p>HPACK 压缩示意：</p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/http2/hpack-header-compression.png&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;HPACK压缩示意&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{640}</span> /&gt;</span></span>;
</code></pre>
<p>作为一种进一步优化方式，HPACK 压缩上下文包含一个静态字典和一个动态字典：</p>
<ul>
<li><a href="https://httpwg.org/specs/rfc7541.html#static.table.definition" target="_blank" rel="noopener noreferrer nofollow">静态字典</a> 在规范中定义，并提供了一个包含所有连接都可能使用的常用 HTTP 标头字段（例如，有效标头名称）的列表</li>
<li>动态字典最初为空，将根据在特定连接内交换的值进行更新</li>
</ul>
<p>因此，为之前未见过的值采用静态 Huffman 编码，并替换每一侧静态表或动态表中已存在值的索引，可以减小每个请求的大小。</p>
<blockquote>
<p>⚠️ <strong>注意</strong>：在 HTTP/2 中，请求和响应标头字段的定义保持不变，仅有一些微小的差异：所有标头字段名称均为小写，请求行现在拆分成各个 <code>:method</code>、<code>:scheme</code>、<code>:authority</code> 和 <code>:path</code> 伪标头字段。</p>
</blockquote>
<ul>
<li>关于 <a href="https://tools.ietf.org/html/rfc7541" target="_blank" rel="noopener noreferrer nofollow">HPACK 头部压缩标准</a> 的制定</li>
<li><a href="https://httpwg.org/specs/rfc7541.html" target="_blank" rel="noopener noreferrer nofollow">HPACK：Header Compression for HTTP/2</a></li>
</ul>
<h3>多路复用</h3>
<p><strong>多路复用（MultiPlexing）</strong>：通过该功能，在一条连接上，您的浏览器可以同时发起无数个请求，并且响应可以同时响应。另外，多路复用中支持了流的优先级（Stream dependencies）设置，允许客户端告知服务器最优资源，可以优先传输。</p>
<p>当我们打开网站时，浏览器会对每个网页并发的连接进行限制，一般浏览器的 HTTP 请求并发数限制在 6-8 个。但实际上，绝大部分网站首页所需要的资源个数远大于这个限制。所以为了不让资源在下载阶段就被阻塞住，我们往往会把一些静态资源分散到 CDN 或其他服务器上，从而通过多域名的方式突破浏览器对并发连接数的限制，从而使得网站能同时下载尽可能多的资源。</p>
<p>但建立更多的连接也意味更多的开销。每个 HTTP 请求都对应建立 TCP 连接，也许有些资源体积只有几 kb，这些情况下建立连接本身的开销就变得更客观，很可能三次握手的实践比传输时间还长</p>
<p>在 HTTP/2 中，有了二进制分帧之后，HTTP/2 不再依赖 TCP 链接去实现多流并行，而是通过 &lt;strong style=&quot;color:red&quot;&gt;流&lt;/strong&gt; 支持多路复用。</p>
<p>将 HTTP 消息分解为独立的帧，交错发送，然后在另一端重新组装是 HTTP/2 最重要的一项增强。事实上，这个机制会在整个网络技术栈中引发一系列连锁反应，从而带来巨大的性能提升，让我们可以：</p>
<ul>
<li>并行交错地发送多个请求/响应，请求/响应之间互不影响</li>
<li>不必再为绕过 HTTP/1.x 限制而做很多工作（请参阅 <a href="https://hpbn.co/optimizing-application-delivery/#optimizing-for-http1x" target="_blank" rel="noopener noreferrer nofollow">针对 HTTP/1.x 进行优化</a>，例如级联文件、Image Sprites 和域名分片</li>
<li>消除不必要的延迟和提高现有网络容量的利用率，从而减少页面加载时间</li>
</ul>
<p>HTTP/2 中的新二进制分帧层解决了 HTTP/1.x 中存在的 <strong>队头阻塞</strong> 问题，也消除了并行处理和发送请求及响应时对多个连接的依赖。</p>
<h3>服务器推送</h3>
<p>服务端推送（Server push）：同 SPDY 一样，HTTP/2 也具有客户端推送功能。目前，大多数网站已经启用 HTTP/2，如淘宝。使用服务器推动，可以提前将资源推送至浏览器缓存。</p>
<p>HTTP/2 中的 Server Push 并不是指类似于现在的 Server Sent Event（SSE） 或者 WebSocket 的推送技术。<strong>它是一种服务器根据客户端以前发送的请求来猜测未来的请求，并提前将未来请求的结果推送给客户端的技术</strong>。</p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/http2/server-push.png&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;服务器推送&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{640}</span> /&gt;</span></span>;
</code></pre>
<blockquote>
<p>为什么在浏览器中需要一种此类机制呢？</p>
</blockquote>
<p>一个典型的网络应用包含多种资源，客户端需要检查服务器提供的文档才能逐个找到它们。 那为什么不让服务器提前推送这些资源，从而减少额外的延迟时间呢？ 服务器已经知道客户端下一步要请求什么资源，这时候服务器推送即可派上用场。</p>
<p>事实上，如果您在网页中内联过 CSS、JavaScript，或者通过数据 URI 内联过其他资产（请参阅 <a href="https://hpbn.co/http1x/#resource-inlining" target="_blank" rel="noopener noreferrer nofollow">资源内联</a>），那么您就已经亲身体验过服务器推送了。 对于将资源手动内联到文档中的过程，我们实际上是在将资源推送给客户端，而不是等待客户端请求。 使用 HTTP/2，我们不仅可以实现相同结果，还会获得其他性能优势。</p>
<p>推送资源可以进行以下处理：</p>
<ul>
<li>由客户端缓存</li>
<li>在不同页面之间重用</li>
<li>与其他资源一起复用</li>
<li>由服务器设定优先级</li>
<li>被客户端拒绝</li>
</ul>
<h4>Nginx 配置实现</h4>
<p>通过 Nginx 配置能主动推送两个 HTML 文档中需要请求的文件：</p>
<pre class="hljs"><code class="language-nginx"><span class="hljs-section">server</span> {
    <span class="hljs-comment"># 设定开启使用 HTTP2</span>
    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl http2;
    <span class="hljs-attribute">server_name</span>  localhost;

    <span class="hljs-attribute">ssl</span>                      <span class="hljs-literal">on</span>;
    <span class="hljs-attribute">ssl_certificate</span>          /etc/nginx/certs/example.crt;
    <span class="hljs-attribute">ssl_certificate_key</span>      /etc/nginx/certs/example.key;

    <span class="hljs-attribute">ssl_session_timeout</span>  <span class="hljs-number">5m</span>;

    <span class="hljs-attribute">ssl_ciphers</span> HIGH:!aNULL:!MD5;
    <span class="hljs-attribute">ssl_protocols</span> SSLv3 TLSv1 TLSv1.<span class="hljs-number">1</span> TLSv1.<span class="hljs-number">2</span>;
    <span class="hljs-attribute">ssl_prefer_server_ciphers</span>   <span class="hljs-literal">on</span>;

    <span class="hljs-section">location</span> / {
      <span class="hljs-attribute">root</span>   /usr/share/nginx/html;
      <span class="hljs-attribute">index</span>  index.html index.htm;

      <span class="hljs-comment"># 服务器主动推送这两个文件</span>
      <span class="hljs-attribute">http2_push</span> /style.css;
      <span class="hljs-attribute">http2_push</span> /example.png;
    }
</code></pre>
<p>这种方式需要写在服务器配置中，每次修改都要重启服务，而且应用与服务器的配置不应该混在一起。</p>
<h4>服务端实现</h4>
<p>服务器推送还有另一个实现方法，就是后端应用产生 HTTP 响应头信息 <code>Link</code> 命令。服务器发现有这个头信息，就会进行服务器推送。</p>
<pre class="hljs"><code class="language-http"><span class="hljs-attribute">Link</span><span class="hljs-punctuation">: </span>&lt;/styles.css&gt;; rel=preload; as=style
</code></pre>
<p>如果要推送多个资源：</p>
<pre class="hljs"><code class="language-http"><span class="hljs-attribute">Link</span><span class="hljs-punctuation">: </span>&lt;/styles.css&gt;; rel=preload; as=style, &lt;/example.png&gt;; rel=preload; as=image
</code></pre>
<p>这时，Nginx 的配置改成下面这样。</p>
<pre class="hljs"><code class="language-nginx"><span class="hljs-section">server</span> {
    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl http2;

    <span class="hljs-comment"># ...</span>

    <span class="hljs-attribute">root</span> /var/www/html;

    <span class="hljs-section">location</span> = / {
        <span class="hljs-attribute">proxy_pass</span> http://upstream;
        <span class="hljs-attribute">http2_push_preload</span> <span class="hljs-literal">on</span>;
    }
}
</code></pre>
<p>如果服务器或者浏览器不支持 HTTP2，那么浏览器就会按照 <code>preload</code> 来处理这个头信息，预加载指定的资源文件。</p>
<p>事实上，这个头信息就是 <code>preload</code> 标准提出的，它的语法和 <code>as</code> 属性的值都写在了 <a href="https://w3c.github.io/preload/#as-attribute" target="_blank" rel="noopener noreferrer nofollow">标准</a> 里面。</p>
<p>参考 <a href="https://blog.risingstack.com/node-js-http-2-push/" target="_blank" rel="noopener noreferrer nofollow">HTTP/2 Server Push with Node.js</a> 实现。</p>
<h4>缓存问题</h4>
<p>服务器推送有一个很麻烦的问题。所要推送的资源文件，如果浏览器已经有缓存，推送就是浪费带宽。即使推送的文件版本更新，浏览器也会优先使用本地缓存。</p>
<p>一种解决办法是，只对第一次访问的用户开启服务器推送。下面是 Nginx 官方给出的示例，根据 Cookie 判断是否为第一次访问。</p>
<pre class="hljs"><code class="language-nginx"><span class="hljs-section">server</span> {
    <span class="hljs-attribute">listen</span> <span class="hljs-number">443</span> ssl http2 default_server;

    <span class="hljs-attribute">ssl_certificate</span> ssl/certificate.pem;
    <span class="hljs-attribute">ssl_certificate_key</span> ssl/key.pem;

    <span class="hljs-attribute">root</span> /var/www/html;
    <span class="hljs-attribute">http2_push_preload</span> <span class="hljs-literal">on</span>;

    <span class="hljs-section">location</span> = /demo.html {
        <span class="hljs-attribute">add_header</span> Set-Cookie <span class="hljs-string">&quot;session=1&quot;</span>;
        <span class="hljs-attribute">add_header</span> Link <span class="hljs-variable">$resources</span>;
    }
}


<span class="hljs-attribute">map</span> <span class="hljs-variable">$http_cookie</span> <span class="hljs-variable">$resources</span> {
    &quot;~*session=1&quot; &quot;&quot;;
    <span class="hljs-attribute">default</span> <span class="hljs-string">&quot;&lt;/style.css&gt;; as=style; rel=preload&quot;</span>;
}
</code></pre>
<h3>安全提升</h3>
<blockquote>
<p>HTTP/2 是不是必须基于 TLS/SSL 协议？</p>
</blockquote>
<ul>
<li>IETF 标准不要求必须基于 TLS/SSL 协议 📌</li>
<li>浏览器要求必须基于 TLS/SSL 协议 📌</li>
<li>在 TLS 层 ALPN（Application Layer Protocol Negotiation）扩展做协商，只认 HTTP/1.x 的代理服务器不会干扰 HTTP/2</li>
<li>sheme：<code>http://</code> 和 <code>https://</code> 默认基于 80 和 443 端口</li>
<li>h2：基于 TLS 协议运行的 HTTP/2 被称为 <code>h2</code></li>
<li>h2c：基于 TCP 协议之上运行的 HTTP/2 被称为 <code>h2c</code></li>
</ul>
<h2>参考资料</h2>
<ul>
<li><a href="https://developers.google.com/web/fundamentals/performance/http2/" target="_blank" rel="noopener noreferrer nofollow">📖 Google developers document: Introduction to HTTP/2</a></li>
<li><a href="https://imququ.com/post/http2-resource.html" target="_blank" rel="noopener noreferrer nofollow">📖 HTTP2 资料汇总</a></li>
<li><a href="https://ye11ow.gitbooks.io/http2-explained/content/" target="_blank" rel="noopener noreferrer nofollow">📝 HTTP2 讲解</a></li>
<li><a href="https://segmentfault.com/a/1190000007219256" target="_blank" rel="noopener noreferrer nofollow">📝 深入研究：HTTP2 的真正性能到底如何</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29609078" target="_blank" rel="noopener noreferrer nofollow">📝 怎样把网站升级到 HTTP/2</a></li>
<li><a href="https://juejin.im/post/5c5ada2e6fb9a049dd80be75" target="_blank" rel="noopener noreferrer nofollow">📝 HTTP/2 常见问题解答</a></li>
<li><a href="https://juejin.im/post/5c6a9f85e51d4503831ad4fa" target="_blank" rel="noopener noreferrer nofollow">📝 从理论到实践，全面理解 HTTP/2</a></li>
<li><a href="https://juejin.im/post/5c4e6d11e51d4534dc477f05" target="_blank" rel="noopener noreferrer nofollow">📝 再谈 HTTP2 性能提升之背后原理</a></li>
<li><a href="https://www.ruanyifeng.com/blog/2018/03/http2_server_push.html" target="_blank" rel="noopener noreferrer nofollow">📝 阮一峰：HTTP/2 服务器推送（Server Push）教程</a></li>
<li><a href="https://chrome.google.com/webstore/detail/http2-and-spdy-indicator/mpbpobfflnpcgagjijhmgnchggcjblin/related?hl=zh-CN" target="_blank" rel="noopener noreferrer nofollow">🛠 HTTP/2 and SPDY indicator</a></li>
</ul>
4:["$","div",null,{"className":"markdown-body","children":["$","article",null,{"dangerouslySetInnerHTML":{"__html":"$c"}}]}]
a:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
8:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"front-end"}],["$","meta","2",{"name":"description","content":"front-end knowledge"}],["$","link","3",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
6:null
