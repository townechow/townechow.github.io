<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/ec0a9d078e716e00.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/485ff6fe79292a08.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/0ff121a467c0636f.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-53834dba86d90934.js"/><script src="/_next/static/chunks/4bd1b696-20882bf820444624.js" async=""></script><script src="/_next/static/chunks/517-98ed787e5f259f2c.js" async=""></script><script src="/_next/static/chunks/main-app-f33d3e3aed85e21f.js" async=""></script><meta name="next-size-adjust" content=""/><title>front-end</title><meta name="description" content="front-end knowledge"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><main><div class="markdown-body"><article><h1>HTTP 报文格式</h1>
<p>对于 TCP 而言，在传输的时候分为两个部分：TCP 头和数据部分。</p>
<p>而 HTTP 报文是面向文本的，报文中的每个字段都是一些 ASCII 码串，各个字段的长度是不确定的。HTTP 有两类报文：<strong>请求报文</strong> 和 <strong>响应报文</strong>。</p>
<p>HTTP 请求/响应报文由以下内容组成：</p>
<ul>
<li>请求头</li>
<li>HTTP 头部字段</li>
<li>空行</li>
<li>可选的 HTTP 报文主体数据</li>
</ul>
<h2>请求报文</h2>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/http/http-request-structure.png&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;HTTP 请求报文结构&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{480}</span> /&gt;</span></span>;
</code></pre>
<p>HTTP 的请求报文分为三个部分：</p>
<ul>
<li>请求行
<ul>
<li>请求方法</li>
<li>请求地址 URL</li>
<li>HTTP 协议版本</li>
</ul>
</li>
<li>首部行
<ul>
<li>Content-Type</li>
</ul>
</li>
<li>空行</li>
<li>实体主体</li>
</ul>
<h3>请求行</h3>
<p>请求行是请求消息的第一行，由三部分组成：</p>
<ul>
<li>请求方法（GET / POST / DELETE / PUT / HEAD）</li>
<li>请求资源的 URI 路径</li>
<li>HTTP 的版本号</li>
</ul>
<p>🌰 <strong>示例：</strong></p>
<pre class="hljs"><code class="language-http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/index.html</span> <span class="hljs-meta">HTTP/1.1</span>
</code></pre>
<h4>请求方法</h4>
<p>HTTP/1.1 协议中共定义了八种方法，以不同的方式操作指定的资源。</p>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">GET</td>
<td style="text-align:left">向指定的资源发出 <strong>显示</strong> 请求，使用 GET 方法应该只用在 <strong>读取数据</strong> 上，而不应该用于产生 <strong>副作用</strong> 的操作中。</td>
</tr>
<tr>
<td style="text-align:left">POST</td>
<td style="text-align:left">指定资源 <strong>提交数据</strong>，请求服务器进行处理（例如提交表单或者上传文件）。<strong>数据被包含在请求文本中</strong>。这个请求可能会创建新的资源或者修改现有资源，或两者皆有。</td>
</tr>
<tr>
<td style="text-align:left">PUT</td>
<td style="text-align:left">向指定资源位置上传其 <strong>最新内容</strong>。</td>
</tr>
<tr>
<td style="text-align:left">DELETE</td>
<td style="text-align:left">请求服务器删除 Request-URI 所标识的资源。</td>
</tr>
<tr>
<td style="text-align:left">OPTIONS</td>
<td style="text-align:left">使服务器传回该 <strong>资源支持的所有 HTTP 请求方法</strong>。用 <code>*</code> 来代替资源名称，向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作。</td>
</tr>
<tr>
<td style="text-align:left">HEAD</td>
<td style="text-align:left">与 GET 方法一样，都是向服务器发出指定资源的请求，只不过服务器将 <strong>不传回资源的本文部分</strong>，它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中 <code>关于该资源的信息</code>（原信息或称元数据）。</td>
</tr>
<tr>
<td style="text-align:left">TRACE</td>
<td style="text-align:left">显示服务器收到的请求，主要用于测试或诊断。</td>
</tr>
<tr>
<td style="text-align:left">CONNECT</td>
<td style="text-align:left">HTTP/1.1 中预留给能够将连接改为通道方式的代理服务器。通常用于 SSL 加密服务器的链接（经由非加密的 HTTP 代理服务器）。</td>
</tr>
</tbody>
</table>
<p>其中，最常见的是 GET 和 POST 方法，如果是 RESful API 接口规范的话一般会用到 POST、DELETE、GET、PUT（分别对应增删查改），这里附上一篇有关 RESTful API 的文章  <a href="https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/08.3" target="_blank" rel="noopener noreferrer nofollow">什么是 RESTful API</a> 。</p>
<h4>GET 与 POST</h4>
<p>HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 GET 请求参数的限制是来源与浏览器或 Web 服务器，浏览器或 Web 服务器限制了 URL 的长度。</p>
<p>为了明确这个概念，我们必须再次强调下面几点：</p>
<ul>
<li>HTTP 协议 未规定 GET 和 POST 的长度限制</li>
<li>GET 的最大长度显示是因为 浏览器和 Web 服务器限制了 URI 的长度</li>
<li>不同的浏览器和 Web 服务器，限制的最大长度不一样</li>
<li>要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte</li>
</ul>
<p><strong>性质</strong></p>
<ul>
<li>GET 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存</li>
<li>POST 不同，POST 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 GET 请求适合于请求缓存</li>
</ul>
<p><strong>两种请求方法的对比</strong></p>
<ul>
<li>从 <strong>缓存</strong> 的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。</li>
<li>从 <strong>编码</strong> 的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，中文需要 URL 编码，而 POST 没有限制。</li>
<li>从 <strong>参数</strong> 的角度，GET 一般放在 URL 中明文传输，因此不安全，而 POST 放在请求体中密文传输，更适合传输敏感信息。</li>
<li>从 <strong>幂等性</strong> 的角度，GET 是幂等的，而 POST 不是。（幂等表示执行相同的操作，结果也是相同的）</li>
<li>从 <strong>TCP</strong> 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 <code>header</code> 部分，如果服务器响应 100（continue）， 然后发 <code>body</code> 部分。（火狐浏览器除外，它的 POST 请求只发一个 TCP 包）</li>
</ul>
<p>GET 传输数据量限制在 2KB（GET 是通过 URL 提交数据，而 URL 本身对于数据没有限制，但是不同的浏览器对于 URL 是有限制的，比如 IE 浏览器对于 URL 的限制为 2KB，而 Chrome，FireFox 浏览器理论上对于 URL 是没有限制的，它真正的限制取决于操作系统本身），而 POST 对于数据大小是无限制的（真正影响到数据大小的是服务器处理程序的能力）。</p>
<h3>请求头</h3>
<p>请求头中的信息有和缓存相关的头（Cache-Control，If-Modified-Since）、客户端身份信息（User-Agent）等等。</p>
<p>请求头的格式为：<code>键: 值</code>，注意 <strong>冒号后面有一个空格</strong>。</p>
<p>🌰 <strong>示例：</strong></p>
<pre class="hljs"><code class="language-http"><span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>*/*
<span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip, deflate, br
<span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-CN,zh;q=0.9,en;q=0.8
<span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive
<span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>21429
<span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json
<span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>api.github.com
<span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>https://github.com
<span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>https://github.com/
<span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36
</code></pre>
<p><strong>常见的请求 Header</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">请求头</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Accept</td>
<td style="text-align:left">表示浏览器接受的数据类型</td>
</tr>
<tr>
<td style="text-align:left">Accept-Encoding</td>
<td style="text-align:left">表示浏览器接受的数据压缩格式</td>
</tr>
<tr>
<td style="text-align:left">Host</td>
<td style="text-align:left">表示当前请求访问的目标地址</td>
</tr>
<tr>
<td style="text-align:left">Authorization</td>
<td style="text-align:left">表示用户身份认证信息</td>
</tr>
<tr>
<td style="text-align:left">User-Agent</td>
<td style="text-align:left">表示浏览器类型</td>
</tr>
<tr>
<td style="text-align:left">If-Modified-Since</td>
<td style="text-align:left">表示当前请求资源最近一次更新时间</td>
</tr>
<tr>
<td style="text-align:left">If-None-Match</td>
<td style="text-align:left">表示当前请求资源最近一次标识的 ETag 值</td>
</tr>
<tr>
<td style="text-align:left">Cookie</td>
<td style="text-align:left">表示浏览器保存的 Cookie 信息</td>
</tr>
<tr>
<td style="text-align:left">Referer</td>
<td style="text-align:left">表示标识请求引用自哪个地址</td>
</tr>
</tbody>
</table>
<h3>请求体</h3>
<p>请求体是 POST 请求方式中的请求参数，以 <code>key = value</code> 形式进行存储，多个请求参数之间用 <code>&amp;</code> 连接，如果请求当中请求体，那么在请求头当中的 Content-Length 属性记录的就是该请求体的长度。</p>
<pre class="hljs"><code class="language-http"><span class="hljs-keyword">POST</span> <span class="hljs-string">hysj.jsp</span> <span class="hljs-meta">HTTP/1.1</span>
<span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>search.cnipr.com
<span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0 (Windows;U;Windows NT 6.9;zh-CN;rv:1.9.1.13)Gecko/20100914 Firefox/3.5.13 (.NET CLR 3.5.30729)
<span class="hljs-attribute">Accept</span><span class="hljs-punctuation">: </span>text/html, application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
<span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>zh-cn,zh;q=0.5
<span class="hljs-attribute">Accept-Encoding</span><span class="hljs-punctuation">: </span>gzip,deflate
<span class="hljs-attribute">Accept-Charst</span><span class="hljs-punctuation">: </span>GN2312,utf-8;q=0.7,*;q=0.7
<span class="hljs-attribute">Keep-Alive</span><span class="hljs-punctuation">: </span>300
<span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive
<span class="hljs-attribute">Referer</span><span class="hljs-punctuation">: </span>http://search.cnipr.com/cnipr/zljs/hyjs-biaodan-y.jsp
<span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>405

<span class="language-apache"><span class="hljs-attribute">pageNo</span>=<span class="hljs-number">0</span>&amp;pageSize=<span class="hljs-number">10</span>&amp;orderNum=<span class="hljs-number">306735659327926273</span>&amp;customerMobile=<span class="hljs-number">15626000000</span>&amp;startTime=<span class="hljs-number">2019</span>-<span class="hljs-number">02</span>-<span class="hljs-number">01</span>%<span class="hljs-number">2000</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>&amp;endTime=<span class="hljs-number">2019</span>-<span class="hljs-number">02</span>-<span class="hljs-number">25</span>%<span class="hljs-number">2014</span>:<span class="hljs-number">54</span>:<span class="hljs-number">20</span>&amp;status=SUCCESS&amp;source=WECHAT_SHOPPING&amp;canteenId=<span class="hljs-number">104</span>&amp;refundStatus=REFUNDED&amp;startPayTime=<span class="hljs-number">2019</span>-<span class="hljs-number">02</span>-<span class="hljs-number">01</span>%<span class="hljs-number">2000</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>&amp;endPayTime=<span class="hljs-number">2019</span>-<span class="hljs-number">02</span>-<span class="hljs-number">25</span>%<span class="hljs-number">2014</span>:<span class="hljs-number">54</span>:<span class="hljs-number">47</span>
</span></code></pre>
<p>根据应用场景的不同，HTTP 请求的请求体有三种不同的形式：</p>
<ol>
<li><strong>任意请求体</strong>：移动开发者常见的，请求体是任意类型的，服务器不会解析请求体，请求体的处理需要自己解析，如 POST、JSON 的时候就是这类</li>
<li><strong>查询字符串</strong>：URL 中 Query String 的格式要求，多个键值对之间用 <code>&amp;</code> 连接，键与值之间用 <code>=</code> 连接，且只能用 ASCII 字符，非 ASCII 字符需使用 <code>UrlEncode</code> 编码</li>
<li><strong>文件上传</strong>：当需要实现 <strong>文件上传</strong> 时，请求体会被分成多个部分，每个字段 / 文件都被首部字段 <code>Content-Type</code> 的 <strong>boundary</strong> 指令指定的值分成单独的段，每段以 <code>--</code> 加 <code>boundary</code> 指令的值开头，然后是该段的描述头，描述头之后空一行接内容，请求结束的标识为 <code>boundary</code> 后面加 <code>--</code></li>
</ol>
<p>&lt;br /&gt;</p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/http/http-upload-file-message-body.jpg&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;HTTP 请求报文结构&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{720}</span> /&gt;</span></span>;
</code></pre>
<p>区分是否被当成文件的关键是  <code>Content-Disposition</code>  是否包含  <code>filename</code>，因为文件有不同的类型，所以还要使用  <code>Content-Type</code>  指示文件的类型，如果不知道是什么类型取值可以为 <code>application/octet-stream</code> 表示文件是一个二进制的文件，如果不是文件则 <code>Content-Type</code>  可以省略。</p>
<h2>响应报文</h2>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/http/http-response-structure.png&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;HTTP 响应报文结构&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{480}</span> /&gt;</span></span>;
</code></pre>
<p>HTTP 响应的格式上除状态行（第一行）与请求报文的请求行不一样之外，其他的就格式而言是一样的，但排除状态行和请求行的区别，从 Header 上还是可以区分出 HTTP 请求和 HTTP 响应的区别的，怎么区别就要看前面的 Header。</p>
<p>HTTP 的响应报文分为三个部分：</p>
<ul>
<li>状态行
<ul>
<li>HTTP 协议版本</li>
<li>状态码</li>
<li>短语</li>
</ul>
</li>
<li>首部行</li>
<li>空行</li>
<li>实体体</li>
</ul>
<h3>状态行</h3>
<p>状态码用以表示网页服务器超文本传输协议响应状态的三位数字码。<a href="/front-end/computer-networks/http/response-status-codes">详细的状态码表请参考此处</a></p>
<table>
<thead>
<tr>
<th style="text-align:left">状态码</th>
<th style="text-align:left">对应信息</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1XX</td>
<td style="text-align:left">提示信息，表示请求已接收，继续处理</td>
</tr>
<tr>
<td style="text-align:left">2XX</td>
<td style="text-align:left">用于表示请求已被成功接收、理解、接收</td>
</tr>
<tr>
<td style="text-align:left">3XX</td>
<td style="text-align:left">用于表示资源（网页等）被永久转移到其它 URL，也就是所谓的重定向</td>
</tr>
<tr>
<td style="text-align:left">4XX</td>
<td style="text-align:left">客户端错误—请求有语法错误或者请求无法实现</td>
</tr>
<tr>
<td style="text-align:left">5XX</td>
<td style="text-align:left">服务器端错误—服务器未能实现合法的请求</td>
</tr>
</tbody>
</table>
<h3>响应头</h3>
<p>响应头同样可用于传递一些附加信息。</p>
<pre class="hljs"><code class="language-http"><span class="hljs-meta">HTTP/1.0</span> <span class="hljs-number">200</span> ok
<span class="hljs-attribute">content-type</span><span class="hljs-punctuation">: </span>application/javascript;charset=utf-8
<span class="hljs-attribute">date</span><span class="hljs-punctuation">: </span>Tue, 07 Mar 2017 03:06:14 GMT
<span class="hljs-attribute">sever</span><span class="hljs-punctuation">: </span>Domain Reliability Searver
<span class="hljs-attribute">content-length</span><span class="hljs-punctuation">: </span>0
<span class="hljs-attribute">x-xss-protection</span><span class="hljs-punctuation">: </span>1, mode=bloack
<span class="hljs-attribute">x-frame-options</span><span class="hljs-punctuation">: </span>SAMEORIGIN
<span class="hljs-attribute">alt-svc</span><span class="hljs-punctuation">: </span>quic=&quot;:443&quot;;ma=2592000;v=&quot;36,35,34&quot;
</code></pre>
<p><strong>常见的响应头 Header</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Date</td>
<td style="text-align:left">表示当前相应资源发送的服务器日期和时间</td>
</tr>
<tr>
<td style="text-align:left">Last-Modified</td>
<td style="text-align:left">表示当前响应资源最后被修改的服务器时间</td>
</tr>
<tr>
<td style="text-align:left">Transfer-Encoding</td>
<td style="text-align:left">表示当前响应资源传输实体的编码格式</td>
</tr>
<tr>
<td style="text-align:left">Set-Cookie</td>
<td style="text-align:left">表示设置 Cookie 信息</td>
</tr>
<tr>
<td style="text-align:left">Location</td>
<td style="text-align:left">在重定向中或者创建新资源时使用</td>
</tr>
<tr>
<td style="text-align:left">Server</td>
<td style="text-align:left">表示服务器名称</td>
</tr>
</tbody>
</table>
<h3>响应体</h3>
<p>响应体也就是网页的正文内容，一般在响应头中会用 Content-Length 来明确响应体的长度，便于浏览器接收，对于大数据量的正文信息，也会使用 <code>chunked</code> 的编码方式。</p>
<h2>参考资料</h2>
<ul>
<li><a href="https://www.cnblogs.com/foodoir/p/5911099.html" target="_blank" rel="noopener noreferrer nofollow">📝 HTTP 请求方法详解</a></li>
</ul>
</article></div></main><script src="/_next/static/chunks/webpack-53834dba86d90934.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5244,[],\"\"]\n3:I[3866,[],\"\"]\n5:I[6213,[],\"OutletBoundary\"]\n7:I[6213,[],\"MetadataBoundary\"]\n9:I[6213,[],\"ViewportBoundary\"]\nb:I[4835,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/ec0a9d078e716e00.css\",\"style\"]\n:HL[\"/_next/static/css/485ff6fe79292a08.css\",\"style\"]\n:HL[\"/_next/static/css/0ff121a467c0636f.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"NW9bMA21iAaih0TqCHqj1\",\"p\":\"\",\"c\":[\"\",\"front-end\",\"computer-networks\",\"http\",\"http-message\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"front-end\",{\"children\":[[\"slug\",\"computer-networks/http/http-message\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/ec0a9d078e716e00.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"front-end\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/485ff6fe79292a08.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0ff121a467c0636f.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"main\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[[\"slug\",\"computer-networks/http/http-message\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"Ulp04J3WkTXlwVyKPEpZ1\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:T4f86,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eHTTP 报文格式\u003c/h1\u003e\n\u003cp\u003e对于 TCP 而言，在传输的时候分为两个部分：TCP 头和数据部分。\u003c/p\u003e\n\u003cp\u003e而 HTTP 报文是面向文本的，报文中的每个字段都是一些 ASCII 码串，各个字段的长度是不确定的。HTTP 有两类报文：\u003cstrong\u003e请求报文\u003c/strong\u003e 和 \u003cstrong\u003e响应报文\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003eHTTP 请求/响应报文由以下内容组成：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e请求头\u003c/li\u003e\n\u003cli\u003eHTTP 头部字段\u003c/li\u003e\n\u003cli\u003e空行\u003c/li\u003e\n\u003cli\u003e可选的 HTTP 报文主体数据\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e请求报文\u003c/h2\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e img \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;../../assets/http/http-request-structure.png\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e () =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;HTTP 请求报文结构\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{img}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{480}\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHTTP 的请求报文分为三个部分：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e请求行\n\u003cul\u003e\n\u003cli\u003e请求方法\u003c/li\u003e\n\u003cli\u003e请求地址 URL\u003c/li\u003e\n\u003cli\u003eHTTP 协议版本\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e首部行\n\u003cul\u003e\n\u003cli\u003eContent-Type\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e空行\u003c/li\u003e\n\u003cli\u003e实体主体\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e请求行\u003c/h3\u003e\n\u003cp\u003e请求行是请求消息的第一行，由三部分组成：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e请求方法（GET / POST / DELETE / PUT / HEAD）\u003c/li\u003e\n\u003cli\u003e请求资源的 URI 路径\u003c/li\u003e\n\u003cli\u003eHTTP 的版本号\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e🌰 \u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-http\"\u003e\u003cspan class=\"hljs-keyword\"\u003eGET\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e/index.html\u003c/span\u003e \u003cspan class=\"hljs-meta\"\u003eHTTP/1.1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e请求方法\u003c/h4\u003e\n\u003cp\u003eHTTP/1.1 协议中共定义了八种方法，以不同的方式操作指定的资源。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e方法名\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e功能\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eGET\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e向指定的资源发出 \u003cstrong\u003e显示\u003c/strong\u003e 请求，使用 GET 方法应该只用在 \u003cstrong\u003e读取数据\u003c/strong\u003e 上，而不应该用于产生 \u003cstrong\u003e副作用\u003c/strong\u003e 的操作中。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003ePOST\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e指定资源 \u003cstrong\u003e提交数据\u003c/strong\u003e，请求服务器进行处理（例如提交表单或者上传文件）。\u003cstrong\u003e数据被包含在请求文本中\u003c/strong\u003e。这个请求可能会创建新的资源或者修改现有资源，或两者皆有。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003ePUT\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e向指定资源位置上传其 \u003cstrong\u003e最新内容\u003c/strong\u003e。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eDELETE\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e请求服务器删除 Request-URI 所标识的资源。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eOPTIONS\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e使服务器传回该 \u003cstrong\u003e资源支持的所有 HTTP 请求方法\u003c/strong\u003e。用 \u003ccode\u003e*\u003c/code\u003e 来代替资源名称，向 Web 服务器发送 OPTIONS 请求，可以测试服务器功能是否正常运作。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eHEAD\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e与 GET 方法一样，都是向服务器发出指定资源的请求，只不过服务器将 \u003cstrong\u003e不传回资源的本文部分\u003c/strong\u003e，它的好处在于，使用这个方法可以在不必传输全部内容的情况下，就可以获取其中 \u003ccode\u003e关于该资源的信息\u003c/code\u003e（原信息或称元数据）。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eTRACE\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e显示服务器收到的请求，主要用于测试或诊断。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eCONNECT\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eHTTP/1.1 中预留给能够将连接改为通道方式的代理服务器。通常用于 SSL 加密服务器的链接（经由非加密的 HTTP 代理服务器）。\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e其中，最常见的是 GET 和 POST 方法，如果是 RESful API 接口规范的话一般会用到 POST、DELETE、GET、PUT（分别对应增删查改），这里附上一篇有关 RESTful API 的文章  \u003ca href=\"https://github.com/astaxie/build-web-application-with-golang/blob/master/zh/08.3\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e什么是 RESTful API\u003c/a\u003e 。\u003c/p\u003e\n\u003ch4\u003eGET 与 POST\u003c/h4\u003e\n\u003cp\u003eHTTP 协议从未规定 GET/POST 的请求长度限制是多少。对 GET 请求参数的限制是来源与浏览器或 Web 服务器，浏览器或 Web 服务器限制了 URL 的长度。\u003c/p\u003e\n\u003cp\u003e为了明确这个概念，我们必须再次强调下面几点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eHTTP 协议 未规定 GET 和 POST 的长度限制\u003c/li\u003e\n\u003cli\u003eGET 的最大长度显示是因为 浏览器和 Web 服务器限制了 URI 的长度\u003c/li\u003e\n\u003cli\u003e不同的浏览器和 Web 服务器，限制的最大长度不一样\u003c/li\u003e\n\u003cli\u003e要支持 IE，则最大长度为 2083byte，若只支持 Chrome，则最大长度 8182byte\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e性质\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eGET 请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存\u003c/li\u003e\n\u003cli\u003ePOST 不同，POST 做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此 GET 请求适合于请求缓存\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e两种请求方法的对比\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e从 \u003cstrong\u003e缓存\u003c/strong\u003e 的角度，GET 请求会被浏览器主动缓存下来，留下历史记录，而 POST 默认不会。\u003c/li\u003e\n\u003cli\u003e从 \u003cstrong\u003e编码\u003c/strong\u003e 的角度，GET 只能进行 URL 编码，只能接收 ASCII 字符，中文需要 URL 编码，而 POST 没有限制。\u003c/li\u003e\n\u003cli\u003e从 \u003cstrong\u003e参数\u003c/strong\u003e 的角度，GET 一般放在 URL 中明文传输，因此不安全，而 POST 放在请求体中密文传输，更适合传输敏感信息。\u003c/li\u003e\n\u003cli\u003e从 \u003cstrong\u003e幂等性\u003c/strong\u003e 的角度，GET 是幂等的，而 POST 不是。（幂等表示执行相同的操作，结果也是相同的）\u003c/li\u003e\n\u003cli\u003e从 \u003cstrong\u003eTCP\u003c/strong\u003e 的角度，GET 请求会把请求报文一次性发出去，而 POST 会分为两个 TCP 数据包，首先发 \u003ccode\u003eheader\u003c/code\u003e 部分，如果服务器响应 100（continue）， 然后发 \u003ccode\u003ebody\u003c/code\u003e 部分。（火狐浏览器除外，它的 POST 请求只发一个 TCP 包）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eGET 传输数据量限制在 2KB（GET 是通过 URL 提交数据，而 URL 本身对于数据没有限制，但是不同的浏览器对于 URL 是有限制的，比如 IE 浏览器对于 URL 的限制为 2KB，而 Chrome，FireFox 浏览器理论上对于 URL 是没有限制的，它真正的限制取决于操作系统本身），而 POST 对于数据大小是无限制的（真正影响到数据大小的是服务器处理程序的能力）。\u003c/p\u003e\n\u003ch3\u003e请求头\u003c/h3\u003e\n\u003cp\u003e请求头中的信息有和缓存相关的头（Cache-Control，If-Modified-Since）、客户端身份信息（User-Agent）等等。\u003c/p\u003e\n\u003cp\u003e请求头的格式为：\u003ccode\u003e键: 值\u003c/code\u003e，注意 \u003cstrong\u003e冒号后面有一个空格\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e🌰 \u003cstrong\u003e示例：\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-http\"\u003e\u003cspan class=\"hljs-attribute\"\u003eAccept\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003e*/*\n\u003cspan class=\"hljs-attribute\"\u003eAccept-Encoding\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003egzip, deflate, br\n\u003cspan class=\"hljs-attribute\"\u003eAccept-Language\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003ezh-CN,zh;q=0.9,en;q=0.8\n\u003cspan class=\"hljs-attribute\"\u003eConnection\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003ekeep-alive\n\u003cspan class=\"hljs-attribute\"\u003eContent-Length\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003e21429\n\u003cspan class=\"hljs-attribute\"\u003eContent-Type\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003eapplication/json\n\u003cspan class=\"hljs-attribute\"\u003eHost\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003eapi.github.com\n\u003cspan class=\"hljs-attribute\"\u003eOrigin\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003ehttps://github.com\n\u003cspan class=\"hljs-attribute\"\u003eReferer\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003ehttps://github.com/\n\u003cspan class=\"hljs-attribute\"\u003eUser-Agent\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003eMozilla/5.0 (Macintosh; Intel Mac OS X 10_13_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e常见的请求 Header\u003c/strong\u003e\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e请求头\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e说明\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eAccept\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e表示浏览器接受的数据类型\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eAccept-Encoding\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e表示浏览器接受的数据压缩格式\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eHost\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e表示当前请求访问的目标地址\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eAuthorization\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e表示用户身份认证信息\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eUser-Agent\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e表示浏览器类型\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eIf-Modified-Since\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e表示当前请求资源最近一次更新时间\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eIf-None-Match\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e表示当前请求资源最近一次标识的 ETag 值\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eCookie\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e表示浏览器保存的 Cookie 信息\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eReferer\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e表示标识请求引用自哪个地址\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3\u003e请求体\u003c/h3\u003e\n\u003cp\u003e请求体是 POST 请求方式中的请求参数，以 \u003ccode\u003ekey = value\u003c/code\u003e 形式进行存储，多个请求参数之间用 \u003ccode\u003e\u0026amp;\u003c/code\u003e 连接，如果请求当中请求体，那么在请求头当中的 Content-Length 属性记录的就是该请求体的长度。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-http\"\u003e\u003cspan class=\"hljs-keyword\"\u003ePOST\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003ehysj.jsp\u003c/span\u003e \u003cspan class=\"hljs-meta\"\u003eHTTP/1.1\u003c/span\u003e\n\u003cspan class=\"hljs-attribute\"\u003eHost\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003esearch.cnipr.com\n\u003cspan class=\"hljs-attribute\"\u003eUser-Agent\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003eMozilla/5.0 (Windows;U;Windows NT 6.9;zh-CN;rv:1.9.1.13)Gecko/20100914 Firefox/3.5.13 (.NET CLR 3.5.30729)\n\u003cspan class=\"hljs-attribute\"\u003eAccept\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003etext/html, application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\n\u003cspan class=\"hljs-attribute\"\u003eAccept-Language\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003ezh-cn,zh;q=0.5\n\u003cspan class=\"hljs-attribute\"\u003eAccept-Encoding\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003egzip,deflate\n\u003cspan class=\"hljs-attribute\"\u003eAccept-Charst\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003eGN2312,utf-8;q=0.7,*;q=0.7\n\u003cspan class=\"hljs-attribute\"\u003eKeep-Alive\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003e300\n\u003cspan class=\"hljs-attribute\"\u003eConnection\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003ekeep-alive\n\u003cspan class=\"hljs-attribute\"\u003eReferer\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003ehttp://search.cnipr.com/cnipr/zljs/hyjs-biaodan-y.jsp\n\u003cspan class=\"hljs-attribute\"\u003eContent-Length\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003e405\n\n\u003cspan class=\"language-apache\"\u003e\u003cspan class=\"hljs-attribute\"\u003epageNo\u003c/span\u003e=\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e\u0026amp;pageSize=\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e\u0026amp;orderNum=\u003cspan class=\"hljs-number\"\u003e306735659327926273\u003c/span\u003e\u0026amp;customerMobile=\u003cspan class=\"hljs-number\"\u003e15626000000\u003c/span\u003e\u0026amp;startTime=\u003cspan class=\"hljs-number\"\u003e2019\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e02\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e01\u003c/span\u003e%\u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e\u0026amp;endTime=\u003cspan class=\"hljs-number\"\u003e2019\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e02\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e%\u003cspan class=\"hljs-number\"\u003e2014\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e54\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e\u0026amp;status=SUCCESS\u0026amp;source=WECHAT_SHOPPING\u0026amp;canteenId=\u003cspan class=\"hljs-number\"\u003e104\u003c/span\u003e\u0026amp;refundStatus=REFUNDED\u0026amp;startPayTime=\u003cspan class=\"hljs-number\"\u003e2019\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e02\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e01\u003c/span\u003e%\u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e00\u003c/span\u003e\u0026amp;endPayTime=\u003cspan class=\"hljs-number\"\u003e2019\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e02\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e25\u003c/span\u003e%\u003cspan class=\"hljs-number\"\u003e2014\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e54\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e47\u003c/span\u003e\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e根据应用场景的不同，HTTP 请求的请求体有三种不同的形式：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e任意请求体\u003c/strong\u003e：移动开发者常见的，请求体是任意类型的，服务器不会解析请求体，请求体的处理需要自己解析，如 POST、JSON 的时候就是这类\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e查询字符串\u003c/strong\u003e：URL 中 Query String 的格式要求，多个键值对之间用 \u003ccode\u003e\u0026amp;\u003c/code\u003e 连接，键与值之间用 \u003ccode\u003e=\u003c/code\u003e 连接，且只能用 ASCII 字符，非 ASCII 字符需使用 \u003ccode\u003eUrlEncode\u003c/code\u003e 编码\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e文件上传\u003c/strong\u003e：当需要实现 \u003cstrong\u003e文件上传\u003c/strong\u003e 时，请求体会被分成多个部分，每个字段 / 文件都被首部字段 \u003ccode\u003eContent-Type\u003c/code\u003e 的 \u003cstrong\u003eboundary\u003c/strong\u003e 指令指定的值分成单独的段，每段以 \u003ccode\u003e--\u003c/code\u003e 加 \u003ccode\u003eboundary\u003c/code\u003e 指令的值开头，然后是该段的描述头，描述头之后空一行接内容，请求结束的标识为 \u003ccode\u003eboundary\u003c/code\u003e 后面加 \u003ccode\u003e--\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e\u0026lt;br /\u0026gt;\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e img \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;../../assets/http/http-upload-file-message-body.jpg\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e () =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;HTTP 请求报文结构\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{img}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{720}\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e区分是否被当成文件的关键是  \u003ccode\u003eContent-Disposition\u003c/code\u003e  是否包含  \u003ccode\u003efilename\u003c/code\u003e，因为文件有不同的类型，所以还要使用  \u003ccode\u003eContent-Type\u003c/code\u003e  指示文件的类型，如果不知道是什么类型取值可以为 \u003ccode\u003eapplication/octet-stream\u003c/code\u003e 表示文件是一个二进制的文件，如果不是文件则 \u003ccode\u003eContent-Type\u003c/code\u003e  可以省略。\u003c/p\u003e\n\u003ch2\u003e响应报文\u003c/h2\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e img \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;../../assets/http/http-response-structure.png\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e () =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;HTTP 响应报文结构\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{img}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{480}\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHTTP 响应的格式上除状态行（第一行）与请求报文的请求行不一样之外，其他的就格式而言是一样的，但排除状态行和请求行的区别，从 Header 上还是可以区分出 HTTP 请求和 HTTP 响应的区别的，怎么区别就要看前面的 Header。\u003c/p\u003e\n\u003cp\u003eHTTP 的响应报文分为三个部分：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e状态行\n\u003cul\u003e\n\u003cli\u003eHTTP 协议版本\u003c/li\u003e\n\u003cli\u003e状态码\u003c/li\u003e\n\u003cli\u003e短语\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e首部行\u003c/li\u003e\n\u003cli\u003e空行\u003c/li\u003e\n\u003cli\u003e实体体\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e状态行\u003c/h3\u003e\n\u003cp\u003e状态码用以表示网页服务器超文本传输协议响应状态的三位数字码。\u003ca href=\"/front-end/computer-networks/http/response-status-codes\"\u003e详细的状态码表请参考此处\u003c/a\u003e\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e状态码\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e对应信息\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e1XX\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e提示信息，表示请求已接收，继续处理\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e2XX\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e用于表示请求已被成功接收、理解、接收\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e3XX\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e用于表示资源（网页等）被永久转移到其它 URL，也就是所谓的重定向\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e4XX\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e客户端错误—请求有语法错误或者请求无法实现\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e5XX\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e服务器端错误—服务器未能实现合法的请求\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3\u003e响应头\u003c/h3\u003e\n\u003cp\u003e响应头同样可用于传递一些附加信息。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-http\"\u003e\u003cspan class=\"hljs-meta\"\u003eHTTP/1.0\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e ok\n\u003cspan class=\"hljs-attribute\"\u003econtent-type\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003eapplication/javascript;charset=utf-8\n\u003cspan class=\"hljs-attribute\"\u003edate\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003eTue, 07 Mar 2017 03:06:14 GMT\n\u003cspan class=\"hljs-attribute\"\u003esever\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003eDomain Reliability Searver\n\u003cspan class=\"hljs-attribute\"\u003econtent-length\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003e0\n\u003cspan class=\"hljs-attribute\"\u003ex-xss-protection\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003e1, mode=bloack\n\u003cspan class=\"hljs-attribute\"\u003ex-frame-options\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003eSAMEORIGIN\n\u003cspan class=\"hljs-attribute\"\u003ealt-svc\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003equic=\u0026quot;:443\u0026quot;;ma=2592000;v=\u0026quot;36,35,34\u0026quot;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e常见的响应头 Header\u003c/strong\u003e\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e名称\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e作用\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eDate\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e表示当前相应资源发送的服务器日期和时间\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eLast-Modified\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e表示当前响应资源最后被修改的服务器时间\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eTransfer-Encoding\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e表示当前响应资源传输实体的编码格式\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eSet-Cookie\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e表示设置 Cookie 信息\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eLocation\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e在重定向中或者创建新资源时使用\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eServer\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e表示服务器名称\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3\u003e响应体\u003c/h3\u003e\n\u003cp\u003e响应体也就是网页的正文内容，一般在响应头中会用 Content-Length 来明确响应体的长度，便于浏览器接收，对于大数据量的正文信息，也会使用 \u003ccode\u003echunked\u003c/code\u003e 的编码方式。\u003c/p\u003e\n\u003ch2\u003e参考资料\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.cnblogs.com/foodoir/p/5911099.html\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 HTTP 请求方法详解\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"markdown-body\",\"children\":[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"front-end\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"front-end knowledge\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>