<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/d4dd73d504c89c58.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/485ff6fe79292a08.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/0ff121a467c0636f.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-53834dba86d90934.js"/><script src="/_next/static/chunks/4bd1b696-20882bf820444624.js" async=""></script><script src="/_next/static/chunks/517-98ed787e5f259f2c.js" async=""></script><script src="/_next/static/chunks/main-app-f33d3e3aed85e21f.js" async=""></script><meta name="next-size-adjust" content=""/><title>front-end</title><meta name="description" content="front-end knowledge"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><main><div class="markdown-body"><article><h1>流量劫持</h1>
<p>流量劫持的方式主要分为两种：</p>
<ul>
<li>域名解析劫持（DNS 劫持）</li>
<li>数据劫持（HTTP 劫持）</li>
</ul>
<p>我们国内用户，一般是在家用路由器后面，要访问一个网站的话，会有三个步骤：</p>
<ol>
<li>首先访问 DNS 服务器，将域名转换为 IP 地址。</li>
<li>访问这个 IP 地址，这样用户就访问了目标网站。</li>
<li>如果是一个建设良好的网站，一般会把静态资源放在 CDN 上。</li>
</ol>
<p>流量劫持就是在这些环节当中，对数据进行 <strong>偷窃</strong>、<strong>篡改</strong>，甚至转发流量进行攻击的这样一类行为。</p>
<h2>DNS 劫持</h2>
<p><strong>域名解析劫持</strong>（DNS 劫持）是针对传统 DNS 解析的常见劫持方式。用户在浏览器输入网址，即发出一个 HTTP 请求，首先需要进行域名解析，得到业务服务器的 IP 地址。使用传统 DNS 解析时，会通过当地网络运营商提供的本地域名服务器解析得到结果。在请求本地域名服务器解析域名时会出现问题，目标域名被恶意地解析到其他 IP 地址，造成用户无法正常使用服务。</p>
<p><a href="/front-end/computer-networks/computer-network-architecture/dns#%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B">🌐 关于域名解析过程详解</a></p>
<h3>攻击方式</h3>
<p>那么如何才能够污染 DNS 以达成流量劫持的目的呢？粗略来说，一共有三种途径：</p>
<ol>
<li><strong>在用户设备上动手</strong>：这个主要是通过一些恶意软件实现的，比如早期一些流氓软件会在用户本机篡改 <code>hosts</code> 文件，影响用户的搜索引擎工作。</li>
<li><strong>污染中间链路设备</strong>：由于 DNS 查询是基于 UDP 协议明文发送的，因此在任意中间设备上，比如路由器，进行中间人攻击，修改 UDP 包的内容，就可以影响 DNS 的结果了。</li>
<li><strong>入侵 DNS 服务器</strong>：这是一种成本比较高的方案，看起来似乎很困难，但 DNS 是一种相对古老的技术，其服务软件的实现可能已经年久失修，别有用心的攻击者可以寻找一些缺乏维护的 DNS 服务器，施行攻击。另外，有时 DNS 服务器上不止运行 DNS 软件，还会有一些其他的软件也在运行，比如同时也启动了 HTTP 服务等，这时攻击者也可以通过这些软件的漏洞来控制服务器，进而影响 DNS 的解析。由于 DNS 的缓存和上下传递关系，一旦有 DNS 服务器被影响，就会一次影响很多用户的访问，因此非常危险。</li>
</ol>
<p>这三种途径当中，第一种和第三种的实施成本都比较高，但污染链路设备，在 Wi-Fi 普及而安全意识尚未普及的今天，是最容易得手的一种途径。</p>
<h3>防御策略</h3>
<p>目前针对 DNS 投毒，对抗中间人攻击的研究比较多。DNS 协议本身的安全性较差，而改造 DNS 协议又比较困难，因此现在主要的防御手段，集中在替换 UDP 协议上。</p>
<ul>
<li>TLS（Cloudflare）</li>
<li>HTTP（腾讯云、阿里云）</li>
<li>HTTPS（Cloudflare、Google）</li>
</ul>
<p>目前，三种常见的替代方式比较流行：</p>
<ol>
<li>DNS over TLS。这种协议是在 TLS 协议之上传输 DNS 内容，有点类似 HTTPS 和 TLS 关系。</li>
<li>DNS over HTTP。用 HTTP 协议来传输 DNS ，也是可以的。国内厂商当中对这种方案的支持较多。最简单的实现是使用一个 固定的 IP 地址作为域名服务器，每次不发生 UDP ，而是向这台服务器发送 HTTP 请求来获取解析结果。但通常很难签发相应的证书给固定 IP，因此也有些厂商自己对 HTTP 报文进行加密，从而防止这些解析结果再被中间人篡改。</li>
<li>DNS over HTTPS。和第二点比较类似，区别是使用了 HTTPS 协议。根据我的观察，采用这种方案的 Google 和 Cloudflare 都使用的是域名而非固定 IP ，因此还是要先解析一次域名服务器自身的域名才可以进行真正的查询。这可能会导致再次被中间人扰乱，从而迫使用户降级到普通的 UDP 方式上。</li>
</ol>
<p>比较遗憾的是，由于浏览器没有暴露 DNS 相关的接口，这三种较为安全的 DNS 查询方式，都无法在前端当中得以使用。而 iOS 和 Android 开发者有机会使用其中的技术进行加强，但需要单独编写一些代码。</p>
<blockquote>
<p>打工信部电话（12300）投诉也不失是个好办法。</p>
</blockquote>
<h2>HTTP 劫持</h2>
<p>HTTP 协议属于明文协议，中间链路上的任意设备，都可以篡改内容，导致流量劫持。</p>
<h3>防御策略</h3>
<h4>Content Security Policy</h4>
<p>CSP 原本是为了和 XSS 对抗而产生的一种技术方案，其原理是在 HTML 加载的时候，指定每种资源的 URL 白名单规则，防止 XSS 的运行和数据外送。但如果巧妙利用规则，也可以让所有的资源强制走 HTTPS ，这样就可以降低流量劫持的可能性。</p>
<p>具体的 CSP 规则比较复杂，大家可以在 <a href="https://content-security-policy.com/" target="_blank" rel="noopener noreferrer nofollow">CSP 专属网站</a>上自己查看。</p>
<h4>Subresource Integrity</h4>
<p>SRI 是专门用来校验资源的一种方案，它读取资源标签中的 <code>integrity</code> 属性，将其中的信息摘要值，和资源实际的信息摘要值进行对比，如果发现无法匹配，那么浏览器就会拒绝执行资源。对于 <code>&lt;script&gt;</code> 标签来说，就是拒绝执行其中的代码，对于 CSS 来说则是不加载其中的样式。</p>
<p>通过给 <code>link</code> 标签或者 <code>script</code> 标签增加 <code>integrity</code> 属性即可开启 SRI 功能，比如：</p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>
  <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>
  <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//s.url.cn/xxx/aaa.js&quot;</span>
  <span class="hljs-attr">integrity</span>=<span class="hljs-string">&quot;sha156-xxx sha384-yyy&quot;</span>
  <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">&quot;anonymous&quot;</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p><code>integrity</code> 值分成两个部分，第一部分指定哈希值的生成算法（sha256、sha384 及 sha512），第二部分是经过 <code>base64</code> 编码的实际哈希值，两者之间通过一个短横（<code>-</code>）分割。<code>integrity</code> 值可以包含多个由空格分隔的哈希值，只要文件匹配其中任意一个哈希值，就可以通过校验并加载该资源。上述例子中我使用了 <code>sha256</code> 和 <code>sha384</code> 两种 <code>hash</code> 方案。</p>
<blockquote>
<p>备注：crossorigin=&quot;anonymous&quot; 的作用是引入跨域脚本，在 HTML5 中有一种方式可以获取到跨域脚本的错误信息，首先跨域脚本的服务器必须通过 Access-Controll-Allow-Origin 头信息允许当前域名可以获取错误信息，然后是当前域名的 <code>script</code> 标签也必须声明支持跨域，也就是 <code>crossorigin</code> 属性。<code>link</code>、<code>img</code> 等标签均支持跨域脚本。如果上述两个条件无法满足的话， 可以使用 <code>try catch</code> 方案。</p>
</blockquote>
<p>通过使用 webpack 的 <code>html-webpack-plugin</code> 和 <code>webpack-subresource-integrity</code> 可以生成包含 <code>integrity</code> 属性 <code>script</code> 标签。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">import</span> <span class="hljs-title class_">SriPlugin</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;webpack-subresource-integrity&#x27;</span>;

<span class="hljs-keyword">const</span> compiler = <span class="hljs-title function_">webpack</span>({
  <span class="hljs-attr">output</span>: {
    <span class="hljs-attr">crossOriginLoading</span>: <span class="hljs-string">&#x27;anonymous&#x27;</span>,
  },
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">SriPlugin</span>({
      <span class="hljs-attr">hashFuncNames</span>: [<span class="hljs-string">&#x27;sha256&#x27;</span>, <span class="hljs-string">&#x27;sha384&#x27;</span>],
      <span class="hljs-attr">enabled</span>: process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;production&#x27;</span>,
    }),
  ],
});
</code></pre>
<p>那么当 <code>script</code> 或者 <code>link</code> 资源 SRI 校验失败的时候应该怎么做呢？</p>
<p>比较好的方式是通过 <code>script</code> 的 <code>onerror</code> 事件，当遇到 <code>onerror</code> 的时候重新 <code>load</code> 静态文件服务器之间的资源：</p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>
  <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>
  <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//11.url.cn/aaa.js&quot;</span>
  <span class="hljs-attr">integrity</span>=<span class="hljs-string">&quot;sha256-xxx sha384-yyy&quot;</span>
  <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">&quot;anonymous&quot;</span>
  <span class="hljs-attr">onerror</span>=<span class="hljs-string">&quot;loadScriptError.call(this, event)&quot;</span>
  <span class="hljs-attr">onsuccess</span>=<span class="hljs-string">&quot;loadScriptSuccess&quot;</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>在此之前注入以下代码：</p>
<pre class="hljs"><code class="language-js">(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
	<span class="hljs-keyword">function</span> <span class="hljs-title function_">loadScriptError</span> (<span class="hljs-params">event</span>) {
		<span class="hljs-comment">// 上报</span>
		...
		<span class="hljs-comment">// 重新加载 js</span>
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) {
			<span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)
			script.<span class="hljs-property">src</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">src</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\/\/11.src.cn/</span>, <span class="hljs-string">&#x27;https://x.y.z&#x27;</span>) <span class="hljs-comment">// 替换 cdn 地址为静态文件服务器地址</span>
			script.<span class="hljs-property">onload</span> = resolve
			script.<span class="hljs-property">onerror</span> = reject
			script.<span class="hljs-property">crossOrigin</span> = <span class="hljs-string">&#x27;anonymous&#x27;</span>
			<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;head&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">appendChild</span>(script)
		})
	}
	<span class="hljs-keyword">function</span> <span class="hljs-title function_">loadScriptSuccess</span> (<span class="hljs-params"></span>) {
		<span class="hljs-comment">// 上报</span>
		...
	}
	<span class="hljs-variable language_">window</span>.<span class="hljs-property">loadScriptError</span> = loadScriptError
	<span class="hljs-variable language_">window</span>.<span class="hljs-property">loadScriptSuccess</span> = loadScriptSuccess
})()
</code></pre>
<p>比较痛苦的是 <code>onerror</code> 中的 <code>event</code> 中无法区分究竟是什么原因导致的错误，可能是资源不存在，也可能是 SRI 校验失败，当然出现最多的还是请求超时，不过目前来看，除非有统计需求，无差别对待并没有多大问题。</p>
<p>注入 <code>onerror</code> 事件</p>
<p>当然，由于项目中的 <code>script</code> 标签是由 webpack 打包进去的，所以我们要使用 <code>script-ext-html-webpack-plugin</code> 将 <code>onerror</code> 事件和 <code>onsuccess</code> 事件注入进去：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">ScriptExtHtmlWebpackPlugin</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;script-ext-html-webpack-plugin&#x27;</span>);

<span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-comment">//...</span>
  <span class="hljs-attr">plugins</span>: [
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">HtmlWebpackPlugin</span>(),
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">SriPlugin</span>({
      <span class="hljs-attr">hashFuncNames</span>: [<span class="hljs-string">&#x27;sha256&#x27;</span>, <span class="hljs-string">&#x27;sha384&#x27;</span>],
    }),
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScriptExtHtmlWebpackPlugin</span>({
      <span class="hljs-attr">custom</span>: {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\/*_[A-Za-z0-9]{8}.js/</span>,
        <span class="hljs-attr">attribute</span>: <span class="hljs-string">&#x27;onerror&#x27;</span>,
        <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;loadScriptError.call(this, event)&#x27;</span>,
      },
    }),
    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScriptExtHtmlWebpackPlugin</span>({
      <span class="hljs-attr">custom</span>: {
        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\/*_[A-Za-z0-9]{8}.js/</span>,
        <span class="hljs-attr">attribute</span>: <span class="hljs-string">&#x27;onsuccess&#x27;</span>,
        <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;loadScriptSuccess.call(this, event)&#x27;</span>,
      },
    }),
  ],
};
</code></pre>
<p>然后将 <code>loadScriptError</code> 和 <code>loadScriptSuccess</code> 两个方法注入到 HTML 中，可以使用 <code>inline</code> 的方式。</p>
<h2>CDN 劫持</h2>
<p>前面说到 script 加载失败可能是由于多种原因造成的，那如何是否判断发生了 CDN 劫持呢？</p>
<p>方法就是再请求一次数据，比较两次得到文件的内容（当然不必全部比较），如果内容不一致，就可以得出结论了。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">loadScript</span>(<span class="hljs-params">url</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">fetch</span>(url)
    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
      <span class="hljs-keyword">if</span> (res.<span class="hljs-property">ok</span>) {
        <span class="hljs-keyword">return</span> res;
      }
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>());
    })
    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> res.<span class="hljs-title function_">text</span>();
    })
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span>;
    });
}
</code></pre>
<p>比较两次加载的 <code>script</code> 是否相同</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">checkScriptDiff</span>(<span class="hljs-params">src, srcNew</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-title function_">loadScript</span>(src), <span class="hljs-title function_">loadScript</span>(srcNew)])
    .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> {
      <span class="hljs-keyword">var</span> res1 = data[<span class="hljs-number">0</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>);
      <span class="hljs-keyword">var</span> res2 = data[<span class="hljs-number">1</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>);
      <span class="hljs-keyword">if</span> (!!res1 &amp;&amp; !!res2 &amp;&amp; res1 !== res2) {
        <span class="hljs-comment">// CDN劫持事件发生</span>
      }
    })
    .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
      <span class="hljs-comment">// ...</span>
    });
}
</code></pre>
<p>这里为什么只比较前 1000 个字符？因为通常 CDN 劫持者会在 js 文件最前面注入一些代码来达到他们的目的，注入中间代码需要 AST 解析，成本较高，所以比较全部字符串没有意义。如果你还是有顾虑的话，可以加上后 n 个字符的比较。</p>
<h2>参考资料</h2>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity" target="_blank" rel="noopener noreferrer nofollow">📖 MDN：Subresource Integrity</a></li>
<li><a href="https://juejin.im/entry/5a559dd36fb9a01c9e45d896" target="_blank" rel="noopener noreferrer nofollow">📝 常见 Web 安全攻防总结</a></li>
<li><a href="https://juejin.im/entry/5bcec8e2518825102423e391" target="_blank" rel="noopener noreferrer nofollow">📝 浅谈流量劫持与防治</a></li>
<li><a href="https://juejin.im/post/5c355a816fb9a049a42f3ac8" target="_blank" rel="noopener noreferrer nofollow">📝 腾讯 IVWEB 团队：使用 SRI 解决 CDN 劫持</a></li>
<li><a href="https://www.zhihu.com/question/35720092" target="_blank" rel="noopener noreferrer nofollow">📝 应对流量劫持，前端能做哪些工作？</a></li>
<li><a href="https://js8.in/2017/08/04/Web%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%8A%AB%E6%8C%81%E5%92%8C%E5%8F%8D%E5%8A%AB%E6%8C%81/#more" target="_blank" rel="noopener noreferrer nofollow">📝 Web 前端页面劫持和反劫持</a></li>
</ul>
</article></div></main><script src="/_next/static/chunks/webpack-53834dba86d90934.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5244,[],\"\"]\n3:I[3866,[],\"\"]\n5:I[6213,[],\"OutletBoundary\"]\n7:I[6213,[],\"MetadataBoundary\"]\n9:I[6213,[],\"ViewportBoundary\"]\nb:I[4835,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/d4dd73d504c89c58.css\",\"style\"]\n:HL[\"/_next/static/css/485ff6fe79292a08.css\",\"style\"]\n:HL[\"/_next/static/css/0ff121a467c0636f.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"1zJy3VHENUSg9vzcRvJ6P\",\"p\":\"\",\"c\":[\"\",\"front-end\",\"computer-networks\",\"web-security\",\"hijacking\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"front-end\",{\"children\":[[\"slug\",\"computer-networks/web-security/hijacking\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d4dd73d504c89c58.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"front-end\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/485ff6fe79292a08.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0ff121a467c0636f.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"main\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[[\"slug\",\"computer-networks/web-security/hijacking\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"jyWZulmR2WzKTqj4sjuZN\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:T4bd4,"])</script><script>self.__next_f.push([1,"\u003ch1\u003e流量劫持\u003c/h1\u003e\n\u003cp\u003e流量劫持的方式主要分为两种：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e域名解析劫持（DNS 劫持）\u003c/li\u003e\n\u003cli\u003e数据劫持（HTTP 劫持）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e我们国内用户，一般是在家用路由器后面，要访问一个网站的话，会有三个步骤：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e首先访问 DNS 服务器，将域名转换为 IP 地址。\u003c/li\u003e\n\u003cli\u003e访问这个 IP 地址，这样用户就访问了目标网站。\u003c/li\u003e\n\u003cli\u003e如果是一个建设良好的网站，一般会把静态资源放在 CDN 上。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e流量劫持就是在这些环节当中，对数据进行 \u003cstrong\u003e偷窃\u003c/strong\u003e、\u003cstrong\u003e篡改\u003c/strong\u003e，甚至转发流量进行攻击的这样一类行为。\u003c/p\u003e\n\u003ch2\u003eDNS 劫持\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e域名解析劫持\u003c/strong\u003e（DNS 劫持）是针对传统 DNS 解析的常见劫持方式。用户在浏览器输入网址，即发出一个 HTTP 请求，首先需要进行域名解析，得到业务服务器的 IP 地址。使用传统 DNS 解析时，会通过当地网络运营商提供的本地域名服务器解析得到结果。在请求本地域名服务器解析域名时会出现问题，目标域名被恶意地解析到其他 IP 地址，造成用户无法正常使用服务。\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"/front-end/computer-networks/computer-network-architecture/dns#%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E8%BF%87%E7%A8%8B\"\u003e🌐 关于域名解析过程详解\u003c/a\u003e\u003c/p\u003e\n\u003ch3\u003e攻击方式\u003c/h3\u003e\n\u003cp\u003e那么如何才能够污染 DNS 以达成流量劫持的目的呢？粗略来说，一共有三种途径：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\u003cstrong\u003e在用户设备上动手\u003c/strong\u003e：这个主要是通过一些恶意软件实现的，比如早期一些流氓软件会在用户本机篡改 \u003ccode\u003ehosts\u003c/code\u003e 文件，影响用户的搜索引擎工作。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e污染中间链路设备\u003c/strong\u003e：由于 DNS 查询是基于 UDP 协议明文发送的，因此在任意中间设备上，比如路由器，进行中间人攻击，修改 UDP 包的内容，就可以影响 DNS 的结果了。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e入侵 DNS 服务器\u003c/strong\u003e：这是一种成本比较高的方案，看起来似乎很困难，但 DNS 是一种相对古老的技术，其服务软件的实现可能已经年久失修，别有用心的攻击者可以寻找一些缺乏维护的 DNS 服务器，施行攻击。另外，有时 DNS 服务器上不止运行 DNS 软件，还会有一些其他的软件也在运行，比如同时也启动了 HTTP 服务等，这时攻击者也可以通过这些软件的漏洞来控制服务器，进而影响 DNS 的解析。由于 DNS 的缓存和上下传递关系，一旦有 DNS 服务器被影响，就会一次影响很多用户的访问，因此非常危险。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e这三种途径当中，第一种和第三种的实施成本都比较高，但污染链路设备，在 Wi-Fi 普及而安全意识尚未普及的今天，是最容易得手的一种途径。\u003c/p\u003e\n\u003ch3\u003e防御策略\u003c/h3\u003e\n\u003cp\u003e目前针对 DNS 投毒，对抗中间人攻击的研究比较多。DNS 协议本身的安全性较差，而改造 DNS 协议又比较困难，因此现在主要的防御手段，集中在替换 UDP 协议上。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eTLS（Cloudflare）\u003c/li\u003e\n\u003cli\u003eHTTP（腾讯云、阿里云）\u003c/li\u003e\n\u003cli\u003eHTTPS（Cloudflare、Google）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e目前，三种常见的替代方式比较流行：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003eDNS over TLS。这种协议是在 TLS 协议之上传输 DNS 内容，有点类似 HTTPS 和 TLS 关系。\u003c/li\u003e\n\u003cli\u003eDNS over HTTP。用 HTTP 协议来传输 DNS ，也是可以的。国内厂商当中对这种方案的支持较多。最简单的实现是使用一个 固定的 IP 地址作为域名服务器，每次不发生 UDP ，而是向这台服务器发送 HTTP 请求来获取解析结果。但通常很难签发相应的证书给固定 IP，因此也有些厂商自己对 HTTP 报文进行加密，从而防止这些解析结果再被中间人篡改。\u003c/li\u003e\n\u003cli\u003eDNS over HTTPS。和第二点比较类似，区别是使用了 HTTPS 协议。根据我的观察，采用这种方案的 Google 和 Cloudflare 都使用的是域名而非固定 IP ，因此还是要先解析一次域名服务器自身的域名才可以进行真正的查询。这可能会导致再次被中间人扰乱，从而迫使用户降级到普通的 UDP 方式上。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e比较遗憾的是，由于浏览器没有暴露 DNS 相关的接口，这三种较为安全的 DNS 查询方式，都无法在前端当中得以使用。而 iOS 和 Android 开发者有机会使用其中的技术进行加强，但需要单独编写一些代码。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e打工信部电话（12300）投诉也不失是个好办法。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003eHTTP 劫持\u003c/h2\u003e\n\u003cp\u003eHTTP 协议属于明文协议，中间链路上的任意设备，都可以篡改内容，导致流量劫持。\u003c/p\u003e\n\u003ch3\u003e防御策略\u003c/h3\u003e\n\u003ch4\u003eContent Security Policy\u003c/h4\u003e\n\u003cp\u003eCSP 原本是为了和 XSS 对抗而产生的一种技术方案，其原理是在 HTML 加载的时候，指定每种资源的 URL 白名单规则，防止 XSS 的运行和数据外送。但如果巧妙利用规则，也可以让所有的资源强制走 HTTPS ，这样就可以降低流量劫持的可能性。\u003c/p\u003e\n\u003cp\u003e具体的 CSP 规则比较复杂，大家可以在 \u003ca href=\"https://content-security-policy.com/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003eCSP 专属网站\u003c/a\u003e上自己查看。\u003c/p\u003e\n\u003ch4\u003eSubresource Integrity\u003c/h4\u003e\n\u003cp\u003eSRI 是专门用来校验资源的一种方案，它读取资源标签中的 \u003ccode\u003eintegrity\u003c/code\u003e 属性，将其中的信息摘要值，和资源实际的信息摘要值进行对比，如果发现无法匹配，那么浏览器就会拒绝执行资源。对于 \u003ccode\u003e\u0026lt;script\u0026gt;\u003c/code\u003e 标签来说，就是拒绝执行其中的代码，对于 CSS 来说则是不加载其中的样式。\u003c/p\u003e\n\u003cp\u003e通过给 \u003ccode\u003elink\u003c/code\u003e 标签或者 \u003ccode\u003escript\u003c/code\u003e 标签增加 \u003ccode\u003eintegrity\u003c/code\u003e 属性即可开启 SRI 功能，比如：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;//s.url.cn/xxx/aaa.js\u0026quot;\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eintegrity\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;sha156-xxx sha384-yyy\u0026quot;\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ecrossorigin\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;anonymous\u0026quot;\u003c/span\u003e\n\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eintegrity\u003c/code\u003e 值分成两个部分，第一部分指定哈希值的生成算法（sha256、sha384 及 sha512），第二部分是经过 \u003ccode\u003ebase64\u003c/code\u003e 编码的实际哈希值，两者之间通过一个短横（\u003ccode\u003e-\u003c/code\u003e）分割。\u003ccode\u003eintegrity\u003c/code\u003e 值可以包含多个由空格分隔的哈希值，只要文件匹配其中任意一个哈希值，就可以通过校验并加载该资源。上述例子中我使用了 \u003ccode\u003esha256\u003c/code\u003e 和 \u003ccode\u003esha384\u003c/code\u003e 两种 \u003ccode\u003ehash\u003c/code\u003e 方案。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e备注：crossorigin=\u0026quot;anonymous\u0026quot; 的作用是引入跨域脚本，在 HTML5 中有一种方式可以获取到跨域脚本的错误信息，首先跨域脚本的服务器必须通过 Access-Controll-Allow-Origin 头信息允许当前域名可以获取错误信息，然后是当前域名的 \u003ccode\u003escript\u003c/code\u003e 标签也必须声明支持跨域，也就是 \u003ccode\u003ecrossorigin\u003c/code\u003e 属性。\u003ccode\u003elink\u003c/code\u003e、\u003ccode\u003eimg\u003c/code\u003e 等标签均支持跨域脚本。如果上述两个条件无法满足的话， 可以使用 \u003ccode\u003etry catch\u003c/code\u003e 方案。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e通过使用 webpack 的 \u003ccode\u003ehtml-webpack-plugin\u003c/code\u003e 和 \u003ccode\u003ewebpack-subresource-integrity\u003c/code\u003e 可以生成包含 \u003ccode\u003eintegrity\u003c/code\u003e 属性 \u003ccode\u003escript\u003c/code\u003e 标签。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSriPlugin\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;webpack-subresource-integrity\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e compiler = \u003cspan class=\"hljs-title function_\"\u003ewebpack\u003c/span\u003e({\n  \u003cspan class=\"hljs-attr\"\u003eoutput\u003c/span\u003e: {\n    \u003cspan class=\"hljs-attr\"\u003ecrossOriginLoading\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;anonymous\u0026#x27;\u003c/span\u003e,\n  },\n  \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e: [\n    \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSriPlugin\u003c/span\u003e({\n      \u003cspan class=\"hljs-attr\"\u003ehashFuncNames\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\u0026#x27;sha256\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;sha384\u0026#x27;\u003c/span\u003e],\n      \u003cspan class=\"hljs-attr\"\u003eenabled\u003c/span\u003e: process.\u003cspan class=\"hljs-property\"\u003eenv\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eNODE_ENV\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e\u0026#x27;production\u0026#x27;\u003c/span\u003e,\n    }),\n  ],\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e那么当 \u003ccode\u003escript\u003c/code\u003e 或者 \u003ccode\u003elink\u003c/code\u003e 资源 SRI 校验失败的时候应该怎么做呢？\u003c/p\u003e\n\u003cp\u003e比较好的方式是通过 \u003ccode\u003escript\u003c/code\u003e 的 \u003ccode\u003eonerror\u003c/code\u003e 事件，当遇到 \u003ccode\u003eonerror\u003c/code\u003e 的时候重新 \u003ccode\u003eload\u003c/code\u003e 静态文件服务器之间的资源：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;//11.url.cn/aaa.js\u0026quot;\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eintegrity\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;sha256-xxx sha384-yyy\u0026quot;\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ecrossorigin\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;anonymous\u0026quot;\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eonerror\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;loadScriptError.call(this, event)\u0026quot;\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eonsuccess\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;loadScriptSuccess\u0026quot;\u003c/span\u003e\n\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在此之前注入以下代码：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n\t\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eloadScriptError\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eevent\u003c/span\u003e) {\n\t\t\u003cspan class=\"hljs-comment\"\u003e// 上报\u003c/span\u003e\n\t\t...\n\t\t\u003cspan class=\"hljs-comment\"\u003e// 重新加载 js\u003c/span\u003e\n\t\t\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eresolve, reject\u003c/span\u003e) {\n\t\t\t\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e script = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateElement\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;script\u0026#x27;\u003c/span\u003e)\n\t\t\tscript.\u003cspan class=\"hljs-property\"\u003esrc\u003c/span\u003e = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esrc\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/\\/\\/11.src.cn/\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;https://x.y.z\u0026#x27;\u003c/span\u003e) \u003cspan class=\"hljs-comment\"\u003e// 替换 cdn 地址为静态文件服务器地址\u003c/span\u003e\n\t\t\tscript.\u003cspan class=\"hljs-property\"\u003eonload\u003c/span\u003e = resolve\n\t\t\tscript.\u003cspan class=\"hljs-property\"\u003eonerror\u003c/span\u003e = reject\n\t\t\tscript.\u003cspan class=\"hljs-property\"\u003ecrossOrigin\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;anonymous\u0026#x27;\u003c/span\u003e\n\t\t\t\u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementsByTagName\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;head\u0026#x27;\u003c/span\u003e)[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eappendChild\u003c/span\u003e(script)\n\t\t})\n\t}\n\t\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eloadScriptSuccess\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n\t\t\u003cspan class=\"hljs-comment\"\u003e// 上报\u003c/span\u003e\n\t\t...\n\t}\n\t\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eloadScriptError\u003c/span\u003e = loadScriptError\n\t\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eloadScriptSuccess\u003c/span\u003e = loadScriptSuccess\n})()\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e比较痛苦的是 \u003ccode\u003eonerror\u003c/code\u003e 中的 \u003ccode\u003eevent\u003c/code\u003e 中无法区分究竟是什么原因导致的错误，可能是资源不存在，也可能是 SRI 校验失败，当然出现最多的还是请求超时，不过目前来看，除非有统计需求，无差别对待并没有多大问题。\u003c/p\u003e\n\u003cp\u003e注入 \u003ccode\u003eonerror\u003c/code\u003e 事件\u003c/p\u003e\n\u003cp\u003e当然，由于项目中的 \u003ccode\u003escript\u003c/code\u003e 标签是由 webpack 打包进去的，所以我们要使用 \u003ccode\u003escript-ext-html-webpack-plugin\u003c/code\u003e 将 \u003ccode\u003eonerror\u003c/code\u003e 事件和 \u003ccode\u003eonsuccess\u003c/code\u003e 事件注入进去：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eScriptExtHtmlWebpackPlugin\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;script-ext-html-webpack-plugin\u0026#x27;\u003c/span\u003e);\n\n\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-comment\"\u003e//...\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003eplugins\u003c/span\u003e: [\n    \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eHtmlWebpackPlugin\u003c/span\u003e(),\n    \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eSriPlugin\u003c/span\u003e({\n      \u003cspan class=\"hljs-attr\"\u003ehashFuncNames\u003c/span\u003e: [\u003cspan class=\"hljs-string\"\u003e\u0026#x27;sha256\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;sha384\u0026#x27;\u003c/span\u003e],\n    }),\n    \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eScriptExtHtmlWebpackPlugin\u003c/span\u003e({\n      \u003cspan class=\"hljs-attr\"\u003ecustom\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003etest\u003c/span\u003e: \u003cspan class=\"hljs-regexp\"\u003e/\\/*_[A-Za-z0-9]{8}.js/\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003eattribute\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;onerror\u0026#x27;\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;loadScriptError.call(this, event)\u0026#x27;\u003c/span\u003e,\n      },\n    }),\n    \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eScriptExtHtmlWebpackPlugin\u003c/span\u003e({\n      \u003cspan class=\"hljs-attr\"\u003ecustom\u003c/span\u003e: {\n        \u003cspan class=\"hljs-attr\"\u003etest\u003c/span\u003e: \u003cspan class=\"hljs-regexp\"\u003e/\\/*_[A-Za-z0-9]{8}.js/\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003eattribute\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;onsuccess\u0026#x27;\u003c/span\u003e,\n        \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;loadScriptSuccess.call(this, event)\u0026#x27;\u003c/span\u003e,\n      },\n    }),\n  ],\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e然后将 \u003ccode\u003eloadScriptError\u003c/code\u003e 和 \u003ccode\u003eloadScriptSuccess\u003c/code\u003e 两个方法注入到 HTML 中，可以使用 \u003ccode\u003einline\u003c/code\u003e 的方式。\u003c/p\u003e\n\u003ch2\u003eCDN 劫持\u003c/h2\u003e\n\u003cp\u003e前面说到 script 加载失败可能是由于多种原因造成的，那如何是否判断发生了 CDN 劫持呢？\u003c/p\u003e\n\u003cp\u003e方法就是再请求一次数据，比较两次得到文件的内容（当然不必全部比较），如果内容不一致，就可以得出结论了。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eloadScript\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eurl\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(url)\n    .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (res.\u003cspan class=\"hljs-property\"\u003eok\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res;\n      }\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ereject\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e());\n    })\n    .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e res.\u003cspan class=\"hljs-title function_\"\u003etext\u003c/span\u003e();\n    })\n    .\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026#x27;\u003c/span\u003e;\n    });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e比较两次加载的 \u003ccode\u003escript\u003c/code\u003e 是否相同\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003echeckScriptDiff\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003esrc, srcNew\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e([\u003cspan class=\"hljs-title function_\"\u003eloadScript\u003c/span\u003e(src), \u003cspan class=\"hljs-title function_\"\u003eloadScript\u003c/span\u003e(srcNew)])\n    .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e res1 = data[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eslice\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n      \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e res2 = data[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eslice\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!!res1 \u0026amp;\u0026amp; !!res2 \u0026amp;\u0026amp; res1 !== res2) {\n        \u003cspan class=\"hljs-comment\"\u003e// CDN劫持事件发生\u003c/span\u003e\n      }\n    })\n    .\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n      \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n    });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里为什么只比较前 1000 个字符？因为通常 CDN 劫持者会在 js 文件最前面注入一些代码来达到他们的目的，注入中间代码需要 AST 解析，成本较高，所以比较全部字符串没有意义。如果你还是有顾虑的话，可以加上后 n 个字符的比较。\u003c/p\u003e\n\u003ch2\u003e参考资料\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📖 MDN：Subresource Integrity\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.im/entry/5a559dd36fb9a01c9e45d896\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 常见 Web 安全攻防总结\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.im/entry/5bcec8e2518825102423e391\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 浅谈流量劫持与防治\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.im/post/5c355a816fb9a049a42f3ac8\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 腾讯 IVWEB 团队：使用 SRI 解决 CDN 劫持\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.zhihu.com/question/35720092\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 应对流量劫持，前端能做哪些工作？\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://js8.in/2017/08/04/Web%E5%89%8D%E7%AB%AF%E9%A1%B5%E9%9D%A2%E5%8A%AB%E6%8C%81%E5%92%8C%E5%8F%8D%E5%8A%AB%E6%8C%81/#more\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 Web 前端页面劫持和反劫持\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"markdown-body\",\"children\":[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"front-end\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"front-end knowledge\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>