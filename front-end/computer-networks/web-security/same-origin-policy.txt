1:"$Sreact.fragment"
2:I[5244,[],""]
3:I[3866,[],""]
5:I[6213,[],"OutletBoundary"]
7:I[6213,[],"MetadataBoundary"]
9:I[6213,[],"ViewportBoundary"]
b:I[4835,[],""]
:HL["/_next/static/media/569ce4b8f30dc480-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/d4dd73d504c89c58.css","style"]
:HL["/_next/static/css/485ff6fe79292a08.css","style"]
:HL["/_next/static/css/0ff121a467c0636f.css","style"]
0:{"P":null,"b":"1zJy3VHENUSg9vzcRvJ6P","p":"","c":["","front-end","computer-networks","web-security","same-origin-policy"],"i":false,"f":[[["",{"children":["front-end",{"children":[["slug","computer-networks/web-security/same-origin-policy","oc"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/d4dd73d504c89c58.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__variable_4d318d __variable_ea5f4b antialiased","children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[],[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]]}],{"children":["front-end",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/485ff6fe79292a08.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/0ff121a467c0636f.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","main",null,{"children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","front-end","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]}]]}],{"children":[["slug","computer-networks/web-security/same-origin-policy","oc"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","front-end","children","$0:f:0:1:2:children:2:children:0","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L4",null,["$","$L5",null,{"children":"$L6"}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","iEyrn2WfZiecOF0j2pH6D",{"children":[["$","$L7",null,{"children":"$L8"}],["$","$L9",null,{"children":"$La"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}]]}],false]],"m":"$undefined","G":["$b","$undefined"],"s":false,"S":true}
c:T9458,<h1>同源策略</h1>
<p><strong>同源策略</strong>限制从一个源加载的文档或脚本如何与来自另一个源的资源进行交互，这是一个用于隔离潜在恶意文件的关键的安全机制。</p>
<p>同源需要满足以下三个方面：</p>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同</li>
</ul>
<p>以 <code>http://www.a.com</code> 为例</p>
<ul>
<li><code>http://www.a.com/foo</code> 同源</li>
<li><code>http://a.com/foo</code> 不同源（域名不同）</li>
<li><code>http://a.edu/foo</code> 不同源（域名不同）</li>
<li><code>http://b.a.com/foo</code> 不同源（域名不同）</li>
<li><code>http://a.com:81/foo</code> 不同源（端口不同）</li>
<li><code>https://a.com/foo</code> 不同源（协议不同）</li>
</ul>
<p>如果是非同源，则以下行为会受到限制：</p>
<ul>
<li>Cookie、LocalStorage 和 IndexDB 无法读取</li>
<li>DOM 无法获取</li>
<li>AJAX 请求不能发送</li>
</ul>
<p><strong>为什么要实现跨域请求？</strong></p>
<p>工程服务化后，不同职责的服务分散在不同的工程中，往往这些工程的域名是不同的，但一个需求可能对应到多个服务，这时便需要调用不同服务的接口，因此会出现跨域。</p>
<p>同源策略仅存在于浏览器客户端，不存在 Android、iOS、NodeJS、Python、Java 等其他环境。</p>
<p>⚠️ <strong>注意</strong>：跨域请求能成功发送，服务端能接收请求并正常返回结果，只是结果被浏览器拦截了。</p>
<h2>跨源网络访问</h2>
<p>严格来说，浏览器并不是拒绝所有的跨域请求，实际上拒绝的是跨域的读操作。</p>
<p>同源策略控制了不同源之间的交互，这些交互通常分为三类：</p>
<ul>
<li>✅ 通常浏览器允许进行跨域 <strong>写操作</strong>（Cross-origin writes），如链接、重定向以及表单提交</li>
<li>✅ 通常浏览器允许跨域 <strong>资源嵌入</strong>（Cross-origin embedding），如 <code>img</code>、<code>script</code> 标签</li>
<li>❌ 通常浏览器不允许跨域 <strong>读操作</strong>（Cross-origin reads），但常可以通过内嵌资源来巧妙地进行读取访问。例如可以读取嵌套图片的高度和宽度，调用内嵌脚本的方法</li>
</ul>
<h2>解决方案</h2>
<ul>
<li>CORS 跨域资源共享</li>
<li>Node 代理跨域</li>
<li>Nginx 代理跨域</li>
<li>JSONP</li>
<li>WebSocket</li>
<li>window.postMessage</li>
<li>document.domain + iframe</li>
<li>window.location.hash + iframe</li>
<li>window.name + iframe</li>
</ul>
<h3>CORS</h3>
<p>CORS 亦即 <a href="/front-end/computer-networks/http/access-control">跨域资源共享</a>，是一种 HTTP 机制，它使用额外的 HTTP 响应头来告诉浏览器让其运行在一个 <code>origin</code> (<code>domain</code>) 上的 Web 应用被准许访问来自 <strong>不同源服务器</strong> 上的指定的资源。当一个资源从与该资源本身所在的服务器 <strong>不同的域、协议或端口</strong> 请求一个资源时，资源会发起一个 <strong>跨域 HTTP 请求</strong>。</p>
<p>值得注意的是，通常使用 CORS 时，异步请求会被分为<strong>简单请求</strong>和<strong>非简单请求</strong>，非简单请求的区别是会先发送一个 <strong>预检请求</strong>（Preflight Request）。</p>
<p><strong>服务器预检请求 / 响应头</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">响应头</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>Access-Control-Allow-Headers</code></td>
<td style="text-align:left">请求头，响应头，预请求（携带 Cookie 情况下不能为 <code>*</code>）</td>
</tr>
<tr>
<td style="text-align:left"><code>Access-Control-Allow-Methods</code></td>
<td style="text-align:left">请求头，响应头，预请求（携带 Cookie 情况下不能为 <code>*</code>）</td>
</tr>
<tr>
<td style="text-align:left"><code>Access-Control-Allow-Origin</code></td>
<td style="text-align:left">响应头，预请求 / 正常请求（携带 Cookie 情况下不能为 <code>*</code>）</td>
</tr>
<tr>
<td style="text-align:left"><code>Access-Control-Allow-Credentials</code></td>
<td style="text-align:left">响应头，预请求/正常请求（携带 Cookie 情况下要设置为 <code>true</code>）</td>
</tr>
<tr>
<td style="text-align:left"><code>Access-Control-Max-Age</code></td>
<td style="text-align:left">响应头，预请求（单位 <code>s</code>）</td>
</tr>
</tbody>
</table>
<p><code>Access-Control-Allow-Origin</code> 只能阻止浏览器端拿到服务器返回数据，服务端的处理还是会执行，要配合 <code>token</code> 鉴权令牌等策略来防范。</p>
<p>💡 实现细节请参考 <a href="/front-end/computer-networks/http/access-control">HTTP 跨域资源共享</a></p>
<h4>原生实现</h4>
<p>在 Node.js 中 <code>CORS</code> 的实现：</p>
<pre class="hljs"><code class="language-js">app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx, next) =&gt; {
  ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, ctx.<span class="hljs-property">headers</span>.<span class="hljs-property">origin</span>);
  ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="hljs-literal">true</span>);
  ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Access-Control-Request-Method&#x27;</span>, <span class="hljs-string">&#x27;PUT,POST,GET,DELETE,OPTIONS&#x27;</span>);
  ctx.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="hljs-string">&#x27;Origin, X-Requested-With, Content-Type, Accept, cc&#x27;</span>);
});
</code></pre>
<h4>第三方中间件</h4>
<p>以 Koa 为例子，解禁指定域名的跨域请求问题：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);
<span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa2-cors&#x27;</span>); <span class="hljs-comment">// 使用插件解决跨域处理</span>

<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();

app.<span class="hljs-title function_">use</span>(
  <span class="hljs-title function_">cors</span>({
    <span class="hljs-attr">origin</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">ctx</span>) {
      <span class="hljs-keyword">if</span> (ctx.<span class="hljs-property">url</span> === <span class="hljs-string">&#x27;/login&#x27;</span>) {
        <span class="hljs-comment">// 允许来自所有域名的请求</span>
        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;*&#x27;</span>;
      }

      <span class="hljs-comment">// 只允许 http://localhost:8080 这个域名的请求</span>
      <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;http://localhost:8080&#x27;</span>;
    },
    <span class="hljs-comment">// 指定本次预检请求的有效期，单位为秒</span>
    <span class="hljs-attr">maxAge</span>: <span class="hljs-number">5</span>,
    <span class="hljs-comment">// 是否允许发送 Cookie</span>
    <span class="hljs-attr">credentials</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-comment">// 设置所允许的 HTTP 请求方法</span>
    <span class="hljs-attr">allowMethods</span>: [<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;POST&#x27;</span>, <span class="hljs-string">&#x27;PUT&#x27;</span>, <span class="hljs-string">&#x27;DELETE&#x27;</span>, <span class="hljs-string">&#x27;OPTIONS&#x27;</span>],
    <span class="hljs-comment">// 设置服务器支持的所有头信息字段</span>
    <span class="hljs-attr">allowHeaders</span>: [<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;Authorization&#x27;</span>, <span class="hljs-string">&#x27;Accept&#x27;</span>],
    <span class="hljs-comment">// 设置获取其他自定义字段</span>
    <span class="hljs-attr">exposeHeaders</span>: [<span class="hljs-string">&#x27;WWW-Authenticate&#x27;</span>, <span class="hljs-string">&#x27;Server-Authorization&#x27;</span>],
  })
);
</code></pre>
<blockquote>
<p><a href="https://github.com/zadzbw/koa2-cors" target="_blank" rel="noopener noreferrer nofollow">koa2-cors</a> 内部实现请参照源码。</p>
</blockquote>
<h4>关于 Cookie 问题</h4>
<p>要传递 Cookie 需要满足三个条件：</p>
<ol>
<li>Web 请求设置 <code>withCredentials</code></li>
</ol>
<p>这里默认情况下在跨域请求，浏览器是不带 Cookie 的。但是我们可以通过设置 <code>withCredentials</code> 来进行传递 Cookie。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 原生 XMLHttpRequest 的设置方式</span>
<span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XHRHttpRequest</span>();
xhr.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;

<span class="hljs-comment">// Axios 设置方式</span>
axios.<span class="hljs-property">default</span>.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;
</code></pre>
<ol start="2">
<li><code>Access-Control-Allow-Credentials</code> 为 <code>true</code></li>
<li><code>Access-Control-Allow-Origin</code> 为非 <code>*</code></li>
</ol>
<p>这里的请求方式，在 Chrome 中是能看到返回值的，但是只要不满足以上其一，浏览器会报错，无法获取数据。</p>
<h3>Node 代理</h3>
<p>利用 Node + Express + Http-Proxy-Middleware 搭建一个 Proxy 服务器。</p>
<p><strong>前端实现</strong></p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();

<span class="hljs-comment">// 前端开关：浏览器是否读写cookie</span>
xhr.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;

<span class="hljs-comment">// 访问http-proxy-middleware代理服务器</span>
xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;http://www.domain1.com:3000/login?user=admin&#x27;</span>, <span class="hljs-literal">true</span>);
xhr.<span class="hljs-title function_">send</span>();
</code></pre>
<p><strong>服务器实现</strong></p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);
<span class="hljs-keyword">const</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();

app.<span class="hljs-title function_">use</span>(
  <span class="hljs-string">&#x27;/&#x27;</span>,
  <span class="hljs-title function_">proxy</span>({
    <span class="hljs-comment">// 代理跨域目标接口</span>
    <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://www.domain2.com:8080&#x27;</span>,
    <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,

    <span class="hljs-comment">// 修改响应头信息，实现跨域并允许带cookie</span>
    <span class="hljs-attr">onProxyRes</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">proxyRes, req, res</span>) {
      res.<span class="hljs-title function_">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;http://www.domain1.com&#x27;</span>);
      res.<span class="hljs-title function_">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="hljs-string">&#x27;true&#x27;</span>);
    },

    <span class="hljs-comment">// 修改响应信息中的cookie域名</span>
    <span class="hljs-attr">cookieDomainRewrite</span>: <span class="hljs-string">&#x27;www.domain1.com&#x27;</span>, <span class="hljs-comment">// 可以为false，表示不修改</span>
  })
);

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Proxy server is listen at port 3000...&#x27;</span>);
</code></pre>
<p>本质上与 CORS 中列举的 Koa 的例子的原理是一样的，就是解除 CORS 的限制，但这里更强调的是开发时与后端接口联调的场景使用，即启动前端项目的同时，也启动一个开发本地的 Node 代理服务用于转发客户端向服务端发起的请求。</p>
<h3>Nginx 反向代理</h3>
<p>Nginx 可实现用于反向代理的异步 Web 服务器，他除了用于反向代理以外还可以用于负载均衡、 HTTP 缓存。</p>
<pre class="hljs"><code class="language-nginx"><span class="hljs-section">http</span> {
  <span class="hljs-attribute">include</span>               mime.types;
  <span class="hljs-attribute">default_type</span>          application/octet-stream;
  <span class="hljs-attribute">client_max_body_size</span>  <span class="hljs-number">2000M</span>;
  <span class="hljs-attribute">keepalive_timeout</span>     <span class="hljs-number">65</span>;

  <span class="hljs-comment"># 虚拟服务器</span>
  <span class="hljs-section">server</span> {
    <span class="hljs-attribute">listen</span>       <span class="hljs-number">8080</span>;
    <span class="hljs-attribute">server_name</span>  localhost;

    <span class="hljs-comment"># CORS 设置</span>
    <span class="hljs-comment"># 指定响应资源是否允许与给定的 origin 共享</span>
    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Origin *;
    <span class="hljs-comment"># 配置是否允许将对请求的响应暴露给页面</span>
    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Credentials <span class="hljs-string">&#x27;true&#x27;</span>;
    <span class="hljs-comment"># 配置允许跨域的请求头</span>
    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Headers <span class="hljs-string">&#x27;Authorization,Content-Type,Accept,Origin,User-Agent,Cache-Control,X-Mx-ReqToken,X-Requested-With&#x27;</span>;
    <span class="hljs-comment"># 配置允许跨域的请求方法</span>
    <span class="hljs-attribute">add_header</span> Access-Control-Allow-Methods <span class="hljs-string">&#x27;GET,POST,Options&#x27;</span>;

    <span class="hljs-comment"># 跳过服务端校验，直接返回 200</span>
    <span class="hljs-attribute">if</span> (<span class="hljs-variable">$request_method</span> = <span class="hljs-string">&#x27;OPTIONS&#x27;</span>) {
      <span class="hljs-attribute">return</span> <span class="hljs-number">200</span>;
    }

    <span class="hljs-section">location</span> / {
        <span class="hljs-attribute">root</span>        /data/example/dist;
        <span class="hljs-attribute">index</span>       index.html index.htm;
        <span class="hljs-attribute">try_files</span>   <span class="hljs-variable">$uri</span> /index.html;
        <span class="hljs-attribute">add_header</span>  Cache-Control <span class="hljs-string">&quot;private, no-store, no-cache, must-revalidate, proxy-revalidate&quot;</span>;
    }

    <span class="hljs-section">location</span> /api/ {
        <span class="hljs-attribute">proxy_pass</span>  https://xxx.xxx.xxx/req/;
    }
  }
}
</code></pre>
<ul>
<li>对于简单请求，如 GET，只需要在 HTTP Response 后添加 Access-Control-Allow-Origin</li>
<li>对于非简单请求，如 POST、PUT、DELETE 等，浏览器会分两次应答。第一次 Preflight（<code>method: OPTIONS</code>），主要验证来源是否合法，并返回允许的 <code>Headers</code> 等；第二次才是真正的 HTTP 应答，所以服务器必须处理 <code>OPTIONS</code> 应答。</li>
</ul>
<p>由于浏览器第一次 Preflight 预检，导致服务端对其请求进行校验，但是服务端本身没有开启 CORS，所以会导致服务端返回 405 Method Not Allowed 或者 403 Forbidden。所以我们需要在 Nginx 对该请求进行拦截，直接返回 200，跳过服务端校验。</p>
<h3>JSONP</h3>
<p><strong>实现原理</strong></p>
<p>动态创建 <code>&lt;script&gt;</code> 脚本标签，通过跨域脚本嵌入不受同源策略限制的方法实现请求第三方服务器数据内容。除了适用于 <code>&lt;script&gt;</code> 脚本标签，HTML 中包含 <code>src</code> 和 <code>href</code> 属性的标签均不受同源策略限制。</p>
<p><strong>实现步骤</strong></p>
<ol>
<li>动态创建 <code>&lt;script&gt;</code> 标签</li>
<li>标签 <code>src</code> 属性设置接口地址</li>
<li>接口参数，必须要带一个自定义函数名，要不然后台无法返回数据，通常为 <code>callback</code> 或 <code>cb</code></li>
<li>通过定义函数名去接收后台返回数据</li>
</ol>
<p>前端实现：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 动态创建脚本标签</span>
<span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);

<span class="hljs-comment">// 设置接口地址</span>
script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://localhost:8080/api/jsonp?cb=jsonpCallback&#x27;</span>;

<span class="hljs-comment">// 插入页面</span>
<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">appendChild</span>(script);

<span class="hljs-comment">// 通过定义回调函数接收响应数据</span>
<span class="hljs-variable language_">window</span>.<span class="hljs-property">jsonpCallback</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">res</span>) {
  <span class="hljs-comment">// do something with response data</span>
};
</code></pre>
<p>后端实现：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">Koa</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;koa&#x27;</span>);
<span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);
<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Koa</span>();

app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">async</span> (ctx, next) =&gt; {
  <span class="hljs-keyword">if</span> (ctx.<span class="hljs-property">path</span> === <span class="hljs-string">&#x27;/api/jsonp&#x27;</span>) {
    <span class="hljs-keyword">const</span> { cb } = ctx.<span class="hljs-property">query</span>;
    ctx.<span class="hljs-property">body</span> = <span class="hljs-string">`<span class="hljs-subst">${cb}</span>(<span class="hljs-subst">${<span class="hljs-built_in">JSON</span>.stringify({ msg })}</span>)`</span>;
    <span class="hljs-keyword">return</span>;
  }
});

app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">8080</span>);
</code></pre>
<p>由于 <code>&lt;script&gt;</code> 元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了回调函数，该函数就会立即调用。作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用 <code>JSON.parse</code> 的步骤。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>非常高的跨站脚本攻击风险</li>
<li>只能实现 GET 请求</li>
<li>接口出现错误时，很难进行错误识别处理</li>
</ul>
<h3>WebSocket</h3>
<p>WebSocket 是一种通信协议，使用 <code>ws://</code>（非加密）和 <code>wss://</code>（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p>
<p>简单来说，WebSocket 通过客户端和服务端之间建立持久的连接，双方可以随时发送数据。</p>
<p>这种方式本质上没有使用 HTTP 协议进行通信，因此也没有浏览器跨域的限制。</p>
<p>前端部分：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> socket = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>(<span class="hljs-string">&#x27;ws://localhost:8080&#x27;</span>);

socket.<span class="hljs-property">onopen</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  socket.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;Client Socket is openning&#x27;</span>);
};

socket.<span class="hljs-property">onmessage</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>);
};
</code></pre>
<p>后端部分：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">WebSocket</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;ws&#x27;</span>);
<span class="hljs-keyword">const</span> server = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WebSocket</span>.<span class="hljs-title class_">Server</span>({ <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span> });

server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">socket</span>) {
  socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) {
    socket.<span class="hljs-title function_">send</span>(data);
  });
});
</code></pre>
<p>💡 实现细节请参考 <a href="/front-end/html5-scripting-programming/connectivity/web-socket">WebSocket</a></p>
<h3>window.postMessage</h3>
<p>通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为 HTTPS），端口号（443 为 HTTPS 的默认值），以及主机（两个页面的模数 <code>document.domain</code> 设置为相同的值）时，这两个脚本才能相互通信。<code>window.postMessage</code> 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。</p>
<p><code>window.postMessage(message, targetOrigin)</code> 方法是 HTML5 新引进的特性，可以使用它向其他的 <code>window</code> 对象发送消息，无论这个 <code>window</code> 对象是属于同源或不同源，目前 IE8+、Firefox、Chrome、Opera 等浏览器都已经支持该方法。</p>
<p><strong>用途：</strong></p>
<ol>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间消息传递</li>
<li>页面与嵌套的 iframe 消息传递</li>
</ol>
<pre class="hljs"><code class="language-js">otherWindow.<span class="hljs-title function_">postMessage</span>(message, targetOrigin, [transfer]);
</code></pre>
<ul>
<li><code>otherWindow</code>：其他窗口的一个引用，比如 iframe 的 <code>contentWindow</code> 属性、执行 <code>window.open</code> 返回的窗口、或者是命名过或数值索引的 <code>window.iframes</code></li>
<li><code>message</code>：将要发送到其他 <code>window</code> 的数据</li>
<li><code>targetOrigin</code>：通过窗口的 <code>origin</code> 属性来指定哪些窗口能接收到消息事件</li>
<li><code>transfer</code>（可选）：是一串和 <code>message</code> 同时传递的 Transferable 对象，这些对象的所有权将被转移给消息的接收方，而发送一方将不再保有所有权</li>
</ul>
<p>发送端页面：</p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iframe&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:8080/&quot;</span> <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;load()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/javascript&quot;</span>&gt;</span><span class="language-javascript">
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">load</span>(<span class="hljs-params"></span>) {
    iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-string">&#x27;Hello world!&#x27;</span>, <span class="hljs-string">&#x27;http://localhost:8080/&#x27;</span>);

    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>);
    };
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>接收端页面：</p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/javascript&quot;</span>&gt;</span><span class="language-javascript">
  <span class="hljs-variable language_">window</span>.<span class="hljs-property">onmessage</span> = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">data</span>);
    <span class="hljs-comment">// Hello world!</span>
    e.<span class="hljs-property">source</span>.<span class="hljs-title function_">postMessage</span>(e.<span class="hljs-property">data</span>, e.<span class="hljs-property">origin</span>);
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>💡 实现细节请参考 <a href="/front-end/browser-object-model/connectivity/post-message">PostMessage</a></p>
<h3>document.domain + iframe</h3>
<p>Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。</p>
<p>但是，两个网页一级域名相同，只是二级域名不同，浏览器只需要设置 <code>document.domain</code> 为更高级别的域就能实现 Cookie 共享。</p>
<p>🌰 <strong>代码示例</strong></p>
<p>以 <code>a.foo.com</code> 和 <code>b.foo.com</code> 为例，只要设置相同的 <code>document.domain</code>，两个网页就可以共享 Cookie。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-variable language_">document</span>.<span class="hljs-property">domain</span> = <span class="hljs-string">&#x27;foo.com&#x27;</span>;
</code></pre>
<p>⚠️ <strong>注意</strong>：这种方法只适用于 Cookie 和 iframe 窗口，localStorage 和 IndexDB 无法通过这种方法，规避同源策略，需要采用下文提及的 <a href="/front-end/computer-networks/web-security/#postMessage">PostMessage API</a>。</p>
<p>另外，服务器也可以在设置 Cookie 的时候，指定 Cookie 的所属域名为一级域名。</p>
<pre class="hljs"><code class="language-http"><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>key=value; domain=.example; path=/
</code></pre>
<p>那么，二级域名和三级域名不用做任何设置，都可以读取这个 Cookie。</p>
<h3>window.location.hash + iframe</h3>
<p>如果两个网页不同源，就无法拿到对方的 DOM。典型的例子是 <code>iframe</code> 窗口和 <code>window.open</code> 方法打开的窗口，它们与父窗口无法通信。</p>
<p>通过 <code>url</code> 带 <code>hash</code> 锚点，可以通过一个非跨域的中间页面来传递数据。</p>
<p><strong>实现流程</strong></p>
<p>一开始 <code>a.html</code> 给 <code>c.html</code> 传一个 hash 值，然后 <code>c.html</code> 收到 hash 值后，再把 hash 值传递给 <code>b.html</code>，最后 <code>b.html</code> 将结果放到 <code>a.html</code> 的 hash 值中。同样的，<code>a.html</code> 和 <code>b.html</code> 是同域的，都是 <code>http://localhost:8000/</code>，而 <code>c.html</code> 是 <code>http://localhost:8080/</code>。</p>
<p><code>a.html</code>：</p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:8080/hash/c.html#param1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/javascript&quot;</span>&gt;</span><span class="language-javascript">
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">hash</span>);

  <span class="hljs-variable language_">window</span>.<span class="hljs-property">onhashchange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">hash</span>);
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p><code>b.html</code>：</p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/javascript&quot;</span>&gt;</span><span class="language-javascript">
  <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-property">parent</span>.<span class="hljs-property">location</span>.<span class="hljs-property">hash</span> = location.<span class="hljs-property">hash</span>;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p><code>c.html</code>：</p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/javascript&quot;</span>&gt;</span><span class="language-javascript">
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(location.<span class="hljs-property">hash</span>);

  <span class="hljs-keyword">const</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);

  iframe.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://localhost:8000/hash/b.html#name2&#x27;</span>;

  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(iframe);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h3>window.name + iframe</h3>
<p><code>window</code> 对象的 <code>name</code> 属性是一个很特别的属性，当该 <code>window</code> 的 <code>location</code> 变化，然后重新加载，它的 <code>name</code> 属性可以依然保持不变。</p>
<p>其中 <code>a.html</code> 和 <code>b.html</code> 是同域的，都是 <code>http://localhost:8000/</code>，而 <code>c.html</code> 是 <code>http://localhost:8080/</code>。</p>
<p><code>a.html</code>：</p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span>
  <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iframe&quot;</span>
  <span class="hljs-attr">frameborder</span>=<span class="hljs-string">&quot;0&quot;</span>
  <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://localhost:8080/name/c.html&quot;</span>
  <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;load()&quot;</span>
&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/javascript&quot;</span>&gt;</span><span class="language-javascript">
  <span class="hljs-keyword">let</span> first = <span class="hljs-literal">true</span>;
  <span class="hljs-comment">// onload 事件会触发 2 次，第 1 次加载跨域页，并留存数据于 window.name</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">load</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (first) {
      <span class="hljs-comment">// 第 1 次 onload（跨域页）成功后，切换到同域代理页面</span>
      iframe.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://localhost:8000/name/b.html&#x27;</span>;
      first = <span class="hljs-literal">false</span>;
    } <span class="hljs-keyword">else</span> {
      <span class="hljs-comment">// 第 2 次 onload（同域 b.html 页）成功后，读取同域 window.name 中数据</span>
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-property">name</span>);
    }
  }
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p><code>b.html</code> 为中间代理页，与 <code>a.html</code> 同域，内容为空。</p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
</code></pre>
<p><code>c.html</code>：</p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;application/javascript&quot;</span>&gt;</span><span class="language-javascript">
  <span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<h2>阻止跨源访问</h2>
<ul>
<li>阻止跨域写操作，只要检测请求中的一个不可测的标记（CSRF token）即可，这个标记被称为 <a href="https://www.owasp.org/index.php/Cross-Site_Request_Forgery_%28CSRF%29" target="_blank" rel="noopener noreferrer nofollow">Cross-Site Request Forgery (CSRF)</a> 标记。必须使用这个标记来阻止页面的跨站读操作。</li>
<li>阻止跨站嵌入，需要确保你的资源不能是以上列出的可嵌入资源格式。多数情况下浏览器都不会遵守 <code>Content-Type</code> 消息头。例如，如果您在 HTML 文档中指定 <code>&lt;script&gt;</code> 标记，则浏览器将尝试将 HTML 解析为 JavaScript。 当您的资源不是您网站的入口点时，您还可以使用 CSRF 令牌来防止嵌入。</li>
<li>阻止资源的跨站读取，需要保证该资源是不可嵌入的。阻止嵌入行为是必须的，因为嵌入资源通常向其暴露信息。</li>
</ul>
<h2>参考资料</h2>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener noreferrer nofollow">📖 MDN: 浏览器的同源策略</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener noreferrer nofollow">📝 浏览器同源政策及其规避方法</a></li>
<li><a href="https://juejin.im/post/5a6320d56fb9a01cb64ee191" target="_blank" rel="noopener noreferrer nofollow">📝 我知道的跨域与安全</a></li>
<li><a href="https://mp.weixin.qq.com/s/Nk8YPYQDUJOKgQ9Qa7byag" target="_blank" rel="noopener noreferrer nofollow">📝 10 种跨域解决方案（附终极方案）</a></li>
</ul>
4:["$","div",null,{"className":"markdown-body","children":["$","article",null,{"dangerouslySetInnerHTML":{"__html":"$c"}}]}]
a:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
8:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"front-end"}],["$","meta","2",{"name":"description","content":"front-end knowledge"}],["$","link","3",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
6:null
