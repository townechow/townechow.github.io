1:"$Sreact.fragment"
2:I[5244,[],""]
3:I[3866,[],""]
5:I[6213,[],"OutletBoundary"]
7:I[6213,[],"MetadataBoundary"]
9:I[6213,[],"ViewportBoundary"]
b:I[4835,[],""]
:HL["/_next/static/media/569ce4b8f30dc480-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/d4dd73d504c89c58.css","style"]
:HL["/_next/static/css/485ff6fe79292a08.css","style"]
:HL["/_next/static/css/0ff121a467c0636f.css","style"]
0:{"P":null,"b":"1zJy3VHENUSg9vzcRvJ6P","p":"","c":["","front-end","basic-concept","data-types","type-conversion"],"i":false,"f":[[["",{"children":["front-end",{"children":[["slug","basic-concept/data-types/type-conversion","oc"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/d4dd73d504c89c58.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__variable_4d318d __variable_ea5f4b antialiased","children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[],[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]]}],{"children":["front-end",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/485ff6fe79292a08.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/0ff121a467c0636f.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","main",null,{"children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","front-end","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]}]]}],{"children":[["slug","basic-concept/data-types/type-conversion","oc"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","front-end","children","$0:f:0:1:2:children:2:children:0","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L4",null,["$","$L5",null,{"children":"$L6"}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","T9pRqtx2cfbinjHhBBCtV",{"children":[["$","$L7",null,{"children":"$L8"}],["$","$L9",null,{"children":"$La"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}]]}],false]],"m":"$undefined","G":["$b","$undefined"],"s":false,"S":true}
c:T84dc,<h1>类型转换</h1>
<p>JavaScript 作为一种弱类型的语言，不用像 C 语言那样要定义好数据类型，因为允许变量类型的 <strong>隐式类型转换</strong> 和允许 <strong>强制类型转换</strong>。我们在定义一个变量的时候，只需一个 <code>var</code>、<code>let</code>、<code>const</code> 搞定，不用担心数据的类型。</p>
<h2>基本规则</h2>
<p>从 ECMAScript Standard 中了解 Number、String、Boolean、Array 和 Object 之间的相互转换会更加直观。</p>
<h3>ToString</h3>
<blockquote>
<p>此处所说的 ToString 并非对象的 <code>toString()</code> 方法，而是指其他类型的值转换为字符串类型的操作。</p>
</blockquote>
<p>下面列出常见转换为 String 类型的规则：</p>
<ul>
<li><code>null</code>：转为 <code>&quot;null&quot;</code></li>
<li><code>undefined</code>：转为 <code>&quot;undefined&quot;</code></li>
<li>Boolean 类型：
<ul>
<li><code>true</code> 转为 <code>&quot;true&quot;</code></li>
<li><code>false</code> 转为 <code>&quot;false&quot;</code></li>
</ul>
</li>
<li>Number 类型：转为数字的字符串形式
<ul>
<li>如 <code>10</code> 转为 <code>&quot;10&quot;</code></li>
<li><code>1e21</code> 转为 <code>&quot;1e+21&quot;</code></li>
</ul>
</li>
<li>Array 类型：转为字符串将各元素以小写逗号 <code>,</code> 连接，相当于调用数组 <code>Array.prototype.join()</code> 方法
<ul>
<li>空数组转为空字符串 <code>''</code></li>
<li>数组中 <code>null</code> 和 <code>undefined</code> 会被当作 <strong>空字符串</strong> 处理</li>
</ul>
</li>
<li>普通对象：转为字符串相当于直接使用 <code>Object.prototype.toString()</code>，返回 <code>[object Object]</code></li>
</ul>
<p>&lt;br /&gt;</p>
<pre class="hljs"><code class="language-js"><span class="hljs-title class_">String</span>(<span class="hljs-literal">null</span>);
<span class="hljs-comment">// &quot;null&quot;</span>

<span class="hljs-title class_">String</span>(<span class="hljs-literal">undefined</span>);
<span class="hljs-comment">// &#x27;undefined&#x27;</span>

<span class="hljs-title class_">String</span>(<span class="hljs-literal">true</span>);
<span class="hljs-comment">// &#x27;true&#x27;</span>

<span class="hljs-title class_">String</span>(<span class="hljs-number">10</span>);
<span class="hljs-comment">// &#x27;10&#x27;</span>

<span class="hljs-title class_">String</span>(<span class="hljs-number">1e21</span>);
<span class="hljs-comment">// &#x27;1e+21&#x27;</span>

<span class="hljs-title class_">String</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);
<span class="hljs-comment">// &#x27;1,2,3&#x27;</span>

<span class="hljs-title class_">String</span>([]);
<span class="hljs-comment">// &#x27;&#x27;</span>

<span class="hljs-title class_">String</span>([<span class="hljs-literal">null</span>]);
<span class="hljs-comment">// &#x27;&#x27;</span>

<span class="hljs-title class_">String</span>([<span class="hljs-number">1</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-number">3</span>]);
<span class="hljs-comment">// &#x27;1,,3&#x27;</span>

<span class="hljs-title class_">String</span>({});
<span class="hljs-comment">// &#x27;[object Objecr]&#x27;</span>
</code></pre>
<h3>ToNumber</h3>
<ul>
<li><code>null</code>： 转为 <code>0</code></li>
<li><code>undefined</code>：转为 <code>NaN</code></li>
<li>String 类型：如果是纯数字形式，则转为对应的数字
<ul>
<li>空字符转为 <code>0</code></li>
<li>否则一律按转换失败处理，转为 <code>NaN</code></li>
</ul>
</li>
<li>Boolean 类型：
<ul>
<li><code>true</code> 将被转为 <code>1</code></li>
<li><code>false</code> 将被转为 <code>0</code></li>
</ul>
</li>
<li>Array 类型：数组首先会被转为 <strong>原始数据类型</strong>，也就是 <a href="/front-end/basic-concept/data-types/#ToPrimitive">ToPrimitive</a>，然后在根据转换后的原始类型按照上面的规则处理</li>
<li>对象：同数组的处理</li>
</ul>
<p>&lt;br /&gt;</p>
<pre class="hljs"><code class="language-js"><span class="hljs-title class_">Number</span>(<span class="hljs-literal">null</span>);
<span class="hljs-comment">// 0</span>

<span class="hljs-title class_">Number</span>(<span class="hljs-literal">undefined</span>);
<span class="hljs-comment">// NaN</span>

<span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;10&#x27;</span>);
<span class="hljs-comment">// 10</span>

<span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;10a&#x27;</span>);
<span class="hljs-comment">// NaN</span>

<span class="hljs-title class_">Number</span>(<span class="hljs-string">&#x27;&#x27;</span>);
<span class="hljs-comment">// 0</span>

<span class="hljs-title class_">Number</span>(<span class="hljs-literal">true</span>);
<span class="hljs-comment">// 1</span>

<span class="hljs-title class_">Number</span>(<span class="hljs-literal">false</span>);
<span class="hljs-comment">// 0</span>

<span class="hljs-title class_">Number</span>([]);
<span class="hljs-comment">// 0</span>

<span class="hljs-title class_">Number</span>([<span class="hljs-string">&#x27;1&#x27;</span>]);
<span class="hljs-comment">// 1</span>

<span class="hljs-title class_">Number</span>({});
<span class="hljs-comment">// NaN</span>
</code></pre>
<h3>ToBoolean</h3>
<p>JavaScript 中假值只有 <code>false</code>、<code>null</code>、<code>undefined</code>、<code>&quot;&quot;</code>、<code>0</code> 和 <code>NaN</code>，其他值转为 Boolean 类型都为 <code>true</code>。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">null</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-title class_">Boolean</span>(<span class="hljs-literal">undefined</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-title class_">Boolean</span>(<span class="hljs-string">&#x27;&#x27;</span>);
<span class="hljs-comment">// flase</span>

<span class="hljs-title class_">Boolean</span>(<span class="hljs-title class_">NaN</span>);
<span class="hljs-comment">// flase</span>

<span class="hljs-title class_">Boolean</span>(<span class="hljs-number">0</span>);
<span class="hljs-comment">// flase</span>

<span class="hljs-title class_">Boolean</span>([]);
<span class="hljs-comment">// true</span>

<span class="hljs-title class_">Boolean</span>({});
<span class="hljs-comment">// true</span>

<span class="hljs-title class_">Boolean</span>(<span class="hljs-title class_">Infinity</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<h3>ToPrimitive</h3>
<blockquote>
<p>ToPrimitive 方法用于将引用类型转换为原始数据类型的操作</p>
</blockquote>
<p>🔬 值为引用数据类型时，会调用 JavaScript 内置的 <code>@@ToPrimitive(hint)</code> 方法来指定其目标类型。</p>
<ul>
<li>如果传入值为 Number 类型，则调用对象的 <code>valueOf()</code> 方法，若返回值为原始数据类型，则结束 <code>@@ToPrimitive</code> 操作，如果返回的不是原始数据类型，则继续调用对象的 <code>toString()</code> 方法，若返回值为原始数据类型，则结束 <code>@@ToPrimitive</code> 操作，如果返回的还是引用数据类型，则抛出异常。</li>
<li>如果传入值为 String 类型，则先调用 <code>toString()</code> 方法，再调用 <code>valueOf()</code> 方法。</li>
</ul>
<p>&lt;br /&gt;</p>
<pre class="hljs"><code class="language-js">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] ==
  <span class="hljs-string">&#x27;1,2&#x27;</span>[(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)] <span class="hljs-comment">// true</span>
    .<span class="hljs-title function_">valueOf</span>() <span class="hljs-comment">// &quot;[1,2]&quot;</span>
    [(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)].<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;1,2&quot;</span>

<span class="hljs-keyword">const</span> a = {};
a == <span class="hljs-string">&#x27;[object Object]&#x27;</span>; <span class="hljs-comment">// true</span>
a.<span class="hljs-title function_">valueOf</span>().<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// &quot;[object Object]&quot;</span>
</code></pre>
<blockquote>
<p>对于不同类型的引用数据类型，ToPrimitive 的规则有所不同，比如 Date 对象会先调用 <code>toString()</code> 方法，具体可以参考 <a href="https://www.ecma-international.org/ecma-262/6.0/#sec-toprimitive" target="_blank" rel="noopener noreferrer nofollow">ECMAScript6 规范中对 ToPrimitive 的定义解释</a></p>
<p>以 JavaScript 实现 <a href="https://juejin.im/post/59ad2585f265da246a20e026#heading-1" target="_blank" rel="noopener noreferrer nofollow">ToPrimitive</a></p>
</blockquote>
<p>值得一提的是对于 <strong>数值类型</strong> 的 <code>valueOf()</code> 函数的调用结果仍为数组，因此数组类型的隐式类型转换结果是字符串。</p>
<p>而在 ES6 中引入 Symbol 类型之后，JavaScript 会优先调用对象的 <code>[Symbol.toPrimitive]</code> 方法来将该对象转化为原始类型，那么方法的调用顺序就变为了：</p>
<ul>
<li>当 <code>obj[Symbol.toPrimitive](preferredType)</code> 方法存在时，优先调用该方法</li>
<li>如果 <code>preferredType</code> 参数为 String 类型，则依次尝试 <code>obj.toString()</code> 与 <code>obj.valueOf()</code></li>
<li>如果 <code>preferredType</code> 参数为 Number 类型或者默认值，则依次尝试 <code>obj.valueOf()</code> 与 <code>obj.toString()</code></li>
</ul>
<h2>显式类型转换</h2>
<p>通过手动进行类型转换，JavaScript 提供了以下转型函数：</p>
<ul>
<li>转换为数值类型
<ul>
<li><code>Number(mix)</code></li>
<li><code>parseInt(string, radix)</code></li>
<li><code>parseFloat(string)</code></li>
</ul>
</li>
<li>转换为字符串类型
<ul>
<li><code>toString(radix)</code></li>
<li><code>String(mix)</code></li>
</ul>
</li>
<li>转换为布尔类型
<ul>
<li><code>Boolean(mix)</code></li>
</ul>
</li>
</ul>
<h2>隐式类型转换</h2>
<p>在 JavaScript 中，当运算符在运算时，如果 <strong>两边数据不统一</strong>，CPU 就无法运算，这时我们编译器会自动将运算符两边的数据做一个数据类型转换，转成相同的数据类型再计算。</p>
<p>这种无需开发者手动转换，而由 <strong>编译器自动转换</strong> 的方式就称为 <strong>隐式类型转换</strong>。</p>
<p>JavaScript 的数据类型隐式转换主要分为三种情况：</p>
<ul>
<li>转换为 Boolean 类型</li>
<li>转换为 Number 类型</li>
<li>转换为 String 类型</li>
</ul>
<p>值在 <strong>逻辑判断</strong> 和 <strong>逻辑运算</strong> 时会隐式转换为 Boolean 类型。</p>
<p>Boolean 类型转换规则表：</p>
<table>
<thead>
<tr>
<th style="text-align:left">数据值</th>
<th style="text-align:left">转换后的值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">数字 <code>0</code></td>
<td style="text-align:left"><code>false</code></td>
</tr>
<tr>
<td style="text-align:left"><code>NaN</code></td>
<td style="text-align:left"><code>false</code></td>
</tr>
<tr>
<td style="text-align:left">空字符串 <code>&quot;&quot;</code></td>
<td style="text-align:left"><code>false</code></td>
</tr>
<tr>
<td style="text-align:left"><code>null</code></td>
<td style="text-align:left"><code>false</code></td>
</tr>
<tr>
<td style="text-align:left"><code>undefined</code></td>
<td style="text-align:left"><code>false</code></td>
</tr>
<tr>
<td style="text-align:left">非 <code>!0</code> 数字</td>
<td style="text-align:left"><code>true</code></td>
</tr>
<tr>
<td style="text-align:left">非空字符串 <code>!&quot;&quot;</code></td>
<td style="text-align:left"><code>true</code></td>
</tr>
<tr>
<td style="text-align:left">非 <code>!null</code> 对象类型</td>
<td style="text-align:left"><code>true</code></td>
</tr>
</tbody>
</table>
<p>⚠️ <strong>注意事项</strong>：使用 <code>new</code> 运算符创建的对象隐式转换为 Boolean 类型的值都是 <code>true</code>。</p>
<p>连续两个非操作可以将一个数强制转换为 Boolean 类型。</p>
<pre class="hljs"><code class="language-js">!!<span class="hljs-literal">undefined</span>;
<span class="hljs-comment">// false</span>

!!<span class="hljs-literal">null</span>;
<span class="hljs-comment">// false</span>

!!<span class="hljs-number">1</span>;
<span class="hljs-comment">// true</span>

!!<span class="hljs-string">&#x27;&#x27;</span>;
<span class="hljs-comment">// false</span>

!!<span class="hljs-string">&#x27;Hello&#x27;</span>;
<span class="hljs-comment">// true</span>

!!{};
<span class="hljs-comment">// true</span>

!![];
<span class="hljs-comment">// true</span>

!!<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {};
<span class="hljs-comment">// true</span>
</code></pre>
<h3>运行环境</h3>
<p>很多内置函数期望传入的参数的数据类型是固定的，如 <code>alert(value)</code>，它期望传入的 <code>value</code> 为 String 类型，但是如果我们传入的是 Number 类型或者 Object 类型等非 String 类型的数据的时候，就会发生数据类型的隐式转换。这就是环境运行环境对数据类型转换的影响。</p>
<p>类似的方法还有：</p>
<ul>
<li><code>alert()</code></li>
<li><code>parseInt()</code></li>
</ul>
<h3>运算符</h3>
<h4>加号运算符</h4>
<p>当加号运算符作为一元运算符运算值时，它会将该值转换为 Number 类型。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-string">&#x27; &#x27;</span> +
<span class="hljs-comment">// 0</span>

<span class="hljs-string">&#x27;0&#x27;</span> +
<span class="hljs-comment">// 0</span>

<span class="hljs-string">&#x27;10&#x27;</span> +
<span class="hljs-comment">// 10</span>

<span class="hljs-string">&#x27;String&#x27;</span> +
<span class="hljs-comment">// NaN</span>

<span class="hljs-literal">true</span> +
<span class="hljs-comment">// 1</span>

<span class="hljs-literal">false</span> +
<span class="hljs-comment">// 0</span>

<span class="hljs-literal">undefined</span> +
<span class="hljs-comment">// 0</span>

<span class="hljs-literal">null</span> +
<span class="hljs-comment">// 0</span>

[] +
<span class="hljs-comment">// 0</span>

![] +
<span class="hljs-comment">// 0</span>

[<span class="hljs-number">1</span>] +
<span class="hljs-comment">// 1</span>

[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] +
<span class="hljs-comment">// NaN</span>

[[<span class="hljs-number">1</span>]] +
<span class="hljs-comment">// 1</span>

[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]] +
<span class="hljs-comment">// NaN</span>

{} +
<span class="hljs-comment">// NaN</span>

<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {};
<span class="hljs-comment">// NaN</span>

+<span class="hljs-string">&#x27;&#x27;</span> +
<span class="hljs-comment">// 0</span>
</code></pre>
<p>当加号运算符作为二元运算符操作值时，它会根据两边值类型进行数据类型隐式转换。</p>
<p>首先，当引用对象类型的值进行二元加号运算符运算时，会涉及到转换为原始数据类型的问题。事实上，当一个对象执行例如加法操作的时候，如果它是原始类型，那么就不需要转换。否则，将遵循以下规则：</p>
<ul>
<li>调用实例的 <code>valueOf()</code> 方法，如果有返回的是基础类型，停止下面的过程；否则继续</li>
<li>调用实例的 <code>toString()</code> 方法，如果有返回的是基础类型，停止下面的过程；否则继续</li>
<li>都没返回原始类型，就会报错</li>
</ul>
<p>如果运算符两边均为原始数据类型时，则按照以下规则解释：</p>
<ul>
<li><strong>字符串连接符</strong>：如果两个操作数中只要存在一个操作数为 String 类型，那么另一个操作数会调用 <code>String()</code> 方法转成字符串然后拼接</li>
<li><strong>算术运算符</strong>：如果两个操作数都不是 String 类型，两个操作数会调用 <code>Number()</code> 方法隐式转换为 Number 类型（如果无法成功转换成数字，则变为 <code>NaN</code>，再往下操作），然后进行加法算术运算</li>
</ul>
<p>值转换为 Number 类型和 String 类型都会遵循一个原则：如果该值为原始数据类型，则直接转换为 String 类型或 Number 类型。如果该值为引用数据类型，那么先通过固定的方法将复杂值转换为原始数据类型，再转为 String 类型或 Number 类型。<a href="/front-end/basic-concept/data-types/#ToPrimitive">ToPrimitive</a></p>
<p>⚠️ <strong>注意事项</strong>：当 <code>{} + 任何值</code> 时， 前一个 <code>{}</code> 都会被 JavaScript 解释成空块并忽略他。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-string">&quot;1&quot;</span> + <span class="hljs-number">1</span>             <span class="hljs-comment">// &quot;11&quot;</span>
<span class="hljs-string">&quot;1&quot;</span> + <span class="hljs-string">&quot;1&quot;</span>           <span class="hljs-comment">// &quot;11&quot;</span>
<span class="hljs-string">&quot;1&quot;</span> + <span class="hljs-literal">true</span>          <span class="hljs-comment">// &quot;1true&quot;</span>
<span class="hljs-string">&quot;1&quot;</span> + <span class="hljs-title class_">NaN</span>           <span class="hljs-comment">// &quot;NaN&quot;</span>
<span class="hljs-string">&quot;1&quot;</span> + []            <span class="hljs-comment">// &quot;1&quot;</span>
<span class="hljs-string">&quot;1&quot;</span> + {}            <span class="hljs-comment">// &quot;1[object Object]&quot;</span>
<span class="hljs-string">&quot;1&quot;</span> + <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){}  <span class="hljs-comment">// &quot;1function(){}&quot;</span>
<span class="hljs-string">&quot;1&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Boolean</span>() <span class="hljs-comment">// &quot;1false&quot;</span>

<span class="hljs-number">1</span> + <span class="hljs-title class_">NaN</span>             <span class="hljs-comment">// NaN</span>
<span class="hljs-number">1</span> + <span class="hljs-string">&quot;true&quot;</span>          <span class="hljs-comment">// &quot;1true&quot;</span>
<span class="hljs-number">1</span> + <span class="hljs-literal">true</span>            <span class="hljs-comment">// 2</span>
<span class="hljs-number">1</span> + <span class="hljs-literal">undefined</span>       <span class="hljs-comment">// NaN</span>
<span class="hljs-number">1</span> + <span class="hljs-literal">null</span>            <span class="hljs-comment">// 1</span>

<span class="hljs-number">1</span> + []              <span class="hljs-comment">// &quot;1&quot;</span>
<span class="hljs-number">1</span> + [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]          <span class="hljs-comment">// &quot;11,2&quot;</span>
<span class="hljs-number">1</span> + {}              <span class="hljs-comment">// &quot;1[object Object]&quot;</span>
<span class="hljs-number">1</span> + <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>){}    <span class="hljs-comment">// &quot;1function(){}&quot;</span>
<span class="hljs-number">1</span> + <span class="hljs-title class_">Number</span>()        <span class="hljs-comment">// 1</span>
<span class="hljs-number">1</span> + <span class="hljs-title class_">String</span>()        <span class="hljs-comment">// &quot;1&quot;</span>

[] + []             <span class="hljs-comment">// &quot;&quot;</span>
{} + {}             <span class="hljs-comment">// &quot;[object Object][object Object]&quot;</span>
{} + []             <span class="hljs-comment">// 0</span>
{<span class="hljs-attr">a</span>: <span class="hljs-number">0</span>} + <span class="hljs-number">1</span>          <span class="hljs-comment">// 1</span>
[] + {}             <span class="hljs-comment">// &quot;[object Object]&quot;</span>
[] + !{}            <span class="hljs-comment">// &quot;false&quot;</span>
![] + []            <span class="hljs-comment">// &quot;false&quot;</span>
<span class="hljs-string">&#x27;&#x27;</span> + {}             <span class="hljs-comment">// &quot;[object Object]&quot;</span>
{} + <span class="hljs-string">&#x27;&#x27;</span>             <span class="hljs-comment">// 0</span>
[][<span class="hljs-string">&quot;map&quot;</span>] + []      <span class="hljs-comment">// &quot;function map(){ [native code] }&quot;</span>
[][<span class="hljs-string">&quot;a&quot;</span>] + []        <span class="hljs-comment">// &quot;undefined&quot;</span>
[][[]] + []         <span class="hljs-comment">// &quot;undefined&quot;</span>
+!![] + []          <span class="hljs-comment">// 1</span>
+!![]               <span class="hljs-comment">// 1</span>
<span class="hljs-number">1</span>-{}                <span class="hljs-comment">// NaN</span>
<span class="hljs-number">1</span>-[]                <span class="hljs-comment">// 1</span>
<span class="hljs-literal">true</span> - <span class="hljs-number">1</span>            <span class="hljs-comment">// 0</span>
{} - <span class="hljs-number">1</span>              <span class="hljs-comment">// -1</span>
[] !== []           <span class="hljs-comment">// true</span>
[][<span class="hljs-string">&#x27;push&#x27;</span>](<span class="hljs-number">1</span>)       <span class="hljs-comment">// 1</span>

(![]+[])[+[]]       <span class="hljs-comment">// &quot;f&quot;</span>
(![]+[])[+!![]]     <span class="hljs-comment">// &quot;a&quot;</span>
</code></pre>
<h4>相等运算符</h4>
<p>相等运算符 <code>==</code> 会对操作值进行隐式转换后进行比较</p>
<ul>
<li>如果其中一个操作值为布尔值，则在比较之前先将其转换为数值</li>
<li>如果其中一个操作值为字符串，另一个操作值为数值，则通过 <code>Number()</code> 函数将字符串转换为数值</li>
<li>如果其中一个操作值是对象，另一个不是，则调用对象的 <code>valueOf()</code> 方法，得到的结果按照前面的规则进行比较</li>
<li><code>null</code> 与<code>undefined</code> 是相等的</li>
<li>如果一个操作值为 <code>NaN</code>，则返回 <code>false</code></li>
<li>如果两个操作值都是对象，则比较它们是不是指向同一个对象</li>
</ul>
<pre class="hljs"><code class="language-js"><span class="hljs-string">&#x27;1&#x27;</span> == <span class="hljs-literal">true</span>; <span class="hljs-comment">// true</span>
<span class="hljs-string">&#x27;1&#x27;</span> == <span class="hljs-number">1</span>; <span class="hljs-comment">// true</span>
<span class="hljs-string">&#x27;1&#x27;</span> == {}; <span class="hljs-comment">// false</span>
<span class="hljs-string">&#x27;1&#x27;</span> == []; <span class="hljs-comment">// false</span>

<span class="hljs-literal">undefined</span> == <span class="hljs-literal">undefined</span>; <span class="hljs-comment">// true</span>
<span class="hljs-literal">undefined</span> == <span class="hljs-literal">null</span>; <span class="hljs-comment">// true</span>
nul == <span class="hljs-literal">null</span>; <span class="hljs-comment">// true</span>
</code></pre>
<h4>关系运算符</h4>
<p><a href="/front-end/basic-concept/expressions/comparation-operators">关系运算符</a>：会把其他数据类型转换成 Number 之后再比较关系（除了 Date 类型对象）</p>
<ul>
<li>如果两个操作值都是数值，则进行 <strong>数值</strong> 比较</li>
<li>如果两个操作值都是字符串，则比较字符串对应的 <strong>ASCII 字符编码值</strong>
<ul>
<li>多个字符则从左往右依次比较</li>
</ul>
</li>
<li>如果只有一个操作值是数值，则将另一个操作值转换为数值，进行 <strong>数值</strong> 比较</li>
<li>如果一个操作数是对象，则调用 <code>valueOf()</code> 方法（如果对象没有 <code>valueOf()</code> 方法则调用 <code>toString()</code> 方法），得到的结果按照前面的规则执行比较</li>
<li>如果一个操作值是布尔值，则将其转换为 <strong>数值</strong>，再进行比较</li>
</ul>
<p>📍 <code>NaN</code> 是非常特殊的值，它不和任何类型的值相等，包括它自己，同时它与任何类型的值比较大小时都返回 <code>false</code>。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-number">5</span> &gt; <span class="hljs-number">10</span>;
<span class="hljs-comment">// false</span>

<span class="hljs-string">&#x27;2&#x27;</span> &gt; <span class="hljs-number">10</span>;
<span class="hljs-comment">// false</span>

<span class="hljs-string">&#x27;2&#x27;</span> &gt; <span class="hljs-string">&#x27;10&#x27;</span>;
<span class="hljs-comment">// true</span>

<span class="hljs-string">&#x27;abc&#x27;</span> &gt; <span class="hljs-string">&#x27;b&#x27;</span>;
<span class="hljs-comment">// false</span>

<span class="hljs-string">&#x27;abc&#x27;</span> &gt; <span class="hljs-string">&#x27;aad&#x27;</span>;
<span class="hljs-comment">// true</span>
</code></pre>
<p><strong>JavaScript 原始类型转换表</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">原始值</th>
<th style="text-align:left">转换为数字类型</th>
<th style="text-align:left">转换为字符串类型</th>
<th style="text-align:left">转换为布尔类型</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">false</td>
<td style="text-align:left">0</td>
<td style="text-align:left">&quot;false&quot;</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">true</td>
<td style="text-align:left">1</td>
<td style="text-align:left">&quot;true&quot;</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">0</td>
<td style="text-align:left">&quot;0&quot;</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">&quot;1&quot;</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">&quot;0&quot;</td>
<td style="text-align:left">0</td>
<td style="text-align:left">&quot;0&quot;</td>
<td style="text-align:left">&lt;span style=&quot;color:red&quot;&gt;true&lt;/span&gt;</td>
</tr>
<tr>
<td style="text-align:left">&quot;000&quot;</td>
<td style="text-align:left">0</td>
<td style="text-align:left">&quot;000&quot;</td>
<td style="text-align:left">&lt;span style=&quot;color:red&quot;&gt;true&lt;/span&gt;</td>
</tr>
<tr>
<td style="text-align:left">&quot;1&quot;</td>
<td style="text-align:left">1</td>
<td style="text-align:left">&quot;1&quot;</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">NaN</td>
<td style="text-align:left">NaN</td>
<td style="text-align:left">&quot;NaN&quot;</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">Infinity</td>
<td style="text-align:left">Infinity</td>
<td style="text-align:left">&quot;Infinity&quot;</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">-Infinity</td>
<td style="text-align:left">-Infinity</td>
<td style="text-align:left">&quot;-Inifinity&quot;</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">&quot;&quot;</td>
<td style="text-align:left">&lt;span style=&quot;color:red&quot;&gt;0&lt;/span&gt;</td>
<td style="text-align:left">&quot;&quot;</td>
<td style="text-align:left">&lt;span style=&quot;color:red&quot;&gt;false&lt;/span&gt;</td>
</tr>
<tr>
<td style="text-align:left">&quot; &quot;</td>
<td style="text-align:left">0</td>
<td style="text-align:left">&quot; &quot;</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">&quot;20&quot;</td>
<td style="text-align:left">20</td>
<td style="text-align:left">&quot;20&quot;</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">&quot;Hello&quot;</td>
<td style="text-align:left">NaN</td>
<td style="text-align:left">&quot;Hello&quot;</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">[]</td>
<td style="text-align:left">0</td>
<td style="text-align:left">&quot;&quot;</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">[20]</td>
<td style="text-align:left">20</td>
<td style="text-align:left">&quot;20&quot;</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">[10, 20]</td>
<td style="text-align:left">NaN</td>
<td style="text-align:left">&quot;10,20&quot;</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">[&quot;Hello&quot;]</td>
<td style="text-align:left">NaN</td>
<td style="text-align:left">&quot;Hello&quot;</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">[&quot;Hello&quot;, &quot;World&quot;]</td>
<td style="text-align:left">NaN</td>
<td style="text-align:left">&quot;Hello,World&quot;</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">function(){}</td>
<td style="text-align:left">NaN</td>
<td style="text-align:left">&quot;function(){}&quot;</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">{}</td>
<td style="text-align:left">NaN</td>
<td style="text-align:left">&quot;[object Object]&quot;</td>
<td style="text-align:left">true</td>
</tr>
<tr>
<td style="text-align:left">null</td>
<td style="text-align:left">0</td>
<td style="text-align:left">&quot;null&quot;</td>
<td style="text-align:left">false</td>
</tr>
<tr>
<td style="text-align:left">undefined</td>
<td style="text-align:left">NaN</td>
<td style="text-align:left">&quot;undefined&quot;</td>
<td style="text-align:left">false</td>
</tr>
</tbody>
</table>
<h2>经典试题</h2>
<blockquote>
<p><code>(a == 1) &amp;&amp; (a == 2) &amp;&amp; (a == 3)</code> 能不能为 <code>true</code>？</p>
</blockquote>
<p>事实上是可以的，就是因为在 <code>==</code> 比较的情况下，会进行隐式类型转换。如果参数不是 Date 对象实例，就会进行类型转换，先 <code>valueOf()</code> 再 <code>toString()</code>。所以，我们只要改变原生的 <code>valueOf()</code> 或者 <code>toString()</code> 方法就可以达到效果：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> a = {
  <span class="hljs-attr">num</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">valueOf</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> += <span class="hljs-number">1</span>);
  },
};

<span class="hljs-keyword">const</span> eq = a == <span class="hljs-number">1</span> &amp;&amp; a == <span class="hljs-number">2</span> &amp;&amp; a == <span class="hljs-number">3</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(eq);
<span class="hljs-comment">// true</span>

<span class="hljs-comment">// 或者改写他的 toString 方法</span>
<span class="hljs-keyword">const</span> num = <span class="hljs-number">0</span>;
<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> ++num;
};
<span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) {}

<span class="hljs-comment">// 还可以改写 ES6 的 Symbol 类型的 toPrimitive 的方法</span>
<span class="hljs-keyword">const</span> a = {
  [<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">toPrimitive</span>]: (<span class="hljs-keyword">function</span> (<span class="hljs-params">i</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> ++i;
    };
  })(<span class="hljs-number">0</span>),
};
</code></pre>
<p>每一次进行等号的比较，就会调用一次 <code>valueOf()</code> 方法，自增 1，所以能成立。
另外，减法也是同理：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> a = {
  <span class="hljs-attr">num</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">valueOf</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span> -= <span class="hljs-number">1</span>);
  },
};

<span class="hljs-keyword">const</span> res = a == <span class="hljs-number">3</span> &amp;&amp; a == <span class="hljs-number">2</span> &amp;&amp; a == <span class="hljs-number">1</span>;
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);
</code></pre>
<hr>
<p><strong>参考文章：</strong></p>
<ul>
<li><a href="https://juejin.im/post/59ad2585f265da246a20e026" target="_blank" rel="noopener noreferrer nofollow">📝 JavaScript 运算符规则与隐式类型转换详解</a></li>
</ul>
4:["$","div",null,{"className":"markdown-body","children":["$","article",null,{"dangerouslySetInnerHTML":{"__html":"$c"}}]}]
a:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
8:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"front-end"}],["$","meta","2",{"name":"description","content":"front-end knowledge"}],["$","link","3",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
6:null
