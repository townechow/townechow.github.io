1:"$Sreact.fragment"
2:I[5244,[],""]
3:I[3866,[],""]
5:I[6213,[],"OutletBoundary"]
7:I[6213,[],"MetadataBoundary"]
9:I[6213,[],"ViewportBoundary"]
b:I[4835,[],""]
:HL["/_next/static/media/569ce4b8f30dc480-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/d498c84e4ab246b3.css","style"]
:HL["/_next/static/css/485ff6fe79292a08.css","style"]
:HL["/_next/static/css/b9d97b2190475167.css","style"]
:HL["/_next/static/css/851cdee6d90716dd.css","style"]
0:{"P":null,"b":"NFjmtHF2up8B2PpbDjLiS","p":"","c":["","front-end","basic-concept","expressions","operators","spread-operator"],"i":false,"f":[[["",{"children":["front-end",{"children":[["slug","basic-concept/expressions/operators/spread-operator","oc"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/d498c84e4ab246b3.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/485ff6fe79292a08.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","2",{"rel":"stylesheet","href":"/_next/static/css/b9d97b2190475167.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__variable_4d318d __variable_ea5f4b antialiased","children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[],[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]]}],{"children":["front-end",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/851cdee6d90716dd.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","main",null,{"children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","front-end","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]}]]}],{"children":[["slug","basic-concept/expressions/operators/spread-operator","oc"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","front-end","children","$0:f:0:1:2:children:2:children:0","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L4",null,["$","$L5",null,{"children":"$L6"}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","7Smg5gq3ekWUWmDdv9lrf",{"children":[["$","$L7",null,{"children":"$L8"}],["$","$L9",null,{"children":"$La"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}]]}],false]],"m":"$undefined","G":["$b","$undefined"],"s":false,"S":true}
c:T3750,<h1>扩展运算符</h1>
<p>扩展运算符允许一个表达式在期望多个参数（用于函数调用）或多个元素（用于数组字面量）或多个变量（用于解构赋值）的位置扩展。</p>
<h2>语法</h2>
<h3>函数调用</h3>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-title function_">myFunction</span>(...iterableObj);
</code></pre>
<h3>数组字面量或字符串</h3>
<pre class="hljs language-js"  style=--lang:"js" ><code>[...iterableObj, <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;five&#x27;</span>, <span class="hljs-number">6</span>];
</code></pre>
<h3>对象字面量</h3>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">let</span> iterableObj = { ...obj };
</code></pre>
<h2>应用</h2>
<h3>函数中的应用</h3>
<h4>替代数组的 <code>apply</code> 方法</h4>
<p>当我们的函数有多个变量的时候（特别是当我们不知道变量的数量的时候），有时候会通过将变量保存在数组中，并通过 <code>apply</code> 来执行函数，有了扩展运算符后则有了更好的方式（毕竟使用 <code>apply</code> 需要手动指定 <code>this</code> ，有时候会不是很方便很准确）。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-comment">// ES5</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params">x, y, z</span>) {}
<span class="hljs-keyword">var</span> args = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
myFunction.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, args);

<span class="hljs-comment">// ES6</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params">x, y, z</span>) {}
<span class="hljs-keyword">var</span> args = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
<span class="hljs-title function_">myFunction</span>(...args);
</code></pre>
<p>参数列表中的人和参数都可以使用扩展语法，并且可以多次使用。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">myFunction</span>(<span class="hljs-params">v, w, x, y, z</span>) {}
<span class="hljs-keyword">var</span> args = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>];
<span class="hljs-title function_">myFunction</span>(-<span class="hljs-number">1</span>, ...args, <span class="hljs-number">2</span>, ...[<span class="hljs-number">3</span>]);
</code></pre>
<h4>函数的返回值</h4>
<p>JavaScript 的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一个变通方法。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">var</span> dateField = <span class="hljs-title function_">readDateFields</span>(database);
<span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(...dateFields);
</code></pre>
<p>上面的代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数 Date。</p>
<h3>数组中的应用</h3>
<h4>数组的合并</h4>
<p>扩展运算符提供了数组合并的新写法</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-comment">// ES5</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>].<span class="hljs-title function_">concat</span>(more)
<span class="hljs-comment">// ES6</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, ...more]

<span class="hljs-keyword">var</span> arr1 = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>];
<span class="hljs-keyword">var</span> arr2 = [<span class="hljs-string">&#x27;c&#x27;</span>];
<span class="hljs-keyword">var</span> arr3 = [<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>];

<span class="hljs-comment">// ES5 的合并数组</span>
arr1.<span class="hljs-title function_">concat</span>(arr2, arr3);
<span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span>

<span class="hljs-comment">// ES6 的合并数组</span>
[...arr1, ...arr2, ...arr3]
<span class="hljs-comment">// [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;]</span>
</code></pre>
<h4>数组的拷贝</h4>
<p>被拷贝数组元素仅限基本数据类型。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">let</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-keyword">let</span> b = [...a];
</code></pre>
<h4>与解构赋值结合</h4>
<p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-comment">// ES5</span>
a = list[<span class="hljs-number">0</span>], rest = list.<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>)
<span class="hljs-comment">// ES6</span>
[a, ...rest] = list
</code></pre>
<p>下面是另外一些例子</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-comment">// 数组的分割</span>
<span class="hljs-keyword">const</span> [first, ...rest] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first);
<span class="hljs-comment">// 1</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rest);
<span class="hljs-comment">// [2, 3, 4, 5]</span>

<span class="hljs-keyword">const</span> [first, ...rest] = [];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first);
<span class="hljs-comment">// undefined</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rest);
<span class="hljs-comment">// []</span>

<span class="hljs-keyword">const</span> [first, ...rest] = [<span class="hljs-string">&#x27;foo&#x27;</span>];
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(first);
<span class="hljs-comment">// &#x27;foo&#x27;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(rest);
<span class="hljs-comment">// []</span>
</code></pre>
<p>如果将扩展运算符用于数组赋值，则只能将其放在参数的<strong>最后一位</strong>，否则会报错。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">const</span> [...butLast, last] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]
<span class="hljs-comment">// 报错</span>

<span class="hljs-keyword">const</span> [first, ...middle, last] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-comment">// 报错</span>
</code></pre>
<h3>字符串中的应用</h3>
<p>扩展运算符还可以将字符串转为真正的数组。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code>[...<span class="hljs-string">&#x27;hello&#x27;</span>];
<span class="hljs-comment">// [&#x27;h&#x27;, &#x27;e&#x27;, &#x27;l&#x27;, &#x27;l&#x27;, &#x27;o&#x27;]</span>
</code></pre>
<p>上面的写法有一个重要的好处：能够正确识别 32 位的 Unicode 字符。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-string">&#x27;x\uD83D\uDE80y&#x27;</span>.<span class="hljs-property">length</span>			<span class="hljs-comment">// 4</span>
[...<span class="hljs-string">&#x27;x\uD83D\uDE80y&#x27;</span>].<span class="hljs-property">length</span>	<span class="hljs-comment">// 3</span>
</code></pre>
<p>以上代码的第一种写法中，JavaScript 会将 32 位 Unicode 字符识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数可以像下面这样写。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">length</span>(<span class="hljs-params">str</span>) {
  <span class="hljs-keyword">return</span> [...str].<span class="hljs-property">length</span>;
}

<span class="hljs-title function_">length</span>(<span class="hljs-string">&#x27;x\uD83D\uDE80y&#x27;</span>); <span class="hljs-comment">// 3</span>
</code></pre>
<p>凡事涉及操作 32 位 Unicode 字符的函数都有这个问题。因此，最好都用扩展运算符改写。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">let</span> str = <span class="hljs-string">&#x27;x\uD83D\uDE80y&#x27;</span>;

str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;&#x27;</span>).<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)
<span class="hljs-comment">// &#x27;y\uDE80\uD83Dx&#x27;</span>

[...str].<span class="hljs-title function_">reverse</span>().<span class="hljs-title function_">join</span>(<span class="hljs-string">&#x27;&#x27;</span>)
<span class="hljs-comment">// &#x27;y\uD83D\uDE80x&#x27;</span>
</code></pre>
<p>上面的代码中，如果不用扩展运算，字符串的 <code>reverse</code> 操作就不正确。</p>
<h3>实现 Iterator 接口的对象</h3>
<p>任何 Iterator 接口的对象都可以用扩展运算符转为<strong>真正的数组</strong>。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">var</span> nodeList = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;div&#x27;</span>);
<span class="hljs-keyword">var</span> array = [...nodeList];
</code></pre>
<p>上面的代码中，<code>querySelectorAll</code> 方法返回的是一个 <code>nodeList</code> 对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因在于 <code>NodeList</code> 对象实现了 Iterator。</p>
<p>对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组了。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">let</span> arrayLike = {
  <span class="hljs-string">&#x27;0&#x27;</span>: <span class="hljs-string">&#x27;a&#x27;</span>,
  <span class="hljs-string">&#x27;1&#x27;</span>: <span class="hljs-string">&#x27;b&#x27;</span>,
  <span class="hljs-string">&#x27;2&#x27;</span>: <span class="hljs-string">&#x27;c&#x27;</span>,
  <span class="hljs-attr">length</span>: <span class="hljs-number">3</span>,
};

<span class="hljs-comment">// TypeError: Cannot spread non-iterable object.</span>
<span class="hljs-keyword">let</span> arr = [...arrayLike];
</code></pre>
<p>上面的代码中，<code>arrayLike</code> 是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用 <code>Array.from</code> 方法将 <code>arrayLike</code> 转为真正的数组。</p>
<h3><code>Map</code> 和 <code>Set</code> 结构、<code>Generator</code> 函数</h3>
<p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，如 <code>Map</code> 结构。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>([
  [<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;one&#x27;</span>],
  [<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;two&#x27;</span>],
  [<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;three&#x27;</span>],
]);

<span class="hljs-keyword">let</span> arr = [...map.<span class="hljs-title function_">keys</span>()]; <span class="hljs-comment">// [1, 2, 3]</span>
</code></pre>
<p>Generator 函数运行后会返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">var</span> go = <span class="hljs-keyword">function</span>*() {
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span>;
};

[...<span class="hljs-title function_">go</span>()]; <span class="hljs-comment">// [1, 2, 3]</span>
</code></pre>
<p>上面的代码中，变量 <code>go</code> 是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符即可将内部遍历得到的值转为一个数组。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">var</span> obj = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> };
<span class="hljs-keyword">let</span> arr = [...obj]; <span class="hljs-comment">// TypeError: Cannot spread non-iterable object</span>
</code></pre>
4:["$","div",null,{"className":"markdown-body","children":["$","article",null,{"dangerouslySetInnerHTML":{"__html":"$c"}}]}]
a:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
8:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"front-end"}],["$","meta","2",{"name":"description","content":"front-end knowledge"}],["$","link","3",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
6:null
