<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/ec0a9d078e716e00.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/485ff6fe79292a08.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/0ff121a467c0636f.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-038c2e688b596d0e.js"/><script src="/_next/static/chunks/4bd1b696-20882bf820444624.js" async=""></script><script src="/_next/static/chunks/517-98ed787e5f259f2c.js" async=""></script><script src="/_next/static/chunks/main-app-f33d3e3aed85e21f.js" async=""></script><meta name="next-size-adjust" content=""/><title>front-end</title><meta name="description" content="front-end knowledge"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><main><div class="markdown-body"><h1>RegExp 语法</h1><article><h1>RegExp 语法</h1>
<h2>元字符</h2>
<p><strong>元字符（Meta-Character）</strong> 指那些在正则表达式中具有特殊意义的专用字符，可以用来规定其前导字符（即位于元字符前面的字符）在目标对象中的出现模式。</p>
<table>
<thead>
<tr>
<th style="text-align:left">元字符</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">匹配对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>.</code></td>
<td style="text-align:left">点号</td>
<td style="text-align:left">单个任意字符(除回车 <code>\r</code>、换行 <code>\n</code>、行分隔符 <code>\u2028</code> 和段分隔符 <code>\u2029</code> 外)</td>
</tr>
<tr>
<td style="text-align:left"><code>[]</code></td>
<td style="text-align:left">字符组</td>
<td style="text-align:left">列出的单个任意字符</td>
</tr>
<tr>
<td style="text-align:left"><code>[^]</code></td>
<td style="text-align:left">排除型字符组</td>
<td style="text-align:left">未列出的单个任意字符</td>
</tr>
<tr>
<td style="text-align:left"><code>?</code></td>
<td style="text-align:left">问号</td>
<td style="text-align:left">匹配 0 次或 1 次</td>
</tr>
<tr>
<td style="text-align:left"><code>*</code></td>
<td style="text-align:left">星号</td>
<td style="text-align:left">匹配 0 次或多次</td>
</tr>
<tr>
<td style="text-align:left"><code>+</code></td>
<td style="text-align:left">加号</td>
<td style="text-align:left">匹配 1 次或多次</td>
</tr>
<tr>
<td style="text-align:left"><code>{min,max}</code></td>
<td style="text-align:left">区间量词</td>
<td style="text-align:left">匹配至少 min 次，最多 max 次</td>
</tr>
<tr>
<td style="text-align:left"><code>^</code></td>
<td style="text-align:left">脱字符</td>
<td style="text-align:left">行的起始位置</td>
</tr>
<tr>
<td style="text-align:left"><code>$</code></td>
<td style="text-align:left">美元符</td>
<td style="text-align:left">行的结束位置</td>
</tr>
<tr>
<td style="text-align:left">`</td>
<td style="text-align:left">`</td>
<td style="text-align:left">竖线</td>
</tr>
<tr>
<td style="text-align:left"><code>()</code></td>
<td style="text-align:left">括号</td>
<td style="text-align:left">限制多选结构的范围，标注量词作用的元素，为反向引用捕获文本</td>
</tr>
<tr>
<td style="text-align:left"><code>\1,\2...</code></td>
<td style="text-align:left">反向引用</td>
<td style="text-align:left">匹配之前的第一、第二...组括号内的表达式匹配的文本</td>
</tr>
</tbody>
</table>
<h2>字符类别</h2>
<h3>字符组简记</h3>
<p>用 <code>[0-9]</code>、<code>[a-z]</code> 等字符组，可以很方便地表示数字字符和小写字母字符。对于这类常用字符组，正则表达式提供了更简单的记法，这就是<strong>字符组简记（Shorthands）</strong>。</p>
<p>常见的字符组简记有 <code>\d</code>、<code>\w</code>、<code>\s</code>，其中：</p>
<ul>
<li><code>d</code> 表示（Digit）数字</li>
<li><code>w</code> 表示（Word）单词</li>
<li><code>s</code> 表示（Space）空白</li>
</ul>
<p>正则表达式也提供了对应排除型字符组的简记法：<code>\D</code>、<code>\W</code>、<code>\S</code>。字母完全相同，只是改为大写，这些简记法匹配的字符互补。</p>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\d</code></td>
<td style="text-align:center">数字，等同于 <code>[0-9]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\D</code></td>
<td style="text-align:center">非数字，等同于 <code>[^0-9]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\s</code></td>
<td style="text-align:center">空白字符，等同于 <code>[\f\n\r\t\u000B\u0020\u00A0\u2028\u2029]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\S</code></td>
<td style="text-align:center">非空白字符，等同于 <code>[^\f\n\r\t\u000B\u0020\u00A0\u2028\u2029]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\w</code></td>
<td style="text-align:center">字母、数字、下划线，等同于 <code>[0-9A-Za-z_]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\W</code></td>
<td style="text-align:center">非字母、数字、下划线，等同于 <code>[^0-9A-Za-z_]</code></td>
</tr>
</tbody>
</table>
<h3>任意字符</h3>
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>.</code></td>
<td style="text-align:left">表示除回车 <code>(\r)</code>、换行 <code>(\n)</code>、行分隔符 <code>(\u2028)</code> 和段分隔符 <code>(\u2029)</code> 以外的任意字符。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>⚠️ <strong>注意</strong>：一般认为点号可以代表任意字符，其实并不是</p>
<p>妥善的利用互补属性，可以得到一些巧妙的效果。比如，<code>[\s\S]</code>、<code>[\w\W]</code>、<code>[\d\D]</code> 都可以表示任意字符。</p>
</blockquote>
<p><strong>匹配任意字符</strong></p>
<pre class="hljs"><code class="language-js">/./.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;\r&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/[\s\S]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;\r&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<h3>转义字符</h3>
<p><strong>转义字符（Escape）</strong> 表示为反斜线 <code>\</code> 加字符的形式，共有以下 3 种情况。</p>
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>\</code> + 元字符</td>
<td style="text-align:left">匹配元字符</td>
</tr>
<tr>
<td style="text-align:left"><code>\</code> + <code>]</code> 或 <code>\</code> + <code>}</code></td>
<td style="text-align:left">右方括号和右花括号无需转义</td>
</tr>
<tr>
<td style="text-align:left"><code>\</code> + 非元字符</td>
<td style="text-align:left">表示一些不能打印的特殊字符</td>
</tr>
<tr>
<td style="text-align:left"><code>\</code> + 除上述其他字符</td>
<td style="text-align:left">默认情况匹配此字符</td>
</tr>
</tbody>
</table>
<p>&lt;br /&gt;</p>
<p>因为元字符有特殊的含义，所以无法直接匹配。如果要匹配它们本身，则需要在它们前面加上反斜杠 <code>\</code>。</p>
<pre class="hljs"><code class="language-js">/<span class="hljs-number">1</span>+<span class="hljs-number">1</span>/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;1+1&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/1\+1/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;1+1&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/\*/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;*&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-comment">/*/.test(&#x27;*&#x27;);
// 报错
</span></code></pre>
<p>但实际上，并非 14 个元字符都需要转义，右方括号 <code>]</code> 和右花括号 <code>}</code> 不需要转义</p>
<pre class="hljs"><code class="language-js">/]/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;]&#x27;</span>);
<span class="hljs-comment">// true</span>
<span class="hljs-regexp">/\]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;]&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/\}/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;}&#x27;</span>);
<span class="hljs-comment">// true</span>
<span class="hljs-regexp">/}/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;}&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<p><code>\</code> 加非元字符，表示一些不能打印的特殊字符。</p>
<p>&lt;br /&gt;</p>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\0</code></td>
<td style="text-align:center">NUL 字符 <code>\u0000</code></td>
</tr>
<tr>
<td style="text-align:center"><code>[\b]</code></td>
<td style="text-align:center">匹配退格符 <code>\u0008</code>，不要与 <code>\b</code> 混淆</td>
</tr>
<tr>
<td style="text-align:center"><code>\t</code></td>
<td style="text-align:center">制表符 <code>\u0009</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\n</code></td>
<td style="text-align:center">换行符 <code>\u000A</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\v</code></td>
<td style="text-align:center">垂直制表符 <code>\u000B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\f</code></td>
<td style="text-align:center">换页符 <code>\u000C</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\r</code></td>
<td style="text-align:center">回车符 <code>\u000D</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\xnn</code></td>
<td style="text-align:center">由十六进制数 <code>nn</code> 指定的拉丁字符</td>
</tr>
<tr>
<td style="text-align:center"><code>\uxxxx</code></td>
<td style="text-align:center">由十六进制数 <code>xxxx</code> 指定的 Unicode 字符( <code>\u4e00</code> - <code>\u9fa5</code> 代表中文)</td>
</tr>
<tr>
<td style="text-align:center"><code>\cX</code></td>
<td style="text-align:center">控制字符 <code>^X</code>，表示 <code>ctrl-[X]</code> ，其中的 X 是 A-Z 之中任一个英文字母，用来匹配控制字符</td>
</tr>
</tbody>
</table>
<p><code>\</code> 加任意其他字符，默认情况就是匹配此字符，也就是说，反斜线 <code>(\)</code> 被忽略了。</p>
<pre class="hljs"><code class="language-js">/\x/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;x&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/\y/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;y&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/\z/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;z&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<h3>双重转义</h3>
<p>由于 <code>RegExp</code> 构造函数的参数是字符串，所以某些情况下，需要对字符进行 <strong>双重转义</strong>。</p>
<p>字符 <code>\</code> 在正则表达式字符串中通常被转义为 <code>\\</code> 。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> reg1 = <span class="hljs-regexp">/\.at/</span>;
<span class="hljs-comment">// 等价于</span>
<span class="hljs-keyword">const</span> reg2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;\\.at&#x27;</span>);

<span class="hljs-keyword">const</span> reg3 = <span class="hljs-regexp">/name\/age/</span>;
<span class="hljs-comment">// 等价于</span>
<span class="hljs-keyword">const</span> reg4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;name\\/age&#x27;</span>);

<span class="hljs-keyword">const</span> reg5 = <span class="hljs-regexp">/\w\\hello\\123/</span>;
<span class="hljs-comment">// 等价于</span>
<span class="hljs-keyword">const</span> reg6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;\\w\\\\hello\\\\123&#x27;</span>);
</code></pre>
<h2>字符集合</h2>
<p><strong>字符集合（Character Sets）</strong>，有的编译成字符类或字符集。简单而言，就是指用方括号表示的一组字符，它匹配若干字符之一。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[xyz]</code></td>
<td>一个字符集合，也叫字符组。匹配集合中任意一个字符。可以使用 <code>-</code> 指定一个范围。</td>
</tr>
<tr>
<td><code>[^xyz]</code></td>
<td>一个反义或补充字符集，也叫反义字符组。匹配任意不包括括号内的字符。可以使用 <code>-</code> 指定一个范围。</td>
</tr>
</tbody>
</table>
<p>&lt;br /&gt;</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 匹配 0-9 这 10 个数字之一</span>
<span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/[0123456789]/</span>;

regexp.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;1&#x27;</span>);
<span class="hljs-comment">// true</span>

regexp.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;a&#x27;</span>);
<span class="hljs-comment">// false</span>
</code></pre>
<p>字符组中的字符排列顺序并不影响字符组的功能，出现重复字符也不会影响。</p>
<p>以下三个表达式都是相等的。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> regexp1 = <span class="hljs-regexp">/[0123456789]/</span>;

<span class="hljs-keyword">const</span> regexp2 = <span class="hljs-regexp">/[9876543210] /</span>;

<span class="hljs-keyword">const</span> regexp3 = <span class="hljs-regexp">/[1234567890123456789]/</span>;
</code></pre>
<h3>范围</h3>
<p>正则表达式通过连字符 <code>(-)</code> 提供了范围表示法，可以简化字符组</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> regexp1 = <span class="hljs-regexp">/[0123456789]/</span>;
<span class="hljs-comment">// 等价于</span>
<span class="hljs-keyword">const</span> regexp2 = <span class="hljs-regexp">/[0-9]/</span>;

<span class="hljs-keyword">const</span> regexp3 = <span class="hljs-regexp">/[abcdefghijklmnopqrstuvwxyz]/</span>;
<span class="hljs-comment">// 等价于</span>
<span class="hljs-keyword">const</span> regexp4 = <span class="hljs-regexp">/[a-z]/</span>;
</code></pre>
<p>连字符 <code>(-)</code> 表示的范围是根据 ASCII 编码的码值来确定的，码值小的在前，码值大的在后。</p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../../assets/regexp/ascii.gif&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;ASCII编码表&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{720}</span> /&gt;</span></span>;
</code></pre>
<p>所以 <code>[0-9]</code> 是合法的，而 <code>[9-0]</code> 会报错。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">//匹配 0-9 这 10 个数字之一</span>
<span class="hljs-keyword">const</span> regexp1 = <span class="hljs-regexp">/[0-9]/</span>;
regexp1.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;1&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-keyword">const</span> regexp2 = <span class="hljs-regexp">/[9-0]/</span>;
<span class="hljs-comment">// 报错</span>
regexp2.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;1&#x27;</span>);
</code></pre>
<p>在字符组中可以同时并列多个 <code>-</code> 范围。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> regexp1 = <span class="hljs-regexp">/[0-9a-zA-Z]/</span>;
<span class="hljs-comment">// 匹配数字、大写字母和小写字母</span>
<span class="hljs-keyword">const</span> regexp2 = <span class="hljs-regexp">/[0-9a-fA-F]/</span>;
<span class="hljs-comment">// 匹配数字，大、小写形式的a-f，用来验证十六进制字符</span>

<span class="hljs-keyword">const</span> regexp3 = <span class="hljs-regexp">/[0-9a-fA-F]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;d&#x27;</span>);
<span class="hljs-comment">// true</span>
<span class="hljs-keyword">const</span> regexp4 = <span class="hljs-regexp">/[0-9a-fA-F]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;x&#x27;</span>);
<span class="hljs-comment">// false</span>
</code></pre>
<p>只有在字符组内部，连字符 <code>-</code> 才是元字符，表示一个范围，否则它就只能匹配普通的连字符号。</p>
<p>如果连字符出现在字符组的开头或末尾，它表示的也是普通的连字符号，而不是一个范围。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 匹配中划线</span>
/-/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;-&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/[-]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;-&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-comment">// 匹配0-9的数字或中划线</span>
<span class="hljs-regexp">/[0-9]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;-&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/[0-9-]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;-&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/[0-9\-]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;-&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/[-0-9]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;-&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/[\-0-9]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;-&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<h3>排除</h3>
<p>字符组的另一个类型是 <strong>排除型字符组</strong>，在左方括号后紧跟一个脱字符 <code>^</code> 表示，表示在当前位置匹配一个没有列出的字符。</p>
<p>所以 <code>[^0-9]</code> 表示 0-9 以外的字符。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 匹配第一个是数字字符，第二个不是数字字符的字符串</span>
/[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>][^<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;1e&#x27;</span>);
<span class="hljs-comment">// true</span>
<span class="hljs-regexp">/[0-9][^0-9]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;q2&#x27;</span>);
<span class="hljs-comment">// false</span>
</code></pre>
<p>在字符组内部，脱字符 <code>^</code> 表示排除，而在字符组外部，脱字符 <code>^</code> 表示一个行锚点。</p>
<p><code>^</code> 符号是元字符，在字符组中只要 <code>^</code> 符号不挨着左方括号就可以表示其本身含义，不转义也可以。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 匹配 abc 和 ^ 符号</span>
/[a-c^]/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;^&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/[a-c\^]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;^&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/[\^a-c]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;^&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<p>在字符组中，只有 <code>^</code> 、 <code>-</code> 、<code>[</code> 、<code>]</code> 这 4 个字符可能被当做元字符，其他有元字符功能的字符都只表示其本身。</p>
<pre class="hljs"><code class="language-js">/[[<span class="hljs-number">1</span>]]/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;[&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/[[1]]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;]&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/[\1]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;\\&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/[^^]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;^&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/[1-2]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;-&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/[\[1\]]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;[&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/[\[1\]]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;]&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/[\\]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;\\&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/[^]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;^&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/[1-2\-]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;-&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<h2>数量词</h2>
<p>正则表达式提供了量词，用来设定某个模式出现的次数。</p>
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>x*</code></td>
<td style="text-align:left">相当于 <code>x{0,}</code> （匹配任意多次）</td>
</tr>
<tr>
<td style="text-align:left"><code>x+</code></td>
<td style="text-align:left">相当于 <code>x{1,}</code>（匹配至少一次）</td>
</tr>
<tr>
<td style="text-align:left"><code>x?</code></td>
<td style="text-align:left">相当于 <code>x{0,1}</code> （不匹配或匹配一次）</td>
</tr>
<tr>
<td style="text-align:left"><code>x*?</code> 或 <code>x+?</code></td>
<td style="text-align:left">相当于 <code>*</code> 和 <code>+</code>字符，然而匹配的是最小可能匹配</td>
</tr>
<tr>
<td style="text-align:left"><code>x(?=y)</code></td>
<td style="text-align:left">只有当 <code>x</code> 后面紧跟着 <code>y</code> 时，才匹配 <code>x</code>。（了解详情请看 <a href="/front-end/standard-built-in-objects/text-processing/regexp/#%E7%8E%AF%E8%A7%86">环视</a>）</td>
</tr>
<tr>
<td style="text-align:left"><code>x(?!y)</code></td>
<td style="text-align:left">只有当 <code>x</code> 后面不是紧跟着 <code>y</code> 时，才匹配 <code>x</code>。（了解详情请看 <a href="/front-end/standard-built-in-objects/text-processing/regexp/#%E7%8E%AF%E8%A7%86">环视</a>）</td>
</tr>
<tr>
<td style="text-align:left"><code>x|y</code>（这里是没有 <code>\</code> 的）</td>
<td style="text-align:left">匹配 <code>x</code> 或 <code>y</code></td>
</tr>
<tr>
<td style="text-align:left"><code>x{n}</code></td>
<td style="text-align:left">匹配 <code>n</code> 次（<code>n</code> 为正整数）</td>
</tr>
<tr>
<td style="text-align:left"><code>x{n,m}</code></td>
<td style="text-align:left">匹配至少 <code>n</code> 次，最多 <code>m</code> 次（<code>n</code> 和 <code>m</code> 为正整数）</td>
</tr>
<tr>
<td style="text-align:left"><code>x{n,}</code></td>
<td style="text-align:left">匹配至少 <code>n</code> 次（<code>n</code> 为正整数）</td>
</tr>
</tbody>
</table>
<p>&lt;br /&gt;</p>
<p>邮政编码</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 表示邮政编码 6 位数字</span>
<span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/\d{6}/</span>;
</code></pre>
<p>美国英语和英国英语有些词的写法不一样，如果 <code>traveler</code> 和 <code>traveller</code>，<code>favor</code> 和 <code>favour</code>，<code>color</code> 和 <code>colour</code>。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 同时匹配美国英语和英国英语单词</span>
<span class="hljs-keyword">const</span> regexp1 = <span class="hljs-regexp">/travell?er/</span>;

<span class="hljs-keyword">const</span> regexp2 = <span class="hljs-regexp">/favou?r/</span>;

<span class="hljs-keyword">const</span> regexp3 = <span class="hljs-regexp">/colou?r/</span>;
</code></pre>
<p>协议名有 HTTP 和 HTTPS 两种：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> regexp1 = <span class="hljs-regexp">/https?/</span>;
</code></pre>
<h3>选择</h3>
<p>竖线 <code>|</code> 在正则表达式中表示或关系的选择，以竖线 <code>|</code> 分隔开的多个子表达式也叫选择分支或选择项。在一个选择结构中，选择分支的数目没有限制。</p>
<p>在选择结构中，竖线 <code>|</code> 用来分隔选择项，而括号 <code>()</code> 用来规定整个选择结构的范围。如果没有出现括号，则将整个表达式视为一个选择结构。</p>
<p>选择项的尝试匹配次序是从左到右，直到发现了匹配项，如果某个选择项匹配就忽略右侧其他选择项，如果所有子选择项都不匹配，则整个选择结构匹配失败。</p>
<pre class="hljs"><code class="language-js">/<span class="hljs-number">12</span>|<span class="hljs-number">23</span>|<span class="hljs-number">34</span>/.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;1&#x27;</span>);
<span class="hljs-comment">// null</span>

<span class="hljs-regexp">/12|23|34/</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;12&#x27;</span>);
<span class="hljs-comment">// [&#x27;12&#x27;]</span>

<span class="hljs-regexp">/12|23|34/</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;23&#x27;</span>);
<span class="hljs-comment">// [&#x27;23&#x27;]</span>

<span class="hljs-regexp">/12|23|34/</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;2334&#x27;</span>);
<span class="hljs-comment">// [&#x27;23&#x27;]</span>
</code></pre>
<p>IP 地址一般由 3 个点号和 4 段数字组成，每段数字都在 0-255 之间。</p>
<ul>
<li>0-199：<code>[01]?\d\d?</code></li>
<li>200-249：<code>2[0-4]\d</code></li>
<li>250-255：<code>25[0-5]</code></li>
</ul>
<p>IP 地址：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> ipRegExp = <span class="hljs-regexp">/((2[0-4]\d|25[0-5]|[0-1]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[0-1]?\d\d?)/</span>;

ipRegExp.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;1.1.1.1&#x27;</span>);
<span class="hljs-comment">// true</span>

ipRegExp.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;1.1.1&#x27;</span>);
<span class="hljs-comment">// false</span>

ipRegExp.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;256.1.1.1&#x27;</span>);
<span class="hljs-comment">// false</span>
</code></pre>
<p>类似地，时间匹配也需要分段处理：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 月(1-12)</span>
<span class="hljs-number">0</span>?\d|<span class="hljs-number">1</span>[<span class="hljs-number">0</span>-<span class="hljs-number">2</span>]

<span class="hljs-comment">// 日(1-31)</span>
<span class="hljs-number">0</span>?\d|[<span class="hljs-number">12</span>]\d|<span class="hljs-number">3</span>[<span class="hljs-number">01</span>]

<span class="hljs-comment">// 小时(0-24)</span>
<span class="hljs-number">0</span>?\d|<span class="hljs-number">1</span>\d|<span class="hljs-number">2</span>[<span class="hljs-number">0</span>-<span class="hljs-number">4</span>]

<span class="hljs-comment">// 分钟(0-60)</span>
<span class="hljs-number">0</span>?\d|[<span class="hljs-number">1</span>-<span class="hljs-number">5</span>]\d|<span class="hljs-number">60</span>
</code></pre>
<p>手机号一般是 11 位，前 3 位是号段，后 8 位一般没有限制。而且，在手机开头很可能有 0 或+86。</p>
<ul>
<li>开头：<code>(0|\+86)?</code></li>
<li>前 3 位：<code>13\d|14[579]|15[0-35-9]|17[0135-8]|18\d</code></li>
<li>后 8 位：<code>\d{8}</code></li>
</ul>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> phone = <span class="hljs-regexp">/(0|\+86)?(13\d|14[579]|15[0-35-9]|17[0135-8]|18\d)\d{8}/</span>;

phone.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;13453250661&#x27;</span>);
<span class="hljs-comment">// true</span>

phone.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;1913250661&#x27;</span>);
<span class="hljs-comment">// false</span>

phone.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;1345325061&#x27;</span>);
<span class="hljs-comment">// false</span>
</code></pre>
<p>在选择结构中，应该尽量避免选择分支中存在重复匹配，因为这样会大大增加回溯的计算量</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 错误示范 🙅‍♂️</span>
<span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/a|[ab][0-9]|\w/</span>;
</code></pre>
<h3>贪婪模式</h3>
<p>默认情况下，量词都是<strong>贪婪模式（Greedy quantifier）</strong>，即匹配到下一个字符不满足匹配规则为止。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// exec 方法以数组的形式返回匹配结果</span>
/a+/.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>);
<span class="hljs-comment">// [&#x27;aaa&#x27;]</span>
</code></pre>
<h3>懒惰模式</h3>
<p><strong>懒惰模式（Lazy quantifier）</strong> 和贪婪模式相对应，在量词后加问号 <code>?</code> 表示，表示尽可能少的匹配，一旦条件满足就再不往下匹配。</p>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>{n}?</code></td>
<td style="text-align:left">匹配 <code>n</code> 次</td>
</tr>
<tr>
<td style="text-align:left"><code>{n,m}?</code></td>
<td style="text-align:left">匹配至少 <code>n</code> 次，最多 <code>m</code> 次</td>
</tr>
<tr>
<td style="text-align:left"><code>{n,}?</code></td>
<td style="text-align:left">匹配至少 <code>n</code> 次</td>
</tr>
<tr>
<td style="text-align:left"><code>??</code></td>
<td style="text-align:left">相当于<code>{0,1}</code></td>
</tr>
<tr>
<td style="text-align:left"><code>*?</code></td>
<td style="text-align:left">相当于<code>{0,}</code></td>
</tr>
<tr>
<td style="text-align:left"><code>+?</code></td>
<td style="text-align:left">相当于<code>{1,}</code></td>
</tr>
</tbody>
</table>
<p>&lt;br /&gt;</p>
<p>示例：</p>
<pre class="hljs"><code class="language-js">/a+?/.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>);
<span class="hljs-comment">// [&#x27;a&#x27;]</span>
</code></pre>
<p>匹配 <code>&lt;script&gt;&lt;/script&gt;</code> 之间的代码看上去很容易</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/&lt;script&gt;[\s\S]*&lt;\/script&gt;/</span>;

regexp.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;&lt;script&gt;alert(&quot;1&quot;);&lt;/script&gt;&#x27;</span>);
<span class="hljs-comment">// [&quot;&lt;script&gt;alert(&quot;1&quot;);&lt;/script&gt;&quot;]</span>
</code></pre>
<p>但如果多次出现 <code>script</code> 标签，就会出问题</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/&lt;script&gt;[\s\S]*&lt;\/script&gt;/</span>;

regexp.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;&lt;script&gt;alert(&quot;1&quot;);&lt;/script&gt;&lt;br&gt;&lt;script&gt;alert(&quot;2&quot;);&lt;/script&gt;&#x27;</span>);
<span class="hljs-comment">// [&quot;&lt;script&gt;alert(&quot;1&quot;);&lt;/script&gt;&lt;br&gt;&lt;script&gt;alert(&quot;2&quot;);&lt;/script&gt;&quot;]</span>
</code></pre>
<p>它把无用的 <code>&lt;br&gt;</code> 标签也匹配出来了，此时就需要使用懒惰模式</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/&lt;script&gt;[\s\S]*?&lt;\/script&gt;/</span>;

regexp.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;&lt;script&gt;alert(&quot;1&quot;);&lt;/script&gt;&lt;br&gt;&lt;script&gt;alert(&quot;2&quot;);&lt;/script&gt;&#x27;</span>);
<span class="hljs-comment">// [&quot;&lt;script&gt;alert(&quot;1&quot;);&lt;/script&gt;&quot;]</span>
</code></pre>
<p>在 JavaScript 中，<code>/* */</code> 是注释的一种形式，在文档中可能出现多次，这时就必须使用懒惰模式</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/\/\*[\s\S]*?\*\//</span>;

regexp.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;/*abc*/&lt;br&gt;/*123*/&#x27;</span>);
<span class="hljs-comment">// [&quot;/*abc*/&quot;]</span>
</code></pre>
<h2>分组与反向引用</h2>
<h3>分组</h3>
<p>量词控制之前元素的出现次数，而这个元素可能是一个字符，也可能是一个字符组，也可以是一个表达式。</p>
<p>如果把一个表达式用括号包围起来，这个元素就是括号里的表达式，被称为 <strong>子表达式</strong>。</p>
<p><strong>示例 1</strong>：如果希望字符串 <code>ab</code> 重复出现 2 次，应该写为 <code>(ab){2}</code>，而如果写为 <code>ab{2}</code>，则 <code>{2}</code> 只限定 <code>b</code>。</p>
<pre class="hljs"><code class="language-js">/(ab){<span class="hljs-number">2</span>}/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abab&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/(ab){2}/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abb&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/ab{2}/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abab&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/ab{2}/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abb&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<p><strong>示例 2</strong>：身份证长度有 15 位和 18 位两种，如果只匹配长度，可能会想当然地写成 <code>\d{15,18}</code>，实际上这是错误的，因为它包括 15、16、17、18 这四种长度。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 正确写法</span>
<span class="hljs-keyword">var</span> idCard = <span class="hljs-regexp">/\d{15}(\d{3})?/</span>;
</code></pre>
<p><strong>示例 3</strong>：Email 地址以 <code>@</code> 分隔成两段，之前的部分是用户名，之后的部分是主机名。</p>
<p>用户名允许出现数字、字母和下划线，长度一般在 1-64 个字符之间，则正则可表示为 <code>/\w{1,64}/</code></p>
<p>主机名一般表现为 <code>a.b.···.c</code>，其中 <code>c</code> 为主域名，其他为级数不定的子域名，则正则可表示为 <code>/([-a-zA-z0-9]{1,63}\.)+[-a-zA-Z0-9]{1,63}/</code></p>
<p>所以 email 地址的正则表达式如下：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> email = <span class="hljs-regexp">/\w{1,64}@([-a-zA-z0-9]{1,63}\.)+[-a-zA-Z0-9]{1,63}/</span>;

email.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;q@qq.com&#x27;</span>);
<span class="hljs-comment">// true</span>

email.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;q@qq&#x27;</span>);
<span class="hljs-comment">// false</span>

email.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;q@a.qq.com&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<h3>捕获</h3>
<p>括号不仅可以对元素进行分组，还会保存每个分组匹配的文本，等到匹配完成后，引用捕获的内容。因为捕获了文本，这种功能叫 <strong>捕获分组</strong>。</p>
<p>比如，要匹配诸如 <code>2016-06-23</code> 这样的日期字符串</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/(\d{4})-(\d{2})-(\d{2})/</span>;
</code></pre>
<p>与以往不同的是，年、月、日这三个数值被括号括起来了，从左到右为第 1 个括号、第 2 个括号和第 3 个括号，分别代表第 1、2、3 个捕获组。</p>
<p>JavaScript 有 9 个用于存储捕获组的构造函数属性。</p>
<p><code>RegExp.$1</code>、<code>RegExp.$2</code>、<code>RegExp.$3</code> 到 <code>RegExp.$9</code> 分别用于存储第一、第二第九个匹配的捕获组。</p>
<p>在调用 <code>exec()</code> 或 <code>test()</code> 方法时，这些属性会被自动填充。</p>
<pre class="hljs"><code class="language-js">/(\d{<span class="hljs-number">4</span>})-(\d{<span class="hljs-number">2</span>})-(\d{<span class="hljs-number">2</span>})/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;2016-06-23&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$1</span>);
<span class="hljs-comment">// &#x27;2016&#x27;</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$2</span>);
<span class="hljs-comment">// &#x27;06&#x27;</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$3</span>);
<span class="hljs-comment">// &#x27;23&#x27;</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$4</span>);
<span class="hljs-comment">// &#x27;&#x27;</span>
</code></pre>
<p>而 <code>exec()</code> 方法是专门为捕获组而设计的，返回的数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串。</p>
<pre class="hljs"><code class="language-js">/(\d{<span class="hljs-number">4</span>})-(\d{<span class="hljs-number">2</span>})-(\d{<span class="hljs-number">2</span>})/.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;2016-06-23&#x27;</span>);
<span class="hljs-comment">// [&quot;2016-06-23&quot;, &quot;2016&quot;, &quot;06&quot;, &quot;23&quot;]</span>
</code></pre>
<p>捕获分组捕获的文本，不仅可以 <strong>用于数据提取</strong>，也可以 <strong>用于替换</strong>。</p>
<p><code>replace()</code> 方法就是用于进行数据替换的，该方法接收两个参数，第一个参数为待查找的内容，而第二个参数为替换的内容。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-string">&#x27;2000-01-01&#x27;</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/-/g</span>, <span class="hljs-string">&#x27;.&#x27;</span>);
<span class="hljs-comment">// 2000.01.01</span>
</code></pre>
<p>在 <code>replace()</code> 方法中也可以引用分组，形式是 <code>$num</code>， <code>num</code> 是对应分组的编号。</p>
<p>把 <code>2000-01-01</code> 的形式变成 <code>01-01-2000</code> 的形式：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-string">&#x27;2000-01-01&#x27;</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(\d{4})-(\d{2})-(\d{2})/g</span>, <span class="hljs-string">&#x27;$3-$2-$1&#x27;</span>);
<span class="hljs-comment">//&#x27;01-01-2000&#x27;</span>
</code></pre>
<h3>反向引用</h3>
<p>英文中不少单词都有重叠出现的字母，如 <code>shoot</code> 或 <code>beep</code>。若想检查某个单词是否包含重叠出现的字母，则需要引入 <strong>反向引用（back-reference）</strong></p>
<p>反向引用允许在正则表达式内部引用之前捕获分组匹配的文本，形式是 <code>\num</code>，<code>num</code> 表示所引用分组的编号。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">//重复字母</span>
/([a-z])\<span class="hljs-number">1</span>/

<span class="hljs-regexp">/([a-z])\1/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;aa&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/([a-z])\1/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;ab&#x27;</span>);
<span class="hljs-comment">// false</span>
</code></pre>
<p>反向引用可以用于建立前后联系。HTML 标签的开始标签和结束标签是对应的。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 开始标签</span>
<span class="hljs-keyword">const</span> startIndex = <span class="hljs-regexp">/&lt;([^&gt;]+)&gt;/</span>

<span class="hljs-comment">// 标签内容</span>
<span class="hljs-keyword">const</span> content = <span class="hljs-regexp">/[\s\S]*?/</span>

<span class="hljs-comment">// 匹配成对的标签</span>
<span class="hljs-keyword">const</span> couple = <span class="hljs-regexp">/&lt;([^&gt;]+)&gt;[\s\S]*?&lt;\/\1&gt;/</span>

<span class="hljs-regexp">/&lt;([^&gt;]+)&gt;[\s\S]*?&lt;\/\1&gt;/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;&lt;a&gt;123&lt;/a&gt;&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/&lt;([^&gt;]+)&gt;[\s\S]*?&lt;\/\1&gt;/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;&lt;a&gt;123&lt;/b&gt;&#x27;</span>);
<span class="hljs-comment">// false</span>
</code></pre>
<h3>非捕获</h3>
<p>除了捕获分组，正则表达式还提供了 <strong>非捕获分组(non-capturing group)</strong>，以 <code>(?:)</code> 的形式表示，它只用于限定作用范围，而不捕获任何文本。</p>
<p>比如，要匹配 <code>abcabc</code> 这个字符，一般地，可以写为 <code>(abc){2}</code>，但由于并不需要捕获文本，只是限定了量词的作用范围，所以应该写为 <code>(?:abc){2}</code>。</p>
<pre class="hljs"><code class="language-js">/(abc){<span class="hljs-number">2</span>}/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abcabc&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/(?:abc){2}/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abcabc&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<p>由于非捕获分组不捕获文本，对应地，也就没有捕获组编号。</p>
<pre class="hljs"><code class="language-js">/(abc){<span class="hljs-number">2</span>}/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abcabc&#x27;</span>);
<span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$1</span>);
<span class="hljs-comment">// &#x27;abc&#x27;</span>

<span class="hljs-regexp">/(?:abc){2}/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abcabc&#x27;</span>);
<span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$1</span>);
<span class="hljs-comment">// &#x27;&#x27;</span>
</code></pre>
<p>非捕获分组也不可以使用反向引用。</p>
<pre class="hljs"><code class="language-js">/(?:<span class="hljs-number">123</span>)\<span class="hljs-number">1</span>/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;123123&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/(123)\1/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;123123&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<p>捕获分组和非捕获分组可以在一个正则表达式中同时出现。</p>
<pre class="hljs"><code class="language-js">/(\d)(\d)(?:\d)(\d)(\d)/.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;12345&#x27;</span>);
<span class="hljs-comment">// [&quot;12345&quot;, &quot;1&quot;, &quot;2&quot;, &quot;4&quot;, &quot;5&quot;]</span>
</code></pre>
<h2>断言</h2>
<p>在正则表达式中，有些结构并不真正匹配文本，而只负责判断在某个位置左/右侧是否符合要求，这种结构被称为 <strong>断言（assertion）</strong>，也称为 <strong>锚点（anchor）</strong>，常见的断言有 3 种：</p>
<ul>
<li>单词边界</li>
<li>起始结束</li>
<li>环视</li>
</ul>
<h3>单词边界</h3>
<p>在文本处理中可能会经常进行单词替换，比如把 <code>row</code> 替换成 <code>line</code>。但是，如果直接替换，不仅所有单词 <code>row</code> 都被替换成 <code>line</code>，单词内部的 <code>row</code> 也会被替换成 <code>line</code>。要想解决这个问题，必须有办法确定单词 <code>row</code>，而不是字符串 <code>row</code>。</p>
<p>为了解决这类问题，正则表达式提供了专用的 <strong>单词边界（word boundary）</strong>，记为 <code>\b</code> ，它匹配的是 单词边界 的位置，而不是字符。<code>\b</code> 匹配的是一边是单词字符 <code>\w</code> ，一边是非单词字符 <code>\W</code> 的位置</p>
<p>与 <code>\b</code> 对应的还有 <code>\B</code>，表示非单词边界，但实际上 <code>\B</code> 很少使用</p>
<pre class="hljs"><code class="language-js">/\ban\b/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;an apple&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/\ban\b/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;a an&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/\ban\b/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;an&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/\ban\b/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;and&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/\ban\b/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;ban&#x27;</span>);
<span class="hljs-comment">// false</span>
</code></pre>
<h3>起始结束</h3>
<p>常见的断言还有 <code>^</code> 和 <code>$</code>，它们分别匹配字符串的开始位置和结束位置，所以可以用来判断整个字符串能否由表达式匹配。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">//匹配第一个单词</span>
/^\w*/.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;first word\nsecond word\nthird word&#x27;</span>);
<span class="hljs-comment">// [&#x27;first&#x27;]</span>

<span class="hljs-comment">//匹配最后一个单词</span>
<span class="hljs-regexp">/\w*$/</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;first word\nsecond word\nthird word&#x27;</span>);
<span class="hljs-comment">// [&#x27;word&#x27;]</span>

<span class="hljs-regexp">/^a$/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;a\n&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/^a$/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;a&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<p><code>^</code> 和 <code>$</code> 的常用功能是删除字符串首尾多余的空白，类似于字符串 <code>String</code> 对象的 <code>trim()</code> 方法。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fnTrim</span>(<span class="hljs-params">str</span>) {
  str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\s+|\s+$/</span>, <span class="hljs-string">&#x27;&#x27;</span>);
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fnTrim</span>(<span class="hljs-string">&#x27;      hello world   &#x27;</span>));
<span class="hljs-comment">// &#x27;hello world&#x27;</span>
</code></pre>
<h3>环视</h3>
<p><strong>环视（Look-around）</strong>，可形象地解释为停在原地，四处张望。环视类似于单词边界，在它旁边的文本需要满足某种条件，而且本身不匹配任何字符。</p>
<p>环视分为 <strong>正序环视</strong> 和 <strong>逆序环视</strong>，而 JavaScript 只支持正序环视，相当于只支持向前看，不支持往回看。</p>
<p>而正序环视又分为 <strong>肯定正序环视</strong> 和 <strong>否定正序环视</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>x(?=y)</code></td>
<td style="text-align:left"><strong>肯定</strong> 正序环视，表示 <code>x</code> 后紧跟着 <code>y</code> 才匹配</td>
</tr>
<tr>
<td style="text-align:left"><code>x(?!y)</code></td>
<td style="text-align:left"><strong>否定</strong> 正序环视，表示 <code>x</code> 后不紧跟着 <code>y</code> 才匹配</td>
</tr>
</tbody>
</table>
<p>&lt;br /&gt;</p>
<pre class="hljs"><code class="language-js">/<span class="hljs-title function_">a</span>(?=b)/.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;abc&#x27;</span>);
<span class="hljs-comment">// [&#x27;a&#x27;]</span>

<span class="hljs-regexp">/a(?=b)/</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;ac&#x27;</span>);
<span class="hljs-comment">// null</span>

<span class="hljs-regexp">/a(?!b)/</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;abc&#x27;</span>);
<span class="hljs-comment">// null</span>

<span class="hljs-regexp">/a(?!b)/</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;ac&#x27;</span>);
<span class="hljs-comment">// [&#x27;a&#x27;]</span>

<span class="hljs-regexp">/a(?=b)b/</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;abc&#x27;</span>);
<span class="hljs-comment">// [&#x27;ab&#x27;]</span>
</code></pre>
<p>环视虽然也用到括号，却与捕获型分组编号无关；但如果环视结构出现捕获型括号，则会影响分组。</p>
<pre class="hljs"><code class="language-js">/<span class="hljs-title function_">ab</span>(?=cd)/.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;abcd&#x27;</span>);
<span class="hljs-comment">// [&#x27;ab&#x27;]</span>

<span class="hljs-regexp">/ab(?=(cd))/</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;abcd&#x27;</span>);
<span class="hljs-comment">// [&#x27;ab&#x27;,&#x27;cd&#x27;]</span>
</code></pre>
<h2>匹配模式</h2>
<p><strong>匹配模式（Match Mode）</strong> 指匹配时使用的规则。设置特定的模式，可能会改变对正则表达式的识别。</p>
<h3>不区分大小写模式</h3>
<p>默认地，正则表达式是 <strong>区分大小写</strong> 的，通过设置标志 <code>i</code>，可以 <strong>忽略大小写（ignore case）</strong>。</p>
<pre class="hljs"><code class="language-js">/ab/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;aB&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/ab/i</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;aB&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<h3>多行模式</h3>
<p>默认地，正则表达式中的 <code>^</code> 和 <code>$</code> 匹配的是整个字符串的起始位置和结束位置，而通过设置标志 <code>m</code>，开启多行模式，它们也能匹配字符串内部某一行文本的起始位置和结束位置。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// example 1</span>
/world$/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;hello world\n&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/world$/m</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;hello world\n&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-comment">// example 2</span>
<span class="hljs-regexp">/^b/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;a\nb&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/^b/m</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;a\nb&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<h3>全局模式</h3>
<p>默认地，第一次匹配成功后，正则对象就停止向下匹配了。<code>g</code> 修饰符表示 <strong>全局匹配（global）</strong>，设置 <code>g</code> 标志后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-string">&#x27;1a,2a,3a&#x27;</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/a/</span>, <span class="hljs-string">&#x27;b&#x27;</span>);
<span class="hljs-comment">// &#x27;1b,2a,3a&#x27;</span>

<span class="hljs-string">&#x27;1a,2a,3a&#x27;</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/a/g</span>, <span class="hljs-string">&#x27;b&#x27;</span>);
<span class="hljs-comment">// &#x27;1b,2b,3b&#x27;</span>
</code></pre>
<h2>优先级</h2>
<p>下表为正则表达式符号优先级排序，从上到下，优先级逐渐降低（优先级数值越大，优先级越高）。</p>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">符号名称</th>
<th style="text-align:left">优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>\</code></td>
<td style="text-align:left">转义符</td>
<td style="text-align:left">5</td>
</tr>
<tr>
<td style="text-align:left"><code>()</code> <code>(?!)</code> <code>(?=)</code> <code>[]</code></td>
<td style="text-align:left">括号、字符集、环视</td>
<td style="text-align:left">4</td>
</tr>
<tr>
<td style="text-align:left"><code>*</code> <code>+</code> <code>?</code> <code>{n}</code> <code>{n,}</code> <code>{n,m}</code></td>
<td style="text-align:left">量词</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left"><code>^</code> <code>$</code></td>
<td style="text-align:left">起始结束位置</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left"><code>|</code></td>
<td style="text-align:left">选择</td>
<td style="text-align:left">1</td>
</tr>
</tbody>
</table>
<p>由于括号的用途之一就是为量词限定作用范围，所以优先级比量词高。</p>
<pre class="hljs"><code class="language-js">/ab{<span class="hljs-number">2</span>}/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abab&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/(ab){2}/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abab&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<p>选择符 <code>|</code> 的优先级最低，比起始和结束位置都要低。</p>
<pre class="hljs"><code class="language-js">/^ab|cd$/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abc&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/^(ab|cd)$/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abc&#x27;</span>);
<span class="hljs-comment">// false</span>
</code></pre>
<h2>局限性</h2>
<p>尽管 JavaScript 中的正则表达式功能比较完备，但与其他语言相比，缺少某些特性</p>
<p>下面列出了 JavaScript 正则表达式不支持的特性</p>
<ul>
<li>POSIX 字符组（只支持普通字符组和排除型字符组）</li>
<li>Unicode 支持（只支持单个 Unicode 字符）</li>
<li>匹配字符串开始和结尾的 <code>\A</code> 和 <code>\Z</code> 锚（只支持 <code>^</code> 和 <code>$</code>）</li>
<li>逆序环视（只支持顺序环视）</li>
<li>命名分组（只支持 0-9 编号的捕获组）</li>
<li>单行模式和注释模式（只支持 <code>m</code> 、<code>i</code>、<code>g</code>）</li>
<li>模式作用范围</li>
<li>纯文本模式</li>
</ul>
<h2>参考资料</h2>
<ul>
<li><a href="https://tool.oschina.net/uploads/apidocs/jquery/regexp.html" target="_blank" rel="noopener noreferrer nofollow">正则表达式手册</a></li>
<li><a href="https://regexr.com/" target="_blank" rel="noopener noreferrer nofollow">RegExr 正则表达式练习网站</a></li>
<li><a href="https://regexone.com/" target="_blank" rel="noopener noreferrer nofollow">RegexOne</a></li>
</ul>
</article></div></main><script src="/_next/static/chunks/webpack-038c2e688b596d0e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5244,[],\"\"]\n3:I[3866,[],\"\"]\n5:I[6213,[],\"OutletBoundary\"]\n7:I[6213,[],\"MetadataBoundary\"]\n9:I[6213,[],\"ViewportBoundary\"]\nb:I[4835,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/ec0a9d078e716e00.css\",\"style\"]\n:HL[\"/_next/static/css/485ff6fe79292a08.css\",\"style\"]\n:HL[\"/_next/static/css/0ff121a467c0636f.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"ToCgoFiTXvECVEVLCeZww\",\"p\":\"\",\"c\":[\"\",\"front-end\",\"standard-built-in-objects\",\"text-processing\",\"regexp\",\"regexp-rule\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"front-end\",{\"children\":[[\"slug\",\"standard-built-in-objects/text-processing/regexp/regexp-rule\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/ec0a9d078e716e00.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"front-end\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/485ff6fe79292a08.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0ff121a467c0636f.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"main\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[[\"slug\",\"standard-built-in-objects/text-processing/regexp/regexp-rule\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"hmCfeLoacwdHgVQ3wcW9z\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:Tea0c,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eRegExp 语法\u003c/h1\u003e\n\u003ch2\u003e元字符\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e元字符（Meta-Character）\u003c/strong\u003e 指那些在正则表达式中具有特殊意义的专用字符，可以用来规定其前导字符（即位于元字符前面的字符）在目标对象中的出现模式。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e元字符\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e名称\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e匹配对象\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e.\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e点号\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e单个任意字符(除回车 \u003ccode\u003e\\r\u003c/code\u003e、换行 \u003ccode\u003e\\n\u003c/code\u003e、行分隔符 \u003ccode\u003e\\u2028\u003c/code\u003e 和段分隔符 \u003ccode\u003e\\u2029\u003c/code\u003e 外)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e[]\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e字符组\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e列出的单个任意字符\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e[^]\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e排除型字符组\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e未列出的单个任意字符\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e?\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e问号\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e匹配 0 次或 1 次\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e*\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e星号\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e匹配 0 次或多次\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e+\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e加号\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e匹配 1 次或多次\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e{min,max}\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e区间量词\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e匹配至少 min 次，最多 max 次\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e^\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e脱字符\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e行的起始位置\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e$\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e美元符\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e行的结束位置\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e`\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e`\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e竖线\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e()\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e括号\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e限制多选结构的范围，标注量词作用的元素，为反向引用捕获文本\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e\\1,\\2...\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e反向引用\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e匹配之前的第一、第二...组括号内的表达式匹配的文本\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2\u003e字符类别\u003c/h2\u003e\n\u003ch3\u003e字符组简记\u003c/h3\u003e\n\u003cp\u003e用 \u003ccode\u003e[0-9]\u003c/code\u003e、\u003ccode\u003e[a-z]\u003c/code\u003e 等字符组，可以很方便地表示数字字符和小写字母字符。对于这类常用字符组，正则表达式提供了更简单的记法，这就是\u003cstrong\u003e字符组简记（Shorthands）\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e常见的字符组简记有 \u003ccode\u003e\\d\u003c/code\u003e、\u003ccode\u003e\\w\u003c/code\u003e、\u003ccode\u003e\\s\u003c/code\u003e，其中：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003ed\u003c/code\u003e 表示（Digit）数字\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ew\u003c/code\u003e 表示（Word）单词\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003es\u003c/code\u003e 表示（Space）空白\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e正则表达式也提供了对应排除型字符组的简记法：\u003ccode\u003e\\D\u003c/code\u003e、\u003ccode\u003e\\W\u003c/code\u003e、\u003ccode\u003e\\S\u003c/code\u003e。字母完全相同，只是改为大写，这些简记法匹配的字符互补。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:center\"\u003e字符\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e描述\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ccode\u003e\\d\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e数字，等同于 \u003ccode\u003e[0-9]\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ccode\u003e\\D\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e非数字，等同于 \u003ccode\u003e[^0-9]\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ccode\u003e\\s\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e空白字符，等同于 \u003ccode\u003e[\\f\\n\\r\\t\\u000B\\u0020\\u00A0\\u2028\\u2029]\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ccode\u003e\\S\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e非空白字符，等同于 \u003ccode\u003e[^\\f\\n\\r\\t\\u000B\\u0020\\u00A0\\u2028\\u2029]\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ccode\u003e\\w\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e字母、数字、下划线，等同于 \u003ccode\u003e[0-9A-Za-z_]\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ccode\u003e\\W\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e非字母、数字、下划线，等同于 \u003ccode\u003e[^0-9A-Za-z_]\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch3\u003e任意字符\u003c/h3\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e字符\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e描述\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e.\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e表示除回车 \u003ccode\u003e(\\r)\u003c/code\u003e、换行 \u003ccode\u003e(\\n)\u003c/code\u003e、行分隔符 \u003ccode\u003e(\\u2028)\u003c/code\u003e 和段分隔符 \u003ccode\u003e(\\u2029)\u003c/code\u003e 以外的任意字符。\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cblockquote\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e注意\u003c/strong\u003e：一般认为点号可以代表任意字符，其实并不是\u003c/p\u003e\n\u003cp\u003e妥善的利用互补属性，可以得到一些巧妙的效果。比如，\u003ccode\u003e[\\s\\S]\u003c/code\u003e、\u003ccode\u003e[\\w\\W]\u003c/code\u003e、\u003ccode\u003e[\\d\\D]\u003c/code\u003e 都可以表示任意字符。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003cstrong\u003e匹配任意字符\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e/./.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;\\r\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/[\\s\\S]/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;\\r\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e转义字符\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e转义字符（Escape）\u003c/strong\u003e 表示为反斜线 \u003ccode\u003e\\\u003c/code\u003e 加字符的形式，共有以下 3 种情况。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e字符\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e描述\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e\\\u003c/code\u003e + 元字符\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e匹配元字符\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e\\\u003c/code\u003e + \u003ccode\u003e]\u003c/code\u003e 或 \u003ccode\u003e\\\u003c/code\u003e + \u003ccode\u003e}\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e右方括号和右花括号无需转义\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e\\\u003c/code\u003e + 非元字符\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e表示一些不能打印的特殊字符\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e\\\u003c/code\u003e + 除上述其他字符\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e默认情况匹配此字符\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u0026lt;br /\u0026gt;\u003c/p\u003e\n\u003cp\u003e因为元字符有特殊的含义，所以无法直接匹配。如果要匹配它们本身，则需要在它们前面加上反斜杠 \u003ccode\u003e\\\u003c/code\u003e。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e/\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e+\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e/.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;1+1\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/1\\+1/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;1+1\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/\\*/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;*\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e/*/.test(\u0026#x27;*\u0026#x27;);\n// 报错\n\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但实际上，并非 14 个元字符都需要转义，右方括号 \u003ccode\u003e]\u003c/code\u003e 和右花括号 \u003ccode\u003e}\u003c/code\u003e 不需要转义\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e/]/.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;]\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003cspan class=\"hljs-regexp\"\u003e/\\]/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;]\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/\\}/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;}\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003cspan class=\"hljs-regexp\"\u003e/}/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;}\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e\\\u003c/code\u003e 加非元字符，表示一些不能打印的特殊字符。\u003c/p\u003e\n\u003cp\u003e\u0026lt;br /\u0026gt;\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:center\"\u003e字符\u003c/th\u003e\n\u003cth style=\"text-align:center\"\u003e描述\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ccode\u003e\\0\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003eNUL 字符 \u003ccode\u003e\\u0000\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ccode\u003e[\\b]\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e匹配退格符 \u003ccode\u003e\\u0008\u003c/code\u003e，不要与 \u003ccode\u003e\\b\u003c/code\u003e 混淆\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ccode\u003e\\t\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e制表符 \u003ccode\u003e\\u0009\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ccode\u003e\\n\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e换行符 \u003ccode\u003e\\u000A\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ccode\u003e\\v\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e垂直制表符 \u003ccode\u003e\\u000B\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ccode\u003e\\f\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e换页符 \u003ccode\u003e\\u000C\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ccode\u003e\\r\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e回车符 \u003ccode\u003e\\u000D\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ccode\u003e\\xnn\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e由十六进制数 \u003ccode\u003enn\u003c/code\u003e 指定的拉丁字符\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ccode\u003e\\uxxxx\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e由十六进制数 \u003ccode\u003exxxx\u003c/code\u003e 指定的 Unicode 字符( \u003ccode\u003e\\u4e00\u003c/code\u003e - \u003ccode\u003e\\u9fa5\u003c/code\u003e 代表中文)\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:center\"\u003e\u003ccode\u003e\\cX\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:center\"\u003e控制字符 \u003ccode\u003e^X\u003c/code\u003e，表示 \u003ccode\u003ectrl-[X]\u003c/code\u003e ，其中的 X 是 A-Z 之中任一个英文字母，用来匹配控制字符\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u003ccode\u003e\\\u003c/code\u003e 加任意其他字符，默认情况就是匹配此字符，也就是说，反斜线 \u003ccode\u003e(\\)\u003c/code\u003e 被忽略了。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e/\\x/.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;x\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/\\y/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;y\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/\\z/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;z\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e双重转义\u003c/h3\u003e\n\u003cp\u003e由于 \u003ccode\u003eRegExp\u003c/code\u003e 构造函数的参数是字符串，所以某些情况下，需要对字符进行 \u003cstrong\u003e双重转义\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e字符 \u003ccode\u003e\\\u003c/code\u003e 在正则表达式字符串中通常被转义为 \u003ccode\u003e\\\\\u003c/code\u003e 。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e reg1 = \u003cspan class=\"hljs-regexp\"\u003e/\\.at/\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 等价于\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e reg2 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRegExp\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;\\\\.at\u0026#x27;\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e reg3 = \u003cspan class=\"hljs-regexp\"\u003e/name\\/age/\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 等价于\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e reg4 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRegExp\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;name\\\\/age\u0026#x27;\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e reg5 = \u003cspan class=\"hljs-regexp\"\u003e/\\w\\\\hello\\\\123/\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 等价于\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e reg6 = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eRegExp\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;\\\\w\\\\\\\\hello\\\\\\\\123\u0026#x27;\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e字符集合\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e字符集合（Character Sets）\u003c/strong\u003e，有的编译成字符类或字符集。简单而言，就是指用方括号表示的一组字符，它匹配若干字符之一。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e字符\u003c/th\u003e\n\u003cth\u003e描述\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e[xyz]\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e一个字符集合，也叫字符组。匹配集合中任意一个字符。可以使用 \u003ccode\u003e-\u003c/code\u003e 指定一个范围。\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e\u003ccode\u003e[^xyz]\u003c/code\u003e\u003c/td\u003e\n\u003ctd\u003e一个反义或补充字符集，也叫反义字符组。匹配任意不包括括号内的字符。可以使用 \u003ccode\u003e-\u003c/code\u003e 指定一个范围。\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u0026lt;br /\u0026gt;\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 匹配 0-9 这 10 个数字之一\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp = \u003cspan class=\"hljs-regexp\"\u003e/[0123456789]/\u003c/span\u003e;\n\nregexp.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;1\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\nregexp.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;a\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e字符组中的字符排列顺序并不影响字符组的功能，出现重复字符也不会影响。\u003c/p\u003e\n\u003cp\u003e以下三个表达式都是相等的。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp1 = \u003cspan class=\"hljs-regexp\"\u003e/[0123456789]/\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp2 = \u003cspan class=\"hljs-regexp\"\u003e/[9876543210] /\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp3 = \u003cspan class=\"hljs-regexp\"\u003e/[1234567890123456789]/\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e范围\u003c/h3\u003e\n\u003cp\u003e正则表达式通过连字符 \u003ccode\u003e(-)\u003c/code\u003e 提供了范围表示法，可以简化字符组\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp1 = \u003cspan class=\"hljs-regexp\"\u003e/[0123456789]/\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 等价于\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp2 = \u003cspan class=\"hljs-regexp\"\u003e/[0-9]/\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp3 = \u003cspan class=\"hljs-regexp\"\u003e/[abcdefghijklmnopqrstuvwxyz]/\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 等价于\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp4 = \u003cspan class=\"hljs-regexp\"\u003e/[a-z]/\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e连字符 \u003ccode\u003e(-)\u003c/code\u003e 表示的范围是根据 ASCII 编码的码值来确定的，码值小的在前，码值大的在后。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e img \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;../../../assets/regexp/ascii.gif\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e () =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;ASCII编码表\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{img}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{720}\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e所以 \u003ccode\u003e[0-9]\u003c/code\u003e 是合法的，而 \u003ccode\u003e[9-0]\u003c/code\u003e 会报错。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//匹配 0-9 这 10 个数字之一\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp1 = \u003cspan class=\"hljs-regexp\"\u003e/[0-9]/\u003c/span\u003e;\nregexp1.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;1\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp2 = \u003cspan class=\"hljs-regexp\"\u003e/[9-0]/\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 报错\u003c/span\u003e\nregexp2.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;1\u0026#x27;\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在字符组中可以同时并列多个 \u003ccode\u003e-\u003c/code\u003e 范围。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp1 = \u003cspan class=\"hljs-regexp\"\u003e/[0-9a-zA-Z]/\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 匹配数字、大写字母和小写字母\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp2 = \u003cspan class=\"hljs-regexp\"\u003e/[0-9a-fA-F]/\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 匹配数字，大、小写形式的a-f，用来验证十六进制字符\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp3 = \u003cspan class=\"hljs-regexp\"\u003e/[0-9a-fA-F]/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;d\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp4 = \u003cspan class=\"hljs-regexp\"\u003e/[0-9a-fA-F]/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;x\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e只有在字符组内部，连字符 \u003ccode\u003e-\u003c/code\u003e 才是元字符，表示一个范围，否则它就只能匹配普通的连字符号。\u003c/p\u003e\n\u003cp\u003e如果连字符出现在字符组的开头或末尾，它表示的也是普通的连字符号，而不是一个范围。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 匹配中划线\u003c/span\u003e\n/-/.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;-\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/[-]/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;-\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 匹配0-9的数字或中划线\u003c/span\u003e\n\u003cspan class=\"hljs-regexp\"\u003e/[0-9]/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;-\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/[0-9-]/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;-\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/[0-9\\-]/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;-\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/[-0-9]/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;-\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/[\\-0-9]/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;-\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e排除\u003c/h3\u003e\n\u003cp\u003e字符组的另一个类型是 \u003cstrong\u003e排除型字符组\u003c/strong\u003e，在左方括号后紧跟一个脱字符 \u003ccode\u003e^\u003c/code\u003e 表示，表示在当前位置匹配一个没有列出的字符。\u003c/p\u003e\n\u003cp\u003e所以 \u003ccode\u003e[^0-9]\u003c/code\u003e 表示 0-9 以外的字符。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 匹配第一个是数字字符，第二个不是数字字符的字符串\u003c/span\u003e\n/[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e][^\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e9\u003c/span\u003e]/.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;1e\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003cspan class=\"hljs-regexp\"\u003e/[0-9][^0-9]/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;q2\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在字符组内部，脱字符 \u003ccode\u003e^\u003c/code\u003e 表示排除，而在字符组外部，脱字符 \u003ccode\u003e^\u003c/code\u003e 表示一个行锚点。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e^\u003c/code\u003e 符号是元字符，在字符组中只要 \u003ccode\u003e^\u003c/code\u003e 符号不挨着左方括号就可以表示其本身含义，不转义也可以。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 匹配 abc 和 ^ 符号\u003c/span\u003e\n/[a-c^]/.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;^\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/[a-c\\^]/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;^\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/[\\^a-c]/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;^\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在字符组中，只有 \u003ccode\u003e^\u003c/code\u003e 、 \u003ccode\u003e-\u003c/code\u003e 、\u003ccode\u003e[\u003c/code\u003e 、\u003ccode\u003e]\u003c/code\u003e 这 4 个字符可能被当做元字符，其他有元字符功能的字符都只表示其本身。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e/[[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]]/.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;[\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/[[1]]/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;]\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/[\\1]/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;\\\\\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/[^^]/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;^\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/[1-2]/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;-\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/[\\[1\\]]/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;[\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/[\\[1\\]]/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;]\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/[\\\\]/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;\\\\\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/[^]/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;^\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/[1-2\\-]/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;-\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e数量词\u003c/h2\u003e\n\u003cp\u003e正则表达式提供了量词，用来设定某个模式出现的次数。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e字符\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e描述\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003ex*\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e相当于 \u003ccode\u003ex{0,}\u003c/code\u003e （匹配任意多次）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003ex+\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e相当于 \u003ccode\u003ex{1,}\u003c/code\u003e（匹配至少一次）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003ex?\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e相当于 \u003ccode\u003ex{0,1}\u003c/code\u003e （不匹配或匹配一次）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003ex*?\u003c/code\u003e 或 \u003ccode\u003ex+?\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e相当于 \u003ccode\u003e*\u003c/code\u003e 和 \u003ccode\u003e+\u003c/code\u003e字符，然而匹配的是最小可能匹配\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003ex(?=y)\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e只有当 \u003ccode\u003ex\u003c/code\u003e 后面紧跟着 \u003ccode\u003ey\u003c/code\u003e 时，才匹配 \u003ccode\u003ex\u003c/code\u003e。（了解详情请看 \u003ca href=\"/front-end/standard-built-in-objects/text-processing/regexp/#%E7%8E%AF%E8%A7%86\"\u003e环视\u003c/a\u003e）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003ex(?!y)\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e只有当 \u003ccode\u003ex\u003c/code\u003e 后面不是紧跟着 \u003ccode\u003ey\u003c/code\u003e 时，才匹配 \u003ccode\u003ex\u003c/code\u003e。（了解详情请看 \u003ca href=\"/front-end/standard-built-in-objects/text-processing/regexp/#%E7%8E%AF%E8%A7%86\"\u003e环视\u003c/a\u003e）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003ex|y\u003c/code\u003e（这里是没有 \u003ccode\u003e\\\u003c/code\u003e 的）\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e匹配 \u003ccode\u003ex\u003c/code\u003e 或 \u003ccode\u003ey\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003ex{n}\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e匹配 \u003ccode\u003en\u003c/code\u003e 次（\u003ccode\u003en\u003c/code\u003e 为正整数）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003ex{n,m}\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e匹配至少 \u003ccode\u003en\u003c/code\u003e 次，最多 \u003ccode\u003em\u003c/code\u003e 次（\u003ccode\u003en\u003c/code\u003e 和 \u003ccode\u003em\u003c/code\u003e 为正整数）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003ex{n,}\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e匹配至少 \u003ccode\u003en\u003c/code\u003e 次（\u003ccode\u003en\u003c/code\u003e 为正整数）\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u0026lt;br /\u0026gt;\u003c/p\u003e\n\u003cp\u003e邮政编码\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 表示邮政编码 6 位数字\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp = \u003cspan class=\"hljs-regexp\"\u003e/\\d{6}/\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e美国英语和英国英语有些词的写法不一样，如果 \u003ccode\u003etraveler\u003c/code\u003e 和 \u003ccode\u003etraveller\u003c/code\u003e，\u003ccode\u003efavor\u003c/code\u003e 和 \u003ccode\u003efavour\u003c/code\u003e，\u003ccode\u003ecolor\u003c/code\u003e 和 \u003ccode\u003ecolour\u003c/code\u003e。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 同时匹配美国英语和英国英语单词\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp1 = \u003cspan class=\"hljs-regexp\"\u003e/travell?er/\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp2 = \u003cspan class=\"hljs-regexp\"\u003e/favou?r/\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp3 = \u003cspan class=\"hljs-regexp\"\u003e/colou?r/\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e协议名有 HTTP 和 HTTPS 两种：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp1 = \u003cspan class=\"hljs-regexp\"\u003e/https?/\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e选择\u003c/h3\u003e\n\u003cp\u003e竖线 \u003ccode\u003e|\u003c/code\u003e 在正则表达式中表示或关系的选择，以竖线 \u003ccode\u003e|\u003c/code\u003e 分隔开的多个子表达式也叫选择分支或选择项。在一个选择结构中，选择分支的数目没有限制。\u003c/p\u003e\n\u003cp\u003e在选择结构中，竖线 \u003ccode\u003e|\u003c/code\u003e 用来分隔选择项，而括号 \u003ccode\u003e()\u003c/code\u003e 用来规定整个选择结构的范围。如果没有出现括号，则将整个表达式视为一个选择结构。\u003c/p\u003e\n\u003cp\u003e选择项的尝试匹配次序是从左到右，直到发现了匹配项，如果某个选择项匹配就忽略右侧其他选择项，如果所有子选择项都不匹配，则整个选择结构匹配失败。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e/\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e|\u003cspan class=\"hljs-number\"\u003e23\u003c/span\u003e|\u003cspan class=\"hljs-number\"\u003e34\u003c/span\u003e/.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;1\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// null\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/12|23|34/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;12\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// [\u0026#x27;12\u0026#x27;]\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/12|23|34/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;23\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// [\u0026#x27;23\u0026#x27;]\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/12|23|34/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;2334\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// [\u0026#x27;23\u0026#x27;]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eIP 地址一般由 3 个点号和 4 段数字组成，每段数字都在 0-255 之间。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e0-199：\u003ccode\u003e[01]?\\d\\d?\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e200-249：\u003ccode\u003e2[0-4]\\d\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e250-255：\u003ccode\u003e25[0-5]\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eIP 地址：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e ipRegExp = \u003cspan class=\"hljs-regexp\"\u003e/((2[0-4]\\d|25[0-5]|[0-1]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[0-1]?\\d\\d?)/\u003c/span\u003e;\n\nipRegExp.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;1.1.1.1\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\nipRegExp.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;1.1.1\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\nipRegExp.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;256.1.1.1\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e类似地，时间匹配也需要分段处理：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 月(1-12)\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e?\\d|\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]\n\n\u003cspan class=\"hljs-comment\"\u003e// 日(1-31)\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e?\\d|[\u003cspan class=\"hljs-number\"\u003e12\u003c/span\u003e]\\d|\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e01\u003c/span\u003e]\n\n\u003cspan class=\"hljs-comment\"\u003e// 小时(0-24)\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e?\\d|\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\\d|\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e]\n\n\u003cspan class=\"hljs-comment\"\u003e// 分钟(0-60)\u003c/span\u003e\n\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e?\\d|[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e-\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e]\\d|\u003cspan class=\"hljs-number\"\u003e60\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e手机号一般是 11 位，前 3 位是号段，后 8 位一般没有限制。而且，在手机开头很可能有 0 或+86。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e开头：\u003ccode\u003e(0|\\+86)?\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e前 3 位：\u003ccode\u003e13\\d|14[579]|15[0-35-9]|17[0135-8]|18\\d\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e后 8 位：\u003ccode\u003e\\d{8}\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e phone = \u003cspan class=\"hljs-regexp\"\u003e/(0|\\+86)?(13\\d|14[579]|15[0-35-9]|17[0135-8]|18\\d)\\d{8}/\u003c/span\u003e;\n\nphone.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;13453250661\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\nphone.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;1913250661\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\nphone.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;1345325061\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在选择结构中，应该尽量避免选择分支中存在重复匹配，因为这样会大大增加回溯的计算量\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 错误示范 🙅‍♂️\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp = \u003cspan class=\"hljs-regexp\"\u003e/a|[ab][0-9]|\\w/\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e贪婪模式\u003c/h3\u003e\n\u003cp\u003e默认情况下，量词都是\u003cstrong\u003e贪婪模式（Greedy quantifier）\u003c/strong\u003e，即匹配到下一个字符不满足匹配规则为止。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// exec 方法以数组的形式返回匹配结果\u003c/span\u003e\n/a+/.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;aaa\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// [\u0026#x27;aaa\u0026#x27;]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e懒惰模式\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e懒惰模式（Lazy quantifier）\u003c/strong\u003e 和贪婪模式相对应，在量词后加问号 \u003ccode\u003e?\u003c/code\u003e 表示，表示尽可能少的匹配，一旦条件满足就再不往下匹配。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e符号\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e释义\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e{n}?\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e匹配 \u003ccode\u003en\u003c/code\u003e 次\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e{n,m}?\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e匹配至少 \u003ccode\u003en\u003c/code\u003e 次，最多 \u003ccode\u003em\u003c/code\u003e 次\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e{n,}?\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e匹配至少 \u003ccode\u003en\u003c/code\u003e 次\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e??\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e相当于\u003ccode\u003e{0,1}\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e*?\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e相当于\u003ccode\u003e{0,}\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e+?\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e相当于\u003ccode\u003e{1,}\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u0026lt;br /\u0026gt;\u003c/p\u003e\n\u003cp\u003e示例：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e/a+?/.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;aaa\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// [\u0026#x27;a\u0026#x27;]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e匹配 \u003ccode\u003e\u0026lt;script\u0026gt;\u0026lt;/script\u0026gt;\u003c/code\u003e 之间的代码看上去很容易\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp = \u003cspan class=\"hljs-regexp\"\u003e/\u0026lt;script\u0026gt;[\\s\\S]*\u0026lt;\\/script\u0026gt;/\u003c/span\u003e;\n\nregexp.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026lt;script\u0026gt;alert(\u0026quot;1\u0026quot;);\u0026lt;/script\u0026gt;\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// [\u0026quot;\u0026lt;script\u0026gt;alert(\u0026quot;1\u0026quot;);\u0026lt;/script\u0026gt;\u0026quot;]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但如果多次出现 \u003ccode\u003escript\u003c/code\u003e 标签，就会出问题\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp = \u003cspan class=\"hljs-regexp\"\u003e/\u0026lt;script\u0026gt;[\\s\\S]*\u0026lt;\\/script\u0026gt;/\u003c/span\u003e;\n\nregexp.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026lt;script\u0026gt;alert(\u0026quot;1\u0026quot;);\u0026lt;/script\u0026gt;\u0026lt;br\u0026gt;\u0026lt;script\u0026gt;alert(\u0026quot;2\u0026quot;);\u0026lt;/script\u0026gt;\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// [\u0026quot;\u0026lt;script\u0026gt;alert(\u0026quot;1\u0026quot;);\u0026lt;/script\u0026gt;\u0026lt;br\u0026gt;\u0026lt;script\u0026gt;alert(\u0026quot;2\u0026quot;);\u0026lt;/script\u0026gt;\u0026quot;]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e它把无用的 \u003ccode\u003e\u0026lt;br\u0026gt;\u003c/code\u003e 标签也匹配出来了，此时就需要使用懒惰模式\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp = \u003cspan class=\"hljs-regexp\"\u003e/\u0026lt;script\u0026gt;[\\s\\S]*?\u0026lt;\\/script\u0026gt;/\u003c/span\u003e;\n\nregexp.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026lt;script\u0026gt;alert(\u0026quot;1\u0026quot;);\u0026lt;/script\u0026gt;\u0026lt;br\u0026gt;\u0026lt;script\u0026gt;alert(\u0026quot;2\u0026quot;);\u0026lt;/script\u0026gt;\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// [\u0026quot;\u0026lt;script\u0026gt;alert(\u0026quot;1\u0026quot;);\u0026lt;/script\u0026gt;\u0026quot;]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 JavaScript 中，\u003ccode\u003e/* */\u003c/code\u003e 是注释的一种形式，在文档中可能出现多次，这时就必须使用懒惰模式\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp = \u003cspan class=\"hljs-regexp\"\u003e/\\/\\*[\\s\\S]*?\\*\\//\u003c/span\u003e;\n\nregexp.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;/*abc*/\u0026lt;br\u0026gt;/*123*/\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// [\u0026quot;/*abc*/\u0026quot;]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e分组与反向引用\u003c/h2\u003e\n\u003ch3\u003e分组\u003c/h3\u003e\n\u003cp\u003e量词控制之前元素的出现次数，而这个元素可能是一个字符，也可能是一个字符组，也可以是一个表达式。\u003c/p\u003e\n\u003cp\u003e如果把一个表达式用括号包围起来，这个元素就是括号里的表达式，被称为 \u003cstrong\u003e子表达式\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e示例 1\u003c/strong\u003e：如果希望字符串 \u003ccode\u003eab\u003c/code\u003e 重复出现 2 次，应该写为 \u003ccode\u003e(ab){2}\u003c/code\u003e，而如果写为 \u003ccode\u003eab{2}\u003c/code\u003e，则 \u003ccode\u003e{2}\u003c/code\u003e 只限定 \u003ccode\u003eb\u003c/code\u003e。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e/(ab){\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e}/.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;abab\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/(ab){2}/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;abb\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/ab{2}/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;abab\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/ab{2}/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;abb\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e示例 2\u003c/strong\u003e：身份证长度有 15 位和 18 位两种，如果只匹配长度，可能会想当然地写成 \u003ccode\u003e\\d{15,18}\u003c/code\u003e，实际上这是错误的，因为它包括 15、16、17、18 这四种长度。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 正确写法\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e idCard = \u003cspan class=\"hljs-regexp\"\u003e/\\d{15}(\\d{3})?/\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e示例 3\u003c/strong\u003e：Email 地址以 \u003ccode\u003e@\u003c/code\u003e 分隔成两段，之前的部分是用户名，之后的部分是主机名。\u003c/p\u003e\n\u003cp\u003e用户名允许出现数字、字母和下划线，长度一般在 1-64 个字符之间，则正则可表示为 \u003ccode\u003e/\\w{1,64}/\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e主机名一般表现为 \u003ccode\u003ea.b.···.c\u003c/code\u003e，其中 \u003ccode\u003ec\u003c/code\u003e 为主域名，其他为级数不定的子域名，则正则可表示为 \u003ccode\u003e/([-a-zA-z0-9]{1,63}\\.)+[-a-zA-Z0-9]{1,63}/\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e所以 email 地址的正则表达式如下：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e email = \u003cspan class=\"hljs-regexp\"\u003e/\\w{1,64}@([-a-zA-z0-9]{1,63}\\.)+[-a-zA-Z0-9]{1,63}/\u003c/span\u003e;\n\nemail.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;q@qq.com\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\nemail.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;q@qq\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\nemail.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;q@a.qq.com\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e捕获\u003c/h3\u003e\n\u003cp\u003e括号不仅可以对元素进行分组，还会保存每个分组匹配的文本，等到匹配完成后，引用捕获的内容。因为捕获了文本，这种功能叫 \u003cstrong\u003e捕获分组\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e比如，要匹配诸如 \u003ccode\u003e2016-06-23\u003c/code\u003e 这样的日期字符串\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e regexp = \u003cspan class=\"hljs-regexp\"\u003e/(\\d{4})-(\\d{2})-(\\d{2})/\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e与以往不同的是，年、月、日这三个数值被括号括起来了，从左到右为第 1 个括号、第 2 个括号和第 3 个括号，分别代表第 1、2、3 个捕获组。\u003c/p\u003e\n\u003cp\u003eJavaScript 有 9 个用于存储捕获组的构造函数属性。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eRegExp.$1\u003c/code\u003e、\u003ccode\u003eRegExp.$2\u003c/code\u003e、\u003ccode\u003eRegExp.$3\u003c/code\u003e 到 \u003ccode\u003eRegExp.$9\u003c/code\u003e 分别用于存储第一、第二第九个匹配的捕获组。\u003c/p\u003e\n\u003cp\u003e在调用 \u003ccode\u003eexec()\u003c/code\u003e 或 \u003ccode\u003etest()\u003c/code\u003e 方法时，这些属性会被自动填充。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e/(\\d{\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e})-(\\d{\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e})-(\\d{\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e})/.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;2016-06-23\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eRegExp\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e$1\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// \u0026#x27;2016\u0026#x27;\u003c/span\u003e\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eRegExp\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e$2\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// \u0026#x27;06\u0026#x27;\u003c/span\u003e\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eRegExp\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e$3\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// \u0026#x27;23\u0026#x27;\u003c/span\u003e\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eRegExp\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e$4\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// \u0026#x27;\u0026#x27;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e而 \u003ccode\u003eexec()\u003c/code\u003e 方法是专门为捕获组而设计的，返回的数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e/(\\d{\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e})-(\\d{\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e})-(\\d{\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e})/.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;2016-06-23\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// [\u0026quot;2016-06-23\u0026quot;, \u0026quot;2016\u0026quot;, \u0026quot;06\u0026quot;, \u0026quot;23\u0026quot;]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e捕获分组捕获的文本，不仅可以 \u003cstrong\u003e用于数据提取\u003c/strong\u003e，也可以 \u003cstrong\u003e用于替换\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ereplace()\u003c/code\u003e 方法就是用于进行数据替换的，该方法接收两个参数，第一个参数为待查找的内容，而第二个参数为替换的内容。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\u0026#x27;2000-01-01\u0026#x27;\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/-/g\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;.\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 2000.01.01\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在 \u003ccode\u003ereplace()\u003c/code\u003e 方法中也可以引用分组，形式是 \u003ccode\u003e$num\u003c/code\u003e， \u003ccode\u003enum\u003c/code\u003e 是对应分组的编号。\u003c/p\u003e\n\u003cp\u003e把 \u003ccode\u003e2000-01-01\u003c/code\u003e 的形式变成 \u003ccode\u003e01-01-2000\u003c/code\u003e 的形式：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\u0026#x27;2000-01-01\u0026#x27;\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/(\\d{4})-(\\d{2})-(\\d{2})/g\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;$3-$2-$1\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e//\u0026#x27;01-01-2000\u0026#x27;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e反向引用\u003c/h3\u003e\n\u003cp\u003e英文中不少单词都有重叠出现的字母，如 \u003ccode\u003eshoot\u003c/code\u003e 或 \u003ccode\u003ebeep\u003c/code\u003e。若想检查某个单词是否包含重叠出现的字母，则需要引入 \u003cstrong\u003e反向引用（back-reference）\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e反向引用允许在正则表达式内部引用之前捕获分组匹配的文本，形式是 \u003ccode\u003e\\num\u003c/code\u003e，\u003ccode\u003enum\u003c/code\u003e 表示所引用分组的编号。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//重复字母\u003c/span\u003e\n/([a-z])\\\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e/\n\n\u003cspan class=\"hljs-regexp\"\u003e/([a-z])\\1/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;aa\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/([a-z])\\1/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;ab\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e反向引用可以用于建立前后联系。HTML 标签的开始标签和结束标签是对应的。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 开始标签\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e startIndex = \u003cspan class=\"hljs-regexp\"\u003e/\u0026lt;([^\u0026gt;]+)\u0026gt;/\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 标签内容\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e content = \u003cspan class=\"hljs-regexp\"\u003e/[\\s\\S]*?/\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 匹配成对的标签\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e couple = \u003cspan class=\"hljs-regexp\"\u003e/\u0026lt;([^\u0026gt;]+)\u0026gt;[\\s\\S]*?\u0026lt;\\/\\1\u0026gt;/\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/\u0026lt;([^\u0026gt;]+)\u0026gt;[\\s\\S]*?\u0026lt;\\/\\1\u0026gt;/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026lt;a\u0026gt;123\u0026lt;/a\u0026gt;\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/\u0026lt;([^\u0026gt;]+)\u0026gt;[\\s\\S]*?\u0026lt;\\/\\1\u0026gt;/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026lt;a\u0026gt;123\u0026lt;/b\u0026gt;\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e非捕获\u003c/h3\u003e\n\u003cp\u003e除了捕获分组，正则表达式还提供了 \u003cstrong\u003e非捕获分组(non-capturing group)\u003c/strong\u003e，以 \u003ccode\u003e(?:)\u003c/code\u003e 的形式表示，它只用于限定作用范围，而不捕获任何文本。\u003c/p\u003e\n\u003cp\u003e比如，要匹配 \u003ccode\u003eabcabc\u003c/code\u003e 这个字符，一般地，可以写为 \u003ccode\u003e(abc){2}\u003c/code\u003e，但由于并不需要捕获文本，只是限定了量词的作用范围，所以应该写为 \u003ccode\u003e(?:abc){2}\u003c/code\u003e。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e/(abc){\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e}/.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;abcabc\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/(?:abc){2}/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;abcabc\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e由于非捕获分组不捕获文本，对应地，也就没有捕获组编号。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e/(abc){\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e}/.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;abcabc\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eRegExp\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e$1\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// \u0026#x27;abc\u0026#x27;\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/(?:abc){2}/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;abcabc\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title class_\"\u003eRegExp\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e$1\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// \u0026#x27;\u0026#x27;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e非捕获分组也不可以使用反向引用。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e/(?:\u003cspan class=\"hljs-number\"\u003e123\u003c/span\u003e)\\\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e/.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;123123\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/(123)\\1/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;123123\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e捕获分组和非捕获分组可以在一个正则表达式中同时出现。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e/(\\d)(\\d)(?:\\d)(\\d)(\\d)/.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;12345\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// [\u0026quot;12345\u0026quot;, \u0026quot;1\u0026quot;, \u0026quot;2\u0026quot;, \u0026quot;4\u0026quot;, \u0026quot;5\u0026quot;]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e断言\u003c/h2\u003e\n\u003cp\u003e在正则表达式中，有些结构并不真正匹配文本，而只负责判断在某个位置左/右侧是否符合要求，这种结构被称为 \u003cstrong\u003e断言（assertion）\u003c/strong\u003e，也称为 \u003cstrong\u003e锚点（anchor）\u003c/strong\u003e，常见的断言有 3 种：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e单词边界\u003c/li\u003e\n\u003cli\u003e起始结束\u003c/li\u003e\n\u003cli\u003e环视\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e单词边界\u003c/h3\u003e\n\u003cp\u003e在文本处理中可能会经常进行单词替换，比如把 \u003ccode\u003erow\u003c/code\u003e 替换成 \u003ccode\u003eline\u003c/code\u003e。但是，如果直接替换，不仅所有单词 \u003ccode\u003erow\u003c/code\u003e 都被替换成 \u003ccode\u003eline\u003c/code\u003e，单词内部的 \u003ccode\u003erow\u003c/code\u003e 也会被替换成 \u003ccode\u003eline\u003c/code\u003e。要想解决这个问题，必须有办法确定单词 \u003ccode\u003erow\u003c/code\u003e，而不是字符串 \u003ccode\u003erow\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e为了解决这类问题，正则表达式提供了专用的 \u003cstrong\u003e单词边界（word boundary）\u003c/strong\u003e，记为 \u003ccode\u003e\\b\u003c/code\u003e ，它匹配的是 单词边界 的位置，而不是字符。\u003ccode\u003e\\b\u003c/code\u003e 匹配的是一边是单词字符 \u003ccode\u003e\\w\u003c/code\u003e ，一边是非单词字符 \u003ccode\u003e\\W\u003c/code\u003e 的位置\u003c/p\u003e\n\u003cp\u003e与 \u003ccode\u003e\\b\u003c/code\u003e 对应的还有 \u003ccode\u003e\\B\u003c/code\u003e，表示非单词边界，但实际上 \u003ccode\u003e\\B\u003c/code\u003e 很少使用\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e/\\ban\\b/.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;an apple\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/\\ban\\b/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;a an\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/\\ban\\b/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;an\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/\\ban\\b/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;and\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/\\ban\\b/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;ban\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e起始结束\u003c/h3\u003e\n\u003cp\u003e常见的断言还有 \u003ccode\u003e^\u003c/code\u003e 和 \u003ccode\u003e$\u003c/code\u003e，它们分别匹配字符串的开始位置和结束位置，所以可以用来判断整个字符串能否由表达式匹配。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e//匹配第一个单词\u003c/span\u003e\n/^\\w*/.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;first word\\nsecond word\\nthird word\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// [\u0026#x27;first\u0026#x27;]\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e//匹配最后一个单词\u003c/span\u003e\n\u003cspan class=\"hljs-regexp\"\u003e/\\w*$/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;first word\\nsecond word\\nthird word\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// [\u0026#x27;word\u0026#x27;]\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/^a$/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;a\\n\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/^a$/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;a\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003e^\u003c/code\u003e 和 \u003ccode\u003e$\u003c/code\u003e 的常用功能是删除字符串首尾多余的空白，类似于字符串 \u003ccode\u003eString\u003c/code\u003e 对象的 \u003ccode\u003etrim()\u003c/code\u003e 方法。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efnTrim\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003estr\u003c/span\u003e) {\n  str.\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/^\\s+|\\s+$/\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026#x27;\u003c/span\u003e);\n}\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003efnTrim\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;      hello world   \u0026#x27;\u003c/span\u003e));\n\u003cspan class=\"hljs-comment\"\u003e// \u0026#x27;hello world\u0026#x27;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e环视\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e环视（Look-around）\u003c/strong\u003e，可形象地解释为停在原地，四处张望。环视类似于单词边界，在它旁边的文本需要满足某种条件，而且本身不匹配任何字符。\u003c/p\u003e\n\u003cp\u003e环视分为 \u003cstrong\u003e正序环视\u003c/strong\u003e 和 \u003cstrong\u003e逆序环视\u003c/strong\u003e，而 JavaScript 只支持正序环视，相当于只支持向前看，不支持往回看。\u003c/p\u003e\n\u003cp\u003e而正序环视又分为 \u003cstrong\u003e肯定正序环视\u003c/strong\u003e 和 \u003cstrong\u003e否定正序环视\u003c/strong\u003e。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e符号\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e描述\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003ex(?=y)\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003cstrong\u003e肯定\u003c/strong\u003e 正序环视，表示 \u003ccode\u003ex\u003c/code\u003e 后紧跟着 \u003ccode\u003ey\u003c/code\u003e 才匹配\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003ex(?!y)\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003cstrong\u003e否定\u003c/strong\u003e 正序环视，表示 \u003ccode\u003ex\u003c/code\u003e 后不紧跟着 \u003ccode\u003ey\u003c/code\u003e 才匹配\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e\u0026lt;br /\u0026gt;\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e/\u003cspan class=\"hljs-title function_\"\u003ea\u003c/span\u003e(?=b)/.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;abc\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// [\u0026#x27;a\u0026#x27;]\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/a(?=b)/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;ac\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// null\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/a(?!b)/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;abc\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// null\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/a(?!b)/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;ac\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// [\u0026#x27;a\u0026#x27;]\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/a(?=b)b/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;abc\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// [\u0026#x27;ab\u0026#x27;]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e环视虽然也用到括号，却与捕获型分组编号无关；但如果环视结构出现捕获型括号，则会影响分组。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e/\u003cspan class=\"hljs-title function_\"\u003eab\u003c/span\u003e(?=cd)/.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;abcd\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// [\u0026#x27;ab\u0026#x27;]\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/ab(?=(cd))/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eexec\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;abcd\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// [\u0026#x27;ab\u0026#x27;,\u0026#x27;cd\u0026#x27;]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e匹配模式\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e匹配模式（Match Mode）\u003c/strong\u003e 指匹配时使用的规则。设置特定的模式，可能会改变对正则表达式的识别。\u003c/p\u003e\n\u003ch3\u003e不区分大小写模式\u003c/h3\u003e\n\u003cp\u003e默认地，正则表达式是 \u003cstrong\u003e区分大小写\u003c/strong\u003e 的，通过设置标志 \u003ccode\u003ei\u003c/code\u003e，可以 \u003cstrong\u003e忽略大小写（ignore case）\u003c/strong\u003e。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e/ab/.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;aB\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/ab/i\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;aB\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e多行模式\u003c/h3\u003e\n\u003cp\u003e默认地，正则表达式中的 \u003ccode\u003e^\u003c/code\u003e 和 \u003ccode\u003e$\u003c/code\u003e 匹配的是整个字符串的起始位置和结束位置，而通过设置标志 \u003ccode\u003em\u003c/code\u003e，开启多行模式，它们也能匹配字符串内部某一行文本的起始位置和结束位置。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// example 1\u003c/span\u003e\n/world$/.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;hello world\\n\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/world$/m\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;hello world\\n\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// example 2\u003c/span\u003e\n\u003cspan class=\"hljs-regexp\"\u003e/^b/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;a\\nb\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/^b/m\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;a\\nb\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e全局模式\u003c/h3\u003e\n\u003cp\u003e默认地，第一次匹配成功后，正则对象就停止向下匹配了。\u003ccode\u003eg\u003c/code\u003e 修饰符表示 \u003cstrong\u003e全局匹配（global）\u003c/strong\u003e，设置 \u003ccode\u003eg\u003c/code\u003e 标志后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-string\"\u003e\u0026#x27;1a,2a,3a\u0026#x27;\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/a/\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;b\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// \u0026#x27;1b,2a,3a\u0026#x27;\u003c/span\u003e\n\n\u003cspan class=\"hljs-string\"\u003e\u0026#x27;1a,2a,3a\u0026#x27;\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ereplace\u003c/span\u003e(\u003cspan class=\"hljs-regexp\"\u003e/a/g\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;b\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// \u0026#x27;1b,2b,3b\u0026#x27;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e优先级\u003c/h2\u003e\n\u003cp\u003e下表为正则表达式符号优先级排序，从上到下，优先级逐渐降低（优先级数值越大，优先级越高）。\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e符号\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e符号名称\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003e优先级\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e\\\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e转义符\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e5\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e()\u003c/code\u003e \u003ccode\u003e(?!)\u003c/code\u003e \u003ccode\u003e(?=)\u003c/code\u003e \u003ccode\u003e[]\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e括号、字符集、环视\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e4\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e*\u003c/code\u003e \u003ccode\u003e+\u003c/code\u003e \u003ccode\u003e?\u003c/code\u003e \u003ccode\u003e{n}\u003c/code\u003e \u003ccode\u003e{n,}\u003c/code\u003e \u003ccode\u003e{n,m}\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e量词\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e3\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e^\u003c/code\u003e \u003ccode\u003e$\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e起始结束位置\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e2\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003e|\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e选择\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e1\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e由于括号的用途之一就是为量词限定作用范围，所以优先级比量词高。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e/ab{\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e}/.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;abab\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/(ab){2}/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;abab\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e选择符 \u003ccode\u003e|\u003c/code\u003e 的优先级最低，比起始和结束位置都要低。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e/^ab|cd$/.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;abc\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\n\u003cspan class=\"hljs-regexp\"\u003e/^(ab|cd)$/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;abc\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// false\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e局限性\u003c/h2\u003e\n\u003cp\u003e尽管 JavaScript 中的正则表达式功能比较完备，但与其他语言相比，缺少某些特性\u003c/p\u003e\n\u003cp\u003e下面列出了 JavaScript 正则表达式不支持的特性\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ePOSIX 字符组（只支持普通字符组和排除型字符组）\u003c/li\u003e\n\u003cli\u003eUnicode 支持（只支持单个 Unicode 字符）\u003c/li\u003e\n\u003cli\u003e匹配字符串开始和结尾的 \u003ccode\u003e\\A\u003c/code\u003e 和 \u003ccode\u003e\\Z\u003c/code\u003e 锚（只支持 \u003ccode\u003e^\u003c/code\u003e 和 \u003ccode\u003e$\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e逆序环视（只支持顺序环视）\u003c/li\u003e\n\u003cli\u003e命名分组（只支持 0-9 编号的捕获组）\u003c/li\u003e\n\u003cli\u003e单行模式和注释模式（只支持 \u003ccode\u003em\u003c/code\u003e 、\u003ccode\u003ei\u003c/code\u003e、\u003ccode\u003eg\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e模式作用范围\u003c/li\u003e\n\u003cli\u003e纯文本模式\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e参考资料\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://tool.oschina.net/uploads/apidocs/jquery/regexp.html\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e正则表达式手册\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://regexr.com/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003eRegExr 正则表达式练习网站\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://regexone.com/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003eRegexOne\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"markdown-body\",\"children\":[[\"$\",\"h1\",null,{\"children\":\"RegExp 语法\"}],[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"front-end\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"front-end knowledge\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>