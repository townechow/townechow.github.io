1:"$Sreact.fragment"
2:I[5244,[],""]
3:I[3866,[],""]
5:I[6213,[],"OutletBoundary"]
7:I[6213,[],"MetadataBoundary"]
9:I[6213,[],"ViewportBoundary"]
b:I[4835,[],""]
:HL["/_next/static/media/569ce4b8f30dc480-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/d4dd73d504c89c58.css","style"]
:HL["/_next/static/css/485ff6fe79292a08.css","style"]
:HL["/_next/static/css/0ff121a467c0636f.css","style"]
0:{"P":null,"b":"1zJy3VHENUSg9vzcRvJ6P","p":"","c":["","front-end","standard-built-in-objects","text-processing","regexp","regexp-rule"],"i":false,"f":[[["",{"children":["front-end",{"children":[["slug","standard-built-in-objects/text-processing/regexp/regexp-rule","oc"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/d4dd73d504c89c58.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__variable_4d318d __variable_ea5f4b antialiased","children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[],[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]]}],{"children":["front-end",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/485ff6fe79292a08.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/0ff121a467c0636f.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","main",null,{"children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","front-end","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]}]]}],{"children":[["slug","standard-built-in-objects/text-processing/regexp/regexp-rule","oc"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","front-end","children","$0:f:0:1:2:children:2:children:0","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L4",null,["$","$L5",null,{"children":"$L6"}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","tsz0Dl4EKIH4WfgeeZWC1",{"children":[["$","$L7",null,{"children":"$L8"}],["$","$L9",null,{"children":"$La"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}]]}],false]],"m":"$undefined","G":["$b","$undefined"],"s":false,"S":true}
c:Tea0c,<h1>RegExp 语法</h1>
<h2>元字符</h2>
<p><strong>元字符（Meta-Character）</strong> 指那些在正则表达式中具有特殊意义的专用字符，可以用来规定其前导字符（即位于元字符前面的字符）在目标对象中的出现模式。</p>
<table>
<thead>
<tr>
<th style="text-align:left">元字符</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">匹配对象</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>.</code></td>
<td style="text-align:left">点号</td>
<td style="text-align:left">单个任意字符(除回车 <code>\r</code>、换行 <code>\n</code>、行分隔符 <code>\u2028</code> 和段分隔符 <code>\u2029</code> 外)</td>
</tr>
<tr>
<td style="text-align:left"><code>[]</code></td>
<td style="text-align:left">字符组</td>
<td style="text-align:left">列出的单个任意字符</td>
</tr>
<tr>
<td style="text-align:left"><code>[^]</code></td>
<td style="text-align:left">排除型字符组</td>
<td style="text-align:left">未列出的单个任意字符</td>
</tr>
<tr>
<td style="text-align:left"><code>?</code></td>
<td style="text-align:left">问号</td>
<td style="text-align:left">匹配 0 次或 1 次</td>
</tr>
<tr>
<td style="text-align:left"><code>*</code></td>
<td style="text-align:left">星号</td>
<td style="text-align:left">匹配 0 次或多次</td>
</tr>
<tr>
<td style="text-align:left"><code>+</code></td>
<td style="text-align:left">加号</td>
<td style="text-align:left">匹配 1 次或多次</td>
</tr>
<tr>
<td style="text-align:left"><code>{min,max}</code></td>
<td style="text-align:left">区间量词</td>
<td style="text-align:left">匹配至少 min 次，最多 max 次</td>
</tr>
<tr>
<td style="text-align:left"><code>^</code></td>
<td style="text-align:left">脱字符</td>
<td style="text-align:left">行的起始位置</td>
</tr>
<tr>
<td style="text-align:left"><code>$</code></td>
<td style="text-align:left">美元符</td>
<td style="text-align:left">行的结束位置</td>
</tr>
<tr>
<td style="text-align:left">`</td>
<td style="text-align:left">`</td>
<td style="text-align:left">竖线</td>
</tr>
<tr>
<td style="text-align:left"><code>()</code></td>
<td style="text-align:left">括号</td>
<td style="text-align:left">限制多选结构的范围，标注量词作用的元素，为反向引用捕获文本</td>
</tr>
<tr>
<td style="text-align:left"><code>\1,\2...</code></td>
<td style="text-align:left">反向引用</td>
<td style="text-align:left">匹配之前的第一、第二...组括号内的表达式匹配的文本</td>
</tr>
</tbody>
</table>
<h2>字符类别</h2>
<h3>字符组简记</h3>
<p>用 <code>[0-9]</code>、<code>[a-z]</code> 等字符组，可以很方便地表示数字字符和小写字母字符。对于这类常用字符组，正则表达式提供了更简单的记法，这就是<strong>字符组简记（Shorthands）</strong>。</p>
<p>常见的字符组简记有 <code>\d</code>、<code>\w</code>、<code>\s</code>，其中：</p>
<ul>
<li><code>d</code> 表示（Digit）数字</li>
<li><code>w</code> 表示（Word）单词</li>
<li><code>s</code> 表示（Space）空白</li>
</ul>
<p>正则表达式也提供了对应排除型字符组的简记法：<code>\D</code>、<code>\W</code>、<code>\S</code>。字母完全相同，只是改为大写，这些简记法匹配的字符互补。</p>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\d</code></td>
<td style="text-align:center">数字，等同于 <code>[0-9]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\D</code></td>
<td style="text-align:center">非数字，等同于 <code>[^0-9]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\s</code></td>
<td style="text-align:center">空白字符，等同于 <code>[\f\n\r\t\u000B\u0020\u00A0\u2028\u2029]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\S</code></td>
<td style="text-align:center">非空白字符，等同于 <code>[^\f\n\r\t\u000B\u0020\u00A0\u2028\u2029]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\w</code></td>
<td style="text-align:center">字母、数字、下划线，等同于 <code>[0-9A-Za-z_]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\W</code></td>
<td style="text-align:center">非字母、数字、下划线，等同于 <code>[^0-9A-Za-z_]</code></td>
</tr>
</tbody>
</table>
<h3>任意字符</h3>
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>.</code></td>
<td style="text-align:left">表示除回车 <code>(\r)</code>、换行 <code>(\n)</code>、行分隔符 <code>(\u2028)</code> 和段分隔符 <code>(\u2029)</code> 以外的任意字符。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>⚠️ <strong>注意</strong>：一般认为点号可以代表任意字符，其实并不是</p>
<p>妥善的利用互补属性，可以得到一些巧妙的效果。比如，<code>[\s\S]</code>、<code>[\w\W]</code>、<code>[\d\D]</code> 都可以表示任意字符。</p>
</blockquote>
<p><strong>匹配任意字符</strong></p>
<pre class="hljs"><code class="language-js">/./.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;\r&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/[\s\S]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;\r&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<h3>转义字符</h3>
<p><strong>转义字符（Escape）</strong> 表示为反斜线 <code>\</code> 加字符的形式，共有以下 3 种情况。</p>
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>\</code> + 元字符</td>
<td style="text-align:left">匹配元字符</td>
</tr>
<tr>
<td style="text-align:left"><code>\</code> + <code>]</code> 或 <code>\</code> + <code>}</code></td>
<td style="text-align:left">右方括号和右花括号无需转义</td>
</tr>
<tr>
<td style="text-align:left"><code>\</code> + 非元字符</td>
<td style="text-align:left">表示一些不能打印的特殊字符</td>
</tr>
<tr>
<td style="text-align:left"><code>\</code> + 除上述其他字符</td>
<td style="text-align:left">默认情况匹配此字符</td>
</tr>
</tbody>
</table>
<p>&lt;br /&gt;</p>
<p>因为元字符有特殊的含义，所以无法直接匹配。如果要匹配它们本身，则需要在它们前面加上反斜杠 <code>\</code>。</p>
<pre class="hljs"><code class="language-js">/<span class="hljs-number">1</span>+<span class="hljs-number">1</span>/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;1+1&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/1\+1/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;1+1&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/\*/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;*&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-comment">/*/.test(&#x27;*&#x27;);
// 报错
</span></code></pre>
<p>但实际上，并非 14 个元字符都需要转义，右方括号 <code>]</code> 和右花括号 <code>}</code> 不需要转义</p>
<pre class="hljs"><code class="language-js">/]/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;]&#x27;</span>);
<span class="hljs-comment">// true</span>
<span class="hljs-regexp">/\]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;]&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/\}/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;}&#x27;</span>);
<span class="hljs-comment">// true</span>
<span class="hljs-regexp">/}/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;}&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<p><code>\</code> 加非元字符，表示一些不能打印的特殊字符。</p>
<p>&lt;br /&gt;</p>
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\0</code></td>
<td style="text-align:center">NUL 字符 <code>\u0000</code></td>
</tr>
<tr>
<td style="text-align:center"><code>[\b]</code></td>
<td style="text-align:center">匹配退格符 <code>\u0008</code>，不要与 <code>\b</code> 混淆</td>
</tr>
<tr>
<td style="text-align:center"><code>\t</code></td>
<td style="text-align:center">制表符 <code>\u0009</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\n</code></td>
<td style="text-align:center">换行符 <code>\u000A</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\v</code></td>
<td style="text-align:center">垂直制表符 <code>\u000B</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\f</code></td>
<td style="text-align:center">换页符 <code>\u000C</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\r</code></td>
<td style="text-align:center">回车符 <code>\u000D</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\xnn</code></td>
<td style="text-align:center">由十六进制数 <code>nn</code> 指定的拉丁字符</td>
</tr>
<tr>
<td style="text-align:center"><code>\uxxxx</code></td>
<td style="text-align:center">由十六进制数 <code>xxxx</code> 指定的 Unicode 字符( <code>\u4e00</code> - <code>\u9fa5</code> 代表中文)</td>
</tr>
<tr>
<td style="text-align:center"><code>\cX</code></td>
<td style="text-align:center">控制字符 <code>^X</code>，表示 <code>ctrl-[X]</code> ，其中的 X 是 A-Z 之中任一个英文字母，用来匹配控制字符</td>
</tr>
</tbody>
</table>
<p><code>\</code> 加任意其他字符，默认情况就是匹配此字符，也就是说，反斜线 <code>(\)</code> 被忽略了。</p>
<pre class="hljs"><code class="language-js">/\x/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;x&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/\y/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;y&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/\z/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;z&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<h3>双重转义</h3>
<p>由于 <code>RegExp</code> 构造函数的参数是字符串，所以某些情况下，需要对字符进行 <strong>双重转义</strong>。</p>
<p>字符 <code>\</code> 在正则表达式字符串中通常被转义为 <code>\\</code> 。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> reg1 = <span class="hljs-regexp">/\.at/</span>;
<span class="hljs-comment">// 等价于</span>
<span class="hljs-keyword">const</span> reg2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;\\.at&#x27;</span>);

<span class="hljs-keyword">const</span> reg3 = <span class="hljs-regexp">/name\/age/</span>;
<span class="hljs-comment">// 等价于</span>
<span class="hljs-keyword">const</span> reg4 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;name\\/age&#x27;</span>);

<span class="hljs-keyword">const</span> reg5 = <span class="hljs-regexp">/\w\\hello\\123/</span>;
<span class="hljs-comment">// 等价于</span>
<span class="hljs-keyword">const</span> reg6 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RegExp</span>(<span class="hljs-string">&#x27;\\w\\\\hello\\\\123&#x27;</span>);
</code></pre>
<h2>字符集合</h2>
<p><strong>字符集合（Character Sets）</strong>，有的编译成字符类或字符集。简单而言，就是指用方括号表示的一组字符，它匹配若干字符之一。</p>
<table>
<thead>
<tr>
<th>字符</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>[xyz]</code></td>
<td>一个字符集合，也叫字符组。匹配集合中任意一个字符。可以使用 <code>-</code> 指定一个范围。</td>
</tr>
<tr>
<td><code>[^xyz]</code></td>
<td>一个反义或补充字符集，也叫反义字符组。匹配任意不包括括号内的字符。可以使用 <code>-</code> 指定一个范围。</td>
</tr>
</tbody>
</table>
<p>&lt;br /&gt;</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 匹配 0-9 这 10 个数字之一</span>
<span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/[0123456789]/</span>;

regexp.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;1&#x27;</span>);
<span class="hljs-comment">// true</span>

regexp.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;a&#x27;</span>);
<span class="hljs-comment">// false</span>
</code></pre>
<p>字符组中的字符排列顺序并不影响字符组的功能，出现重复字符也不会影响。</p>
<p>以下三个表达式都是相等的。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> regexp1 = <span class="hljs-regexp">/[0123456789]/</span>;

<span class="hljs-keyword">const</span> regexp2 = <span class="hljs-regexp">/[9876543210] /</span>;

<span class="hljs-keyword">const</span> regexp3 = <span class="hljs-regexp">/[1234567890123456789]/</span>;
</code></pre>
<h3>范围</h3>
<p>正则表达式通过连字符 <code>(-)</code> 提供了范围表示法，可以简化字符组</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> regexp1 = <span class="hljs-regexp">/[0123456789]/</span>;
<span class="hljs-comment">// 等价于</span>
<span class="hljs-keyword">const</span> regexp2 = <span class="hljs-regexp">/[0-9]/</span>;

<span class="hljs-keyword">const</span> regexp3 = <span class="hljs-regexp">/[abcdefghijklmnopqrstuvwxyz]/</span>;
<span class="hljs-comment">// 等价于</span>
<span class="hljs-keyword">const</span> regexp4 = <span class="hljs-regexp">/[a-z]/</span>;
</code></pre>
<p>连字符 <code>(-)</code> 表示的范围是根据 ASCII 编码的码值来确定的，码值小的在前，码值大的在后。</p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../../assets/regexp/ascii.gif&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;ASCII编码表&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{720}</span> /&gt;</span></span>;
</code></pre>
<p>所以 <code>[0-9]</code> 是合法的，而 <code>[9-0]</code> 会报错。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">//匹配 0-9 这 10 个数字之一</span>
<span class="hljs-keyword">const</span> regexp1 = <span class="hljs-regexp">/[0-9]/</span>;
regexp1.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;1&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-keyword">const</span> regexp2 = <span class="hljs-regexp">/[9-0]/</span>;
<span class="hljs-comment">// 报错</span>
regexp2.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;1&#x27;</span>);
</code></pre>
<p>在字符组中可以同时并列多个 <code>-</code> 范围。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> regexp1 = <span class="hljs-regexp">/[0-9a-zA-Z]/</span>;
<span class="hljs-comment">// 匹配数字、大写字母和小写字母</span>
<span class="hljs-keyword">const</span> regexp2 = <span class="hljs-regexp">/[0-9a-fA-F]/</span>;
<span class="hljs-comment">// 匹配数字，大、小写形式的a-f，用来验证十六进制字符</span>

<span class="hljs-keyword">const</span> regexp3 = <span class="hljs-regexp">/[0-9a-fA-F]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;d&#x27;</span>);
<span class="hljs-comment">// true</span>
<span class="hljs-keyword">const</span> regexp4 = <span class="hljs-regexp">/[0-9a-fA-F]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;x&#x27;</span>);
<span class="hljs-comment">// false</span>
</code></pre>
<p>只有在字符组内部，连字符 <code>-</code> 才是元字符，表示一个范围，否则它就只能匹配普通的连字符号。</p>
<p>如果连字符出现在字符组的开头或末尾，它表示的也是普通的连字符号，而不是一个范围。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 匹配中划线</span>
/-/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;-&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/[-]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;-&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-comment">// 匹配0-9的数字或中划线</span>
<span class="hljs-regexp">/[0-9]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;-&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/[0-9-]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;-&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/[0-9\-]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;-&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/[-0-9]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;-&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/[\-0-9]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;-&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<h3>排除</h3>
<p>字符组的另一个类型是 <strong>排除型字符组</strong>，在左方括号后紧跟一个脱字符 <code>^</code> 表示，表示在当前位置匹配一个没有列出的字符。</p>
<p>所以 <code>[^0-9]</code> 表示 0-9 以外的字符。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 匹配第一个是数字字符，第二个不是数字字符的字符串</span>
/[<span class="hljs-number">0</span>-<span class="hljs-number">9</span>][^<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;1e&#x27;</span>);
<span class="hljs-comment">// true</span>
<span class="hljs-regexp">/[0-9][^0-9]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;q2&#x27;</span>);
<span class="hljs-comment">// false</span>
</code></pre>
<p>在字符组内部，脱字符 <code>^</code> 表示排除，而在字符组外部，脱字符 <code>^</code> 表示一个行锚点。</p>
<p><code>^</code> 符号是元字符，在字符组中只要 <code>^</code> 符号不挨着左方括号就可以表示其本身含义，不转义也可以。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 匹配 abc 和 ^ 符号</span>
/[a-c^]/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;^&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/[a-c\^]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;^&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/[\^a-c]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;^&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<p>在字符组中，只有 <code>^</code> 、 <code>-</code> 、<code>[</code> 、<code>]</code> 这 4 个字符可能被当做元字符，其他有元字符功能的字符都只表示其本身。</p>
<pre class="hljs"><code class="language-js">/[[<span class="hljs-number">1</span>]]/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;[&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/[[1]]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;]&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/[\1]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;\\&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/[^^]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;^&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/[1-2]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;-&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/[\[1\]]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;[&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/[\[1\]]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;]&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/[\\]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;\\&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/[^]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;^&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/[1-2\-]/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;-&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<h2>数量词</h2>
<p>正则表达式提供了量词，用来设定某个模式出现的次数。</p>
<table>
<thead>
<tr>
<th style="text-align:left">字符</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>x*</code></td>
<td style="text-align:left">相当于 <code>x{0,}</code> （匹配任意多次）</td>
</tr>
<tr>
<td style="text-align:left"><code>x+</code></td>
<td style="text-align:left">相当于 <code>x{1,}</code>（匹配至少一次）</td>
</tr>
<tr>
<td style="text-align:left"><code>x?</code></td>
<td style="text-align:left">相当于 <code>x{0,1}</code> （不匹配或匹配一次）</td>
</tr>
<tr>
<td style="text-align:left"><code>x*?</code> 或 <code>x+?</code></td>
<td style="text-align:left">相当于 <code>*</code> 和 <code>+</code>字符，然而匹配的是最小可能匹配</td>
</tr>
<tr>
<td style="text-align:left"><code>x(?=y)</code></td>
<td style="text-align:left">只有当 <code>x</code> 后面紧跟着 <code>y</code> 时，才匹配 <code>x</code>。（了解详情请看 <a href="/front-end/standard-built-in-objects/text-processing/regexp/#%E7%8E%AF%E8%A7%86">环视</a>）</td>
</tr>
<tr>
<td style="text-align:left"><code>x(?!y)</code></td>
<td style="text-align:left">只有当 <code>x</code> 后面不是紧跟着 <code>y</code> 时，才匹配 <code>x</code>。（了解详情请看 <a href="/front-end/standard-built-in-objects/text-processing/regexp/#%E7%8E%AF%E8%A7%86">环视</a>）</td>
</tr>
<tr>
<td style="text-align:left"><code>x|y</code>（这里是没有 <code>\</code> 的）</td>
<td style="text-align:left">匹配 <code>x</code> 或 <code>y</code></td>
</tr>
<tr>
<td style="text-align:left"><code>x{n}</code></td>
<td style="text-align:left">匹配 <code>n</code> 次（<code>n</code> 为正整数）</td>
</tr>
<tr>
<td style="text-align:left"><code>x{n,m}</code></td>
<td style="text-align:left">匹配至少 <code>n</code> 次，最多 <code>m</code> 次（<code>n</code> 和 <code>m</code> 为正整数）</td>
</tr>
<tr>
<td style="text-align:left"><code>x{n,}</code></td>
<td style="text-align:left">匹配至少 <code>n</code> 次（<code>n</code> 为正整数）</td>
</tr>
</tbody>
</table>
<p>&lt;br /&gt;</p>
<p>邮政编码</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 表示邮政编码 6 位数字</span>
<span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/\d{6}/</span>;
</code></pre>
<p>美国英语和英国英语有些词的写法不一样，如果 <code>traveler</code> 和 <code>traveller</code>，<code>favor</code> 和 <code>favour</code>，<code>color</code> 和 <code>colour</code>。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 同时匹配美国英语和英国英语单词</span>
<span class="hljs-keyword">const</span> regexp1 = <span class="hljs-regexp">/travell?er/</span>;

<span class="hljs-keyword">const</span> regexp2 = <span class="hljs-regexp">/favou?r/</span>;

<span class="hljs-keyword">const</span> regexp3 = <span class="hljs-regexp">/colou?r/</span>;
</code></pre>
<p>协议名有 HTTP 和 HTTPS 两种：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> regexp1 = <span class="hljs-regexp">/https?/</span>;
</code></pre>
<h3>选择</h3>
<p>竖线 <code>|</code> 在正则表达式中表示或关系的选择，以竖线 <code>|</code> 分隔开的多个子表达式也叫选择分支或选择项。在一个选择结构中，选择分支的数目没有限制。</p>
<p>在选择结构中，竖线 <code>|</code> 用来分隔选择项，而括号 <code>()</code> 用来规定整个选择结构的范围。如果没有出现括号，则将整个表达式视为一个选择结构。</p>
<p>选择项的尝试匹配次序是从左到右，直到发现了匹配项，如果某个选择项匹配就忽略右侧其他选择项，如果所有子选择项都不匹配，则整个选择结构匹配失败。</p>
<pre class="hljs"><code class="language-js">/<span class="hljs-number">12</span>|<span class="hljs-number">23</span>|<span class="hljs-number">34</span>/.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;1&#x27;</span>);
<span class="hljs-comment">// null</span>

<span class="hljs-regexp">/12|23|34/</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;12&#x27;</span>);
<span class="hljs-comment">// [&#x27;12&#x27;]</span>

<span class="hljs-regexp">/12|23|34/</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;23&#x27;</span>);
<span class="hljs-comment">// [&#x27;23&#x27;]</span>

<span class="hljs-regexp">/12|23|34/</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;2334&#x27;</span>);
<span class="hljs-comment">// [&#x27;23&#x27;]</span>
</code></pre>
<p>IP 地址一般由 3 个点号和 4 段数字组成，每段数字都在 0-255 之间。</p>
<ul>
<li>0-199：<code>[01]?\d\d?</code></li>
<li>200-249：<code>2[0-4]\d</code></li>
<li>250-255：<code>25[0-5]</code></li>
</ul>
<p>IP 地址：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> ipRegExp = <span class="hljs-regexp">/((2[0-4]\d|25[0-5]|[0-1]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[0-1]?\d\d?)/</span>;

ipRegExp.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;1.1.1.1&#x27;</span>);
<span class="hljs-comment">// true</span>

ipRegExp.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;1.1.1&#x27;</span>);
<span class="hljs-comment">// false</span>

ipRegExp.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;256.1.1.1&#x27;</span>);
<span class="hljs-comment">// false</span>
</code></pre>
<p>类似地，时间匹配也需要分段处理：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 月(1-12)</span>
<span class="hljs-number">0</span>?\d|<span class="hljs-number">1</span>[<span class="hljs-number">0</span>-<span class="hljs-number">2</span>]

<span class="hljs-comment">// 日(1-31)</span>
<span class="hljs-number">0</span>?\d|[<span class="hljs-number">12</span>]\d|<span class="hljs-number">3</span>[<span class="hljs-number">01</span>]

<span class="hljs-comment">// 小时(0-24)</span>
<span class="hljs-number">0</span>?\d|<span class="hljs-number">1</span>\d|<span class="hljs-number">2</span>[<span class="hljs-number">0</span>-<span class="hljs-number">4</span>]

<span class="hljs-comment">// 分钟(0-60)</span>
<span class="hljs-number">0</span>?\d|[<span class="hljs-number">1</span>-<span class="hljs-number">5</span>]\d|<span class="hljs-number">60</span>
</code></pre>
<p>手机号一般是 11 位，前 3 位是号段，后 8 位一般没有限制。而且，在手机开头很可能有 0 或+86。</p>
<ul>
<li>开头：<code>(0|\+86)?</code></li>
<li>前 3 位：<code>13\d|14[579]|15[0-35-9]|17[0135-8]|18\d</code></li>
<li>后 8 位：<code>\d{8}</code></li>
</ul>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> phone = <span class="hljs-regexp">/(0|\+86)?(13\d|14[579]|15[0-35-9]|17[0135-8]|18\d)\d{8}/</span>;

phone.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;13453250661&#x27;</span>);
<span class="hljs-comment">// true</span>

phone.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;1913250661&#x27;</span>);
<span class="hljs-comment">// false</span>

phone.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;1345325061&#x27;</span>);
<span class="hljs-comment">// false</span>
</code></pre>
<p>在选择结构中，应该尽量避免选择分支中存在重复匹配，因为这样会大大增加回溯的计算量</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 错误示范 🙅‍♂️</span>
<span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/a|[ab][0-9]|\w/</span>;
</code></pre>
<h3>贪婪模式</h3>
<p>默认情况下，量词都是<strong>贪婪模式（Greedy quantifier）</strong>，即匹配到下一个字符不满足匹配规则为止。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// exec 方法以数组的形式返回匹配结果</span>
/a+/.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>);
<span class="hljs-comment">// [&#x27;aaa&#x27;]</span>
</code></pre>
<h3>懒惰模式</h3>
<p><strong>懒惰模式（Lazy quantifier）</strong> 和贪婪模式相对应，在量词后加问号 <code>?</code> 表示，表示尽可能少的匹配，一旦条件满足就再不往下匹配。</p>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">释义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>{n}?</code></td>
<td style="text-align:left">匹配 <code>n</code> 次</td>
</tr>
<tr>
<td style="text-align:left"><code>{n,m}?</code></td>
<td style="text-align:left">匹配至少 <code>n</code> 次，最多 <code>m</code> 次</td>
</tr>
<tr>
<td style="text-align:left"><code>{n,}?</code></td>
<td style="text-align:left">匹配至少 <code>n</code> 次</td>
</tr>
<tr>
<td style="text-align:left"><code>??</code></td>
<td style="text-align:left">相当于<code>{0,1}</code></td>
</tr>
<tr>
<td style="text-align:left"><code>*?</code></td>
<td style="text-align:left">相当于<code>{0,}</code></td>
</tr>
<tr>
<td style="text-align:left"><code>+?</code></td>
<td style="text-align:left">相当于<code>{1,}</code></td>
</tr>
</tbody>
</table>
<p>&lt;br /&gt;</p>
<p>示例：</p>
<pre class="hljs"><code class="language-js">/a+?/.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;aaa&#x27;</span>);
<span class="hljs-comment">// [&#x27;a&#x27;]</span>
</code></pre>
<p>匹配 <code>&lt;script&gt;&lt;/script&gt;</code> 之间的代码看上去很容易</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/&lt;script&gt;[\s\S]*&lt;\/script&gt;/</span>;

regexp.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;&lt;script&gt;alert(&quot;1&quot;);&lt;/script&gt;&#x27;</span>);
<span class="hljs-comment">// [&quot;&lt;script&gt;alert(&quot;1&quot;);&lt;/script&gt;&quot;]</span>
</code></pre>
<p>但如果多次出现 <code>script</code> 标签，就会出问题</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/&lt;script&gt;[\s\S]*&lt;\/script&gt;/</span>;

regexp.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;&lt;script&gt;alert(&quot;1&quot;);&lt;/script&gt;&lt;br&gt;&lt;script&gt;alert(&quot;2&quot;);&lt;/script&gt;&#x27;</span>);
<span class="hljs-comment">// [&quot;&lt;script&gt;alert(&quot;1&quot;);&lt;/script&gt;&lt;br&gt;&lt;script&gt;alert(&quot;2&quot;);&lt;/script&gt;&quot;]</span>
</code></pre>
<p>它把无用的 <code>&lt;br&gt;</code> 标签也匹配出来了，此时就需要使用懒惰模式</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/&lt;script&gt;[\s\S]*?&lt;\/script&gt;/</span>;

regexp.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;&lt;script&gt;alert(&quot;1&quot;);&lt;/script&gt;&lt;br&gt;&lt;script&gt;alert(&quot;2&quot;);&lt;/script&gt;&#x27;</span>);
<span class="hljs-comment">// [&quot;&lt;script&gt;alert(&quot;1&quot;);&lt;/script&gt;&quot;]</span>
</code></pre>
<p>在 JavaScript 中，<code>/* */</code> 是注释的一种形式，在文档中可能出现多次，这时就必须使用懒惰模式</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/\/\*[\s\S]*?\*\//</span>;

regexp.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;/*abc*/&lt;br&gt;/*123*/&#x27;</span>);
<span class="hljs-comment">// [&quot;/*abc*/&quot;]</span>
</code></pre>
<h2>分组与反向引用</h2>
<h3>分组</h3>
<p>量词控制之前元素的出现次数，而这个元素可能是一个字符，也可能是一个字符组，也可以是一个表达式。</p>
<p>如果把一个表达式用括号包围起来，这个元素就是括号里的表达式，被称为 <strong>子表达式</strong>。</p>
<p><strong>示例 1</strong>：如果希望字符串 <code>ab</code> 重复出现 2 次，应该写为 <code>(ab){2}</code>，而如果写为 <code>ab{2}</code>，则 <code>{2}</code> 只限定 <code>b</code>。</p>
<pre class="hljs"><code class="language-js">/(ab){<span class="hljs-number">2</span>}/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abab&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/(ab){2}/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abb&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/ab{2}/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abab&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/ab{2}/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abb&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<p><strong>示例 2</strong>：身份证长度有 15 位和 18 位两种，如果只匹配长度，可能会想当然地写成 <code>\d{15,18}</code>，实际上这是错误的，因为它包括 15、16、17、18 这四种长度。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 正确写法</span>
<span class="hljs-keyword">var</span> idCard = <span class="hljs-regexp">/\d{15}(\d{3})?/</span>;
</code></pre>
<p><strong>示例 3</strong>：Email 地址以 <code>@</code> 分隔成两段，之前的部分是用户名，之后的部分是主机名。</p>
<p>用户名允许出现数字、字母和下划线，长度一般在 1-64 个字符之间，则正则可表示为 <code>/\w{1,64}/</code></p>
<p>主机名一般表现为 <code>a.b.···.c</code>，其中 <code>c</code> 为主域名，其他为级数不定的子域名，则正则可表示为 <code>/([-a-zA-z0-9]{1,63}\.)+[-a-zA-Z0-9]{1,63}/</code></p>
<p>所以 email 地址的正则表达式如下：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> email = <span class="hljs-regexp">/\w{1,64}@([-a-zA-z0-9]{1,63}\.)+[-a-zA-Z0-9]{1,63}/</span>;

email.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;q@qq.com&#x27;</span>);
<span class="hljs-comment">// true</span>

email.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;q@qq&#x27;</span>);
<span class="hljs-comment">// false</span>

email.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;q@a.qq.com&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<h3>捕获</h3>
<p>括号不仅可以对元素进行分组，还会保存每个分组匹配的文本，等到匹配完成后，引用捕获的内容。因为捕获了文本，这种功能叫 <strong>捕获分组</strong>。</p>
<p>比如，要匹配诸如 <code>2016-06-23</code> 这样的日期字符串</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> regexp = <span class="hljs-regexp">/(\d{4})-(\d{2})-(\d{2})/</span>;
</code></pre>
<p>与以往不同的是，年、月、日这三个数值被括号括起来了，从左到右为第 1 个括号、第 2 个括号和第 3 个括号，分别代表第 1、2、3 个捕获组。</p>
<p>JavaScript 有 9 个用于存储捕获组的构造函数属性。</p>
<p><code>RegExp.$1</code>、<code>RegExp.$2</code>、<code>RegExp.$3</code> 到 <code>RegExp.$9</code> 分别用于存储第一、第二第九个匹配的捕获组。</p>
<p>在调用 <code>exec()</code> 或 <code>test()</code> 方法时，这些属性会被自动填充。</p>
<pre class="hljs"><code class="language-js">/(\d{<span class="hljs-number">4</span>})-(\d{<span class="hljs-number">2</span>})-(\d{<span class="hljs-number">2</span>})/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;2016-06-23&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$1</span>);
<span class="hljs-comment">// &#x27;2016&#x27;</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$2</span>);
<span class="hljs-comment">// &#x27;06&#x27;</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$3</span>);
<span class="hljs-comment">// &#x27;23&#x27;</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$4</span>);
<span class="hljs-comment">// &#x27;&#x27;</span>
</code></pre>
<p>而 <code>exec()</code> 方法是专门为捕获组而设计的，返回的数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串。</p>
<pre class="hljs"><code class="language-js">/(\d{<span class="hljs-number">4</span>})-(\d{<span class="hljs-number">2</span>})-(\d{<span class="hljs-number">2</span>})/.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;2016-06-23&#x27;</span>);
<span class="hljs-comment">// [&quot;2016-06-23&quot;, &quot;2016&quot;, &quot;06&quot;, &quot;23&quot;]</span>
</code></pre>
<p>捕获分组捕获的文本，不仅可以 <strong>用于数据提取</strong>，也可以 <strong>用于替换</strong>。</p>
<p><code>replace()</code> 方法就是用于进行数据替换的，该方法接收两个参数，第一个参数为待查找的内容，而第二个参数为替换的内容。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-string">&#x27;2000-01-01&#x27;</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/-/g</span>, <span class="hljs-string">&#x27;.&#x27;</span>);
<span class="hljs-comment">// 2000.01.01</span>
</code></pre>
<p>在 <code>replace()</code> 方法中也可以引用分组，形式是 <code>$num</code>， <code>num</code> 是对应分组的编号。</p>
<p>把 <code>2000-01-01</code> 的形式变成 <code>01-01-2000</code> 的形式：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-string">&#x27;2000-01-01&#x27;</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(\d{4})-(\d{2})-(\d{2})/g</span>, <span class="hljs-string">&#x27;$3-$2-$1&#x27;</span>);
<span class="hljs-comment">//&#x27;01-01-2000&#x27;</span>
</code></pre>
<h3>反向引用</h3>
<p>英文中不少单词都有重叠出现的字母，如 <code>shoot</code> 或 <code>beep</code>。若想检查某个单词是否包含重叠出现的字母，则需要引入 <strong>反向引用（back-reference）</strong></p>
<p>反向引用允许在正则表达式内部引用之前捕获分组匹配的文本，形式是 <code>\num</code>，<code>num</code> 表示所引用分组的编号。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">//重复字母</span>
/([a-z])\<span class="hljs-number">1</span>/

<span class="hljs-regexp">/([a-z])\1/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;aa&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/([a-z])\1/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;ab&#x27;</span>);
<span class="hljs-comment">// false</span>
</code></pre>
<p>反向引用可以用于建立前后联系。HTML 标签的开始标签和结束标签是对应的。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 开始标签</span>
<span class="hljs-keyword">const</span> startIndex = <span class="hljs-regexp">/&lt;([^&gt;]+)&gt;/</span>

<span class="hljs-comment">// 标签内容</span>
<span class="hljs-keyword">const</span> content = <span class="hljs-regexp">/[\s\S]*?/</span>

<span class="hljs-comment">// 匹配成对的标签</span>
<span class="hljs-keyword">const</span> couple = <span class="hljs-regexp">/&lt;([^&gt;]+)&gt;[\s\S]*?&lt;\/\1&gt;/</span>

<span class="hljs-regexp">/&lt;([^&gt;]+)&gt;[\s\S]*?&lt;\/\1&gt;/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;&lt;a&gt;123&lt;/a&gt;&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/&lt;([^&gt;]+)&gt;[\s\S]*?&lt;\/\1&gt;/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;&lt;a&gt;123&lt;/b&gt;&#x27;</span>);
<span class="hljs-comment">// false</span>
</code></pre>
<h3>非捕获</h3>
<p>除了捕获分组，正则表达式还提供了 <strong>非捕获分组(non-capturing group)</strong>，以 <code>(?:)</code> 的形式表示，它只用于限定作用范围，而不捕获任何文本。</p>
<p>比如，要匹配 <code>abcabc</code> 这个字符，一般地，可以写为 <code>(abc){2}</code>，但由于并不需要捕获文本，只是限定了量词的作用范围，所以应该写为 <code>(?:abc){2}</code>。</p>
<pre class="hljs"><code class="language-js">/(abc){<span class="hljs-number">2</span>}/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abcabc&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/(?:abc){2}/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abcabc&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<p>由于非捕获分组不捕获文本，对应地，也就没有捕获组编号。</p>
<pre class="hljs"><code class="language-js">/(abc){<span class="hljs-number">2</span>}/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abcabc&#x27;</span>);
<span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$1</span>);
<span class="hljs-comment">// &#x27;abc&#x27;</span>

<span class="hljs-regexp">/(?:abc){2}/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abcabc&#x27;</span>);
<span class="hljs-comment">// true</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">RegExp</span>.<span class="hljs-property">$1</span>);
<span class="hljs-comment">// &#x27;&#x27;</span>
</code></pre>
<p>非捕获分组也不可以使用反向引用。</p>
<pre class="hljs"><code class="language-js">/(?:<span class="hljs-number">123</span>)\<span class="hljs-number">1</span>/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;123123&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/(123)\1/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;123123&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<p>捕获分组和非捕获分组可以在一个正则表达式中同时出现。</p>
<pre class="hljs"><code class="language-js">/(\d)(\d)(?:\d)(\d)(\d)/.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;12345&#x27;</span>);
<span class="hljs-comment">// [&quot;12345&quot;, &quot;1&quot;, &quot;2&quot;, &quot;4&quot;, &quot;5&quot;]</span>
</code></pre>
<h2>断言</h2>
<p>在正则表达式中，有些结构并不真正匹配文本，而只负责判断在某个位置左/右侧是否符合要求，这种结构被称为 <strong>断言（assertion）</strong>，也称为 <strong>锚点（anchor）</strong>，常见的断言有 3 种：</p>
<ul>
<li>单词边界</li>
<li>起始结束</li>
<li>环视</li>
</ul>
<h3>单词边界</h3>
<p>在文本处理中可能会经常进行单词替换，比如把 <code>row</code> 替换成 <code>line</code>。但是，如果直接替换，不仅所有单词 <code>row</code> 都被替换成 <code>line</code>，单词内部的 <code>row</code> 也会被替换成 <code>line</code>。要想解决这个问题，必须有办法确定单词 <code>row</code>，而不是字符串 <code>row</code>。</p>
<p>为了解决这类问题，正则表达式提供了专用的 <strong>单词边界（word boundary）</strong>，记为 <code>\b</code> ，它匹配的是 单词边界 的位置，而不是字符。<code>\b</code> 匹配的是一边是单词字符 <code>\w</code> ，一边是非单词字符 <code>\W</code> 的位置</p>
<p>与 <code>\b</code> 对应的还有 <code>\B</code>，表示非单词边界，但实际上 <code>\B</code> 很少使用</p>
<pre class="hljs"><code class="language-js">/\ban\b/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;an apple&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/\ban\b/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;a an&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/\ban\b/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;an&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/\ban\b/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;and&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/\ban\b/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;ban&#x27;</span>);
<span class="hljs-comment">// false</span>
</code></pre>
<h3>起始结束</h3>
<p>常见的断言还有 <code>^</code> 和 <code>$</code>，它们分别匹配字符串的开始位置和结束位置，所以可以用来判断整个字符串能否由表达式匹配。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">//匹配第一个单词</span>
/^\w*/.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;first word\nsecond word\nthird word&#x27;</span>);
<span class="hljs-comment">// [&#x27;first&#x27;]</span>

<span class="hljs-comment">//匹配最后一个单词</span>
<span class="hljs-regexp">/\w*$/</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;first word\nsecond word\nthird word&#x27;</span>);
<span class="hljs-comment">// [&#x27;word&#x27;]</span>

<span class="hljs-regexp">/^a$/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;a\n&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/^a$/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;a&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<p><code>^</code> 和 <code>$</code> 的常用功能是删除字符串首尾多余的空白，类似于字符串 <code>String</code> 对象的 <code>trim()</code> 方法。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fnTrim</span>(<span class="hljs-params">str</span>) {
  str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/^\s+|\s+$/</span>, <span class="hljs-string">&#x27;&#x27;</span>);
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fnTrim</span>(<span class="hljs-string">&#x27;      hello world   &#x27;</span>));
<span class="hljs-comment">// &#x27;hello world&#x27;</span>
</code></pre>
<h3>环视</h3>
<p><strong>环视（Look-around）</strong>，可形象地解释为停在原地，四处张望。环视类似于单词边界，在它旁边的文本需要满足某种条件，而且本身不匹配任何字符。</p>
<p>环视分为 <strong>正序环视</strong> 和 <strong>逆序环视</strong>，而 JavaScript 只支持正序环视，相当于只支持向前看，不支持往回看。</p>
<p>而正序环视又分为 <strong>肯定正序环视</strong> 和 <strong>否定正序环视</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>x(?=y)</code></td>
<td style="text-align:left"><strong>肯定</strong> 正序环视，表示 <code>x</code> 后紧跟着 <code>y</code> 才匹配</td>
</tr>
<tr>
<td style="text-align:left"><code>x(?!y)</code></td>
<td style="text-align:left"><strong>否定</strong> 正序环视，表示 <code>x</code> 后不紧跟着 <code>y</code> 才匹配</td>
</tr>
</tbody>
</table>
<p>&lt;br /&gt;</p>
<pre class="hljs"><code class="language-js">/<span class="hljs-title function_">a</span>(?=b)/.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;abc&#x27;</span>);
<span class="hljs-comment">// [&#x27;a&#x27;]</span>

<span class="hljs-regexp">/a(?=b)/</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;ac&#x27;</span>);
<span class="hljs-comment">// null</span>

<span class="hljs-regexp">/a(?!b)/</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;abc&#x27;</span>);
<span class="hljs-comment">// null</span>

<span class="hljs-regexp">/a(?!b)/</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;ac&#x27;</span>);
<span class="hljs-comment">// [&#x27;a&#x27;]</span>

<span class="hljs-regexp">/a(?=b)b/</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;abc&#x27;</span>);
<span class="hljs-comment">// [&#x27;ab&#x27;]</span>
</code></pre>
<p>环视虽然也用到括号，却与捕获型分组编号无关；但如果环视结构出现捕获型括号，则会影响分组。</p>
<pre class="hljs"><code class="language-js">/<span class="hljs-title function_">ab</span>(?=cd)/.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;abcd&#x27;</span>);
<span class="hljs-comment">// [&#x27;ab&#x27;]</span>

<span class="hljs-regexp">/ab(?=(cd))/</span>.<span class="hljs-title function_">exec</span>(<span class="hljs-string">&#x27;abcd&#x27;</span>);
<span class="hljs-comment">// [&#x27;ab&#x27;,&#x27;cd&#x27;]</span>
</code></pre>
<h2>匹配模式</h2>
<p><strong>匹配模式（Match Mode）</strong> 指匹配时使用的规则。设置特定的模式，可能会改变对正则表达式的识别。</p>
<h3>不区分大小写模式</h3>
<p>默认地，正则表达式是 <strong>区分大小写</strong> 的，通过设置标志 <code>i</code>，可以 <strong>忽略大小写（ignore case）</strong>。</p>
<pre class="hljs"><code class="language-js">/ab/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;aB&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/ab/i</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;aB&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<h3>多行模式</h3>
<p>默认地，正则表达式中的 <code>^</code> 和 <code>$</code> 匹配的是整个字符串的起始位置和结束位置，而通过设置标志 <code>m</code>，开启多行模式，它们也能匹配字符串内部某一行文本的起始位置和结束位置。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// example 1</span>
/world$/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;hello world\n&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/world$/m</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;hello world\n&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-comment">// example 2</span>
<span class="hljs-regexp">/^b/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;a\nb&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/^b/m</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;a\nb&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<h3>全局模式</h3>
<p>默认地，第一次匹配成功后，正则对象就停止向下匹配了。<code>g</code> 修饰符表示 <strong>全局匹配（global）</strong>，设置 <code>g</code> 标志后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-string">&#x27;1a,2a,3a&#x27;</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/a/</span>, <span class="hljs-string">&#x27;b&#x27;</span>);
<span class="hljs-comment">// &#x27;1b,2a,3a&#x27;</span>

<span class="hljs-string">&#x27;1a,2a,3a&#x27;</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/a/g</span>, <span class="hljs-string">&#x27;b&#x27;</span>);
<span class="hljs-comment">// &#x27;1b,2b,3b&#x27;</span>
</code></pre>
<h2>优先级</h2>
<p>下表为正则表达式符号优先级排序，从上到下，优先级逐渐降低（优先级数值越大，优先级越高）。</p>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">符号名称</th>
<th style="text-align:left">优先级</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>\</code></td>
<td style="text-align:left">转义符</td>
<td style="text-align:left">5</td>
</tr>
<tr>
<td style="text-align:left"><code>()</code> <code>(?!)</code> <code>(?=)</code> <code>[]</code></td>
<td style="text-align:left">括号、字符集、环视</td>
<td style="text-align:left">4</td>
</tr>
<tr>
<td style="text-align:left"><code>*</code> <code>+</code> <code>?</code> <code>{n}</code> <code>{n,}</code> <code>{n,m}</code></td>
<td style="text-align:left">量词</td>
<td style="text-align:left">3</td>
</tr>
<tr>
<td style="text-align:left"><code>^</code> <code>$</code></td>
<td style="text-align:left">起始结束位置</td>
<td style="text-align:left">2</td>
</tr>
<tr>
<td style="text-align:left"><code>|</code></td>
<td style="text-align:left">选择</td>
<td style="text-align:left">1</td>
</tr>
</tbody>
</table>
<p>由于括号的用途之一就是为量词限定作用范围，所以优先级比量词高。</p>
<pre class="hljs"><code class="language-js">/ab{<span class="hljs-number">2</span>}/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abab&#x27;</span>);
<span class="hljs-comment">// false</span>

<span class="hljs-regexp">/(ab){2}/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abab&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<p>选择符 <code>|</code> 的优先级最低，比起始和结束位置都要低。</p>
<pre class="hljs"><code class="language-js">/^ab|cd$/.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abc&#x27;</span>);
<span class="hljs-comment">// true</span>

<span class="hljs-regexp">/^(ab|cd)$/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-string">&#x27;abc&#x27;</span>);
<span class="hljs-comment">// false</span>
</code></pre>
<h2>局限性</h2>
<p>尽管 JavaScript 中的正则表达式功能比较完备，但与其他语言相比，缺少某些特性</p>
<p>下面列出了 JavaScript 正则表达式不支持的特性</p>
<ul>
<li>POSIX 字符组（只支持普通字符组和排除型字符组）</li>
<li>Unicode 支持（只支持单个 Unicode 字符）</li>
<li>匹配字符串开始和结尾的 <code>\A</code> 和 <code>\Z</code> 锚（只支持 <code>^</code> 和 <code>$</code>）</li>
<li>逆序环视（只支持顺序环视）</li>
<li>命名分组（只支持 0-9 编号的捕获组）</li>
<li>单行模式和注释模式（只支持 <code>m</code> 、<code>i</code>、<code>g</code>）</li>
<li>模式作用范围</li>
<li>纯文本模式</li>
</ul>
<h2>参考资料</h2>
<ul>
<li><a href="https://tool.oschina.net/uploads/apidocs/jquery/regexp.html" target="_blank" rel="noopener noreferrer nofollow">正则表达式手册</a></li>
<li><a href="https://regexr.com/" target="_blank" rel="noopener noreferrer nofollow">RegExr 正则表达式练习网站</a></li>
<li><a href="https://regexone.com/" target="_blank" rel="noopener noreferrer nofollow">RegexOne</a></li>
</ul>
4:["$","div",null,{"className":"markdown-body","children":["$","article",null,{"dangerouslySetInnerHTML":{"__html":"$c"}}]}]
a:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
8:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"front-end"}],["$","meta","2",{"name":"description","content":"front-end knowledge"}],["$","link","3",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
6:null
