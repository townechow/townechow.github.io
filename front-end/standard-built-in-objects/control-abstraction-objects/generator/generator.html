<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/ec0a9d078e716e00.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/485ff6fe79292a08.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/0ff121a467c0636f.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-53834dba86d90934.js"/><script src="/_next/static/chunks/4bd1b696-20882bf820444624.js" async=""></script><script src="/_next/static/chunks/517-98ed787e5f259f2c.js" async=""></script><script src="/_next/static/chunks/main-app-f33d3e3aed85e21f.js" async=""></script><meta name="next-size-adjust" content=""/><title>front-end</title><meta name="description" content="front-end knowledge"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><main><div class="markdown-body"><article><h1>Generator</h1>
<p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p>
<blockquote>
<p>本篇着重介绍 语法及 API，异步编程应用参考 <a href="/front-end/standard-built-in-objects/control-abstraction-objects/generator/generator-async">Generator 函数的异步应用</a></p>
</blockquote>
<h2>状态机</h2>
<p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p>
<p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个 <a href="/front-end/standard-built-in-objects/control-abstraction-objects/iterator-objects/iterator">遍历器对象</a> 生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
<h3>函数特征</h3>
<p>形式上，Generator 函数是一个普通函数，但是有两个特征</p>
<ul>
<li><code>function</code> 关键字与函数名之间有一个星号（<code>*</code>）</li>
<li>函数体内部使用 <code>yield</code>（中文 <code>生产/产出</code> 的意思）表单式，定义不同的内部状态</li>
</ul>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">helloWorldGenerator</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Hello&#x27;</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;World&#x27;</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Ending&#x27;</span>;
}

<span class="hljs-keyword">const</span> hw = <span class="hljs-title function_">helloWorldGenerator</span>();
</code></pre>
<p>代码定义了一个 Generator 函数 <code>helloWorldGenerator</code>，它内部有两个 <code>yield</code> 表达式（<code>hello</code> 和 <code>world</code>），即该函数有三个状态：<code>hello</code>、<code>world</code> 和 <code>return</code> 语句（结束执行）。</p>
<h3>调用方法</h3>
<p>Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并<strong>不执行</strong>，返回的也不是函数运行结果，而是一个<strong>指向内部状态的指针对象</strong>，也就是 <a href="/front-end/standard-built-in-objects/control-abstraction-objects/iterator-objects/iterator">遍历器对象</a>（Iterator Object）。</p>
<p>下一步，必须调用遍历器对象的 <code>next</code> 方法，使得指针移向下一个状态。也就是说，每次调用 <code>next</code> 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 <code>yield</code> 表达式（或 <code>return</code> 语句）为止。换言之，Generator 函数是分段执行的，<code>yield</code> 表达式是暂停执行的标记，而 <code>next</code> 方法可以恢复执行。</p>
<pre class="hljs"><code class="language-js">hw.<span class="hljs-title function_">next</span>();
<span class="hljs-comment">// { value: &#x27;Hello&#x27;, done: false }</span>

hw.<span class="hljs-title function_">next</span>();
<span class="hljs-comment">// { value: &#x27;World&#x27;, done: false }</span>

hw.<span class="hljs-title function_">next</span>();
<span class="hljs-comment">// { value: &#x27;Ending&#x27;, done: true }</span>

hw.<span class="hljs-title function_">next</span>();
<span class="hljs-comment">// { value: undefined, done: true }</span>
</code></pre>
<p>上面代码一共调用了四次<code>next</code>方法。</p>
<p>第一次调用，Generator 函数开始执行，直到遇到第一个 <code>yield</code> 表达式为止。<code>next</code> 方法返回一个对象，它的<code>value</code> 属性就是当前 <code>yield</code> 表达式的值 <code>Hello</code>，<code>done</code> 属性的值 <code>false</code>，表示遍历还没有结束。</p>
<p>第二次调用，Generator 函数从上次 <code>yield</code> 表达式停下的地方，一直执行到下一个 <code>yield</code> 表达式。<code>next</code> 方法返回的对象的 <code>value</code> 属性就是当前 <code>yield</code> 表达式的值 <code>World</code>，<code>done</code> 属性的值 <code>false</code>，表示遍历还没有结束。</p>
<p>第三次调用，Generator 函数从上次 <code>yield</code> 表达式停下的地方，一直执行到 <code>return</code> 语句（如果没有 <code>return</code> 语句，就执行到函数结束）。<code>next</code> 方法返回的对象的 <code>value</code> 属性，就是紧跟在 <code>return</code> 语句后面的表达式的值（如果没有 <code>return</code> 语句，则 <code>value</code> 属性的值为 <code>undefined</code>），<code>done</code> 属性的值 <code>true</code>，表示遍历已经结束。</p>
<p>第四次调用，此时 Generator 函数已经运行完毕，<code>next</code> 方法返回对象的 <code>value</code> 属性为 <code>undefined</code>，<code>done</code> 属性为 <code>true</code>。以后再调用 <code>next</code> 方法，返回的都是这个值。</p>
<p>总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 <code>next</code> 方法，就会返回一个有着 <code>value</code> 和 <code>done</code> 两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是 <code>yield</code> 表达式后面那个表达式的值；<code>done</code> 属性是一个布尔值，表示是否遍历结束。</p>
<h2>yield 表达式</h2>
<p>由于 Generator 函数返回的遍历器对象，只有调用 <code>next</code> 方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。<code>yield</code> 表达式就是暂停标志。</p>
<p>遍历器对象的 <code>next</code> 方法的运行逻辑如下。</p>
<ol>
<li>
<p>遇到 <code>yield</code> 表达式，就暂停执行后面的操作，并将紧跟在 <code>yield</code> 后面的那个表达式的值，作为返回的对象的 <code>value</code> 属性值。</p>
</li>
<li>
<p>下一次调用 <code>next</code> 方法时，再继续往下执行，直到遇到下一个 <code>yield</code> 表达式。</p>
</li>
<li>
<p>如果没有再遇到新的 <code>yield</code> 表达式，就一直运行到函数结束，直到 <code>return</code> 语句为止，并将 <code>return</code> 语句后面的表达式的值，作为返回的对象的 <code>value</code> 属性值。</p>
</li>
<li>
<p>如果该函数没有 <code>return</code> 语句，则返回的对象的 <code>value</code> 属性值为 <code>undefined</code>。</p>
</li>
</ol>
<p>需要注意的是，<code>yield</code> 表达式后面的表达式，只有当调用 <code>next</code> 方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“<strong>惰性求值</strong>”（Lazy Evaluation）的语法功能。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">gen</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">yield</span> <span class="hljs-number">123</span> + <span class="hljs-number">456</span>;
}
</code></pre>
<p>上面代码中，<code>yield</code> 后面的表达式 <code>123 + 456</code>，不会立即求值，只会在<code>next</code>方法将指针移到这一句时，才会求值。</p>
<h3>yield 与 return</h3>
<p><code>yield</code> 表达式与 <code>return</code> 语句既有相似之处，也有区别。</p>
<ul>
<li>
<p>相似</p>
<ul>
<li>两种语句表达式都能返回紧跟在语句后面的那个表达式的值。</li>
</ul>
</li>
<li>
<p>区别</p>
<ul>
<li><strong>记忆功能</strong>：每次遇到 <code>yield</code>，函数暂停执行，下一次再从该位置继续向后执行，而 <code>return</code> 语句不具备位置记忆的功能。</li>
<li><strong>执行次数</strong>：一个函数里面，只能执行一次（或者说一个）<code>return</code> 语句，但是可以执行多次（或者说多个）<code>yield</code> 表达式。</li>
<li><strong>返回次数</strong>：正常函数只能返回一个值，因为只能执行一次 <code>return</code> ；Generator 函数可以返回一系列的值，因为可以有任意多个<code>yield</code>。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历。</li>
</ul>
</li>
</ul>
<h3>暂缓执行函数</h3>
<p>Generator 函数可以不用 <code>yield</code> 表达式，这时就变成了一个单纯的<strong>暂缓执行函数</strong>。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行了！&#x27;</span>);
}

<span class="hljs-keyword">var</span> generator = <span class="hljs-title function_">fn</span>();

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  generator.<span class="hljs-title function_">next</span>();
}, <span class="hljs-number">2000</span>);
</code></pre>
<p>上面代码中，函数 <code>fn</code> 如果是普通函数，在为变量 <code>generator</code> 赋值时就会执行。但是，函数 <code>fn</code> 是一个 Generator 函数，就变成只有调用 <code>next</code> 方法时，函数 <code>fn</code> 才会执行。</p>
<h3>表达式规范</h3>
<p>另外需要注意，<strong><code>yield</code>表达式只能用在 Generator 函数里面</strong>，用在其他地方都会报错。</p>
<pre class="hljs"><code class="language-js">(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>){
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
})()
<span class="hljs-comment">// SyntaxError: Unexpected number</span>
</code></pre>
<p>上面代码在一个普通函数中使用 <code>yield</code> 表达式，结果产生一个句法错误。</p>
<h3>嵌套表达式</h3>
<p><code>yield</code> 表达式如果用在另一个表达式之中，必须放在<strong>圆括号</strong>里面。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello&#x27;</span> + <span class="hljs-keyword">yield</span>); <span class="hljs-comment">// SyntaxError</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello&#x27;</span> + <span class="hljs-keyword">yield</span> <span class="hljs-number">123</span>); <span class="hljs-comment">// SyntaxError</span>

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello&#x27;</span> + (<span class="hljs-keyword">yield</span>)); <span class="hljs-comment">// OK</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello&#x27;</span> + (<span class="hljs-keyword">yield</span> <span class="hljs-number">123</span>)); <span class="hljs-comment">// OK</span>
}
</code></pre>
<p><code>yield</code> 表达式用作<strong>函数参数</strong>或放在<strong>赋值表达式</strong>的右边，可以不加括号。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">foo</span>(<span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;b&#x27;</span>); <span class="hljs-comment">// OK</span>
  <span class="hljs-keyword">let</span> input = <span class="hljs-keyword">yield</span>; <span class="hljs-comment">// OK</span>
}
</code></pre>
<h2>原型方法</h2>
<ul>
<li><a href="/front-end/standard-built-in-objects/control-abstraction-objects/generator/properties-of-the-promise-prototype-object/next">Generator.prototype.next</a></li>
<li><a href="/front-end/standard-built-in-objects/control-abstraction-objects/generator/properties-of-the-promise-prototype-object/return">Generator.prototype.return</a></li>
<li><a href="/front-end/standard-built-in-objects/control-abstraction-objects/generator/properties-of-the-promise-prototype-object/throw">Generator.prototype.throw</a></li>
</ul>
<p><strong>原型方法共同点</strong></p>
<p>三者的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换 <code>yield</code> 表达式。</p>
<p><code>next()</code> 是将 <code>yield</code> 表达式替换成一个值。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> generator = <span class="hljs-keyword">function</span>*(x, y) {
  <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">yield</span> x + y;
  <span class="hljs-keyword">return</span> result;
};

<span class="hljs-keyword">const</span> gen = <span class="hljs-title function_">generator</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);

gen.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// Object {value: 3, done: false}</span>

gen.<span class="hljs-title function_">next</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// Object {value: 1, done: true}</span>

<span class="hljs-comment">// 相当于将 let result = yield x + y</span>
<span class="hljs-comment">// 替换成 let result = 1;</span>
</code></pre>
<p>上面代码中，第二个 <code>next(1)</code> 方法就相当于将 <code>yield</code> 表达式替换成一个值 <code>1</code>。如果 <code>next</code> 方法没有参数，就相当于替换成 <code>undefined</code>。</p>
<p><code>throw()</code> 是将 <code>yield</code> 表达式替换成一个 <code>throw</code> 语句。</p>
<pre class="hljs"><code class="language-js">gen.<span class="hljs-keyword">throw</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;出错了&#x27;</span>)); <span class="hljs-comment">// Uncaught Error: 出错了</span>

<span class="hljs-comment">// 相当于将 let result = yield x + y</span>
<span class="hljs-comment">// 替换成 let result = throw(new Error(&#x27;出错了&#x27;));</span>
</code></pre>
<p><code>return()</code> 是将 <code>yield</code> 表达式替换成一个 <code>return</code> 语句。</p>
<pre class="hljs"><code class="language-js">gen.<span class="hljs-keyword">return</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// Object {value: 2, done: true}</span>

<span class="hljs-comment">// 相当于将 let result = yield x + y</span>
<span class="hljs-comment">// 替换成 let result = return 2;</span>
</code></pre>
<h2>作为对象的函数</h2>
<p>如果一个对象的属性是 Generator 函数，可以简写成下面的形式。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">let</span> obj = {
  *<span class="hljs-title function_">generator</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// ···</span>
  },
};
</code></pre>
<p>上面代码中，<code>generator</code> 属性前面有一个星号，表示这个属性是一个 Generator 函数。</p>
<p>它的完整形式如下，与上面的写法是等价的。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">let</span> obj = {
  <span class="hljs-attr">myGeneratorMethod</span>: <span class="hljs-keyword">function</span>*() {
    <span class="hljs-comment">// ···</span>
  },
};
</code></pre>
<h2>判断方法</h2>
<p><strong>生成器对象的判断方法</strong></p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isGenerator</span>(<span class="hljs-params">obj</span>) {
  <span class="hljs-keyword">return</span> obj &amp;&amp; <span class="hljs-keyword">typeof</span> obj.<span class="hljs-property">next</span> === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> obj.<span class="hljs-property">throw</span> === <span class="hljs-string">&#x27;function&#x27;</span>;
}
</code></pre>
<p><strong>生成器函数的判断方法</strong></p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isGeneratorFunction</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> constructor = obj.<span class="hljs-property">constructor</span>;
  <span class="hljs-keyword">if</span> (!constructor) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;GeratorFunction&#x27;</span> === constructor.<span class="hljs-property">name</span> || <span class="hljs-string">&#x27;GeneratorFunction&#x27;</span> === constructor.<span class="hljs-property">displayName</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">isGenerator</span>(constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
}
</code></pre>
<p>利用函数的 <code>constructor</code> 构造器的名字来判断，为了兼容性使用 <code>name</code> 与 <code>displayName</code> 两个属性来进行判断. 这里递归调用 <code>isGenerator</code> 判断 <code>constructor</code> 的原型是因为有自定义迭代器的存在。</p>
<hr>
<p><strong>参考书籍：</strong></p>
<ul>
<li><a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener noreferrer nofollow">《ECMAScript 6 入门》阮一峰著</a></li>
</ul>
</article></div></main><script src="/_next/static/chunks/webpack-53834dba86d90934.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5244,[],\"\"]\n3:I[3866,[],\"\"]\n5:I[6213,[],\"OutletBoundary\"]\n7:I[6213,[],\"MetadataBoundary\"]\n9:I[6213,[],\"ViewportBoundary\"]\nb:I[4835,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/ec0a9d078e716e00.css\",\"style\"]\n:HL[\"/_next/static/css/485ff6fe79292a08.css\",\"style\"]\n:HL[\"/_next/static/css/0ff121a467c0636f.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"NW9bMA21iAaih0TqCHqj1\",\"p\":\"\",\"c\":[\"\",\"front-end\",\"standard-built-in-objects\",\"control-abstraction-objects\",\"generator\",\"generator\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"front-end\",{\"children\":[[\"slug\",\"standard-built-in-objects/control-abstraction-objects/generator/generator\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/ec0a9d078e716e00.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"front-end\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/485ff6fe79292a08.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0ff121a467c0636f.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"main\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[[\"slug\",\"standard-built-in-objects/control-abstraction-objects/generator/generator\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"x17-9sNEp-2LQlwJdwFsy\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:T4876,"])</script><script>self.__next_f.push([1,"\u003ch1\u003eGenerator\u003c/h1\u003e\n\u003cp\u003eGenerator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e本篇着重介绍 语法及 API，异步编程应用参考 \u003ca href=\"/front-end/standard-built-in-objects/control-abstraction-objects/generator/generator-async\"\u003eGenerator 函数的异步应用\u003c/a\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e状态机\u003c/h2\u003e\n\u003cp\u003eGenerator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。\u003c/p\u003e\n\u003cp\u003e执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个 \u003ca href=\"/front-end/standard-built-in-objects/control-abstraction-objects/iterator-objects/iterator\"\u003e遍历器对象\u003c/a\u003e 生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。\u003c/p\u003e\n\u003ch3\u003e函数特征\u003c/h3\u003e\n\u003cp\u003e形式上，Generator 函数是一个普通函数，但是有两个特征\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003efunction\u003c/code\u003e 关键字与函数名之间有一个星号（\u003ccode\u003e*\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e函数体内部使用 \u003ccode\u003eyield\u003c/code\u003e（中文 \u003ccode\u003e生产/产出\u003c/code\u003e 的意思）表单式，定义不同的内部状态\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e* \u003cspan class=\"hljs-title function_\"\u003ehelloWorldGenerator\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eyield\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;Hello\u0026#x27;\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003eyield\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;World\u0026#x27;\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;Ending\u0026#x27;\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e hw = \u003cspan class=\"hljs-title function_\"\u003ehelloWorldGenerator\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e代码定义了一个 Generator 函数 \u003ccode\u003ehelloWorldGenerator\u003c/code\u003e，它内部有两个 \u003ccode\u003eyield\u003c/code\u003e 表达式（\u003ccode\u003ehello\u003c/code\u003e 和 \u003ccode\u003eworld\u003c/code\u003e），即该函数有三个状态：\u003ccode\u003ehello\u003c/code\u003e、\u003ccode\u003eworld\u003c/code\u003e 和 \u003ccode\u003ereturn\u003c/code\u003e 语句（结束执行）。\u003c/p\u003e\n\u003ch3\u003e调用方法\u003c/h3\u003e\n\u003cp\u003eGenerator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并\u003cstrong\u003e不执行\u003c/strong\u003e，返回的也不是函数运行结果，而是一个\u003cstrong\u003e指向内部状态的指针对象\u003c/strong\u003e，也就是 \u003ca href=\"/front-end/standard-built-in-objects/control-abstraction-objects/iterator-objects/iterator\"\u003e遍历器对象\u003c/a\u003e（Iterator Object）。\u003c/p\u003e\n\u003cp\u003e下一步，必须调用遍历器对象的 \u003ccode\u003enext\u003c/code\u003e 方法，使得指针移向下一个状态。也就是说，每次调用 \u003ccode\u003enext\u003c/code\u003e 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 \u003ccode\u003eyield\u003c/code\u003e 表达式（或 \u003ccode\u003ereturn\u003c/code\u003e 语句）为止。换言之，Generator 函数是分段执行的，\u003ccode\u003eyield\u003c/code\u003e 表达式是暂停执行的标记，而 \u003ccode\u003enext\u003c/code\u003e 方法可以恢复执行。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003ehw.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// { value: \u0026#x27;Hello\u0026#x27;, done: false }\u003c/span\u003e\n\nhw.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// { value: \u0026#x27;World\u0026#x27;, done: false }\u003c/span\u003e\n\nhw.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// { value: \u0026#x27;Ending\u0026#x27;, done: true }\u003c/span\u003e\n\nhw.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// { value: undefined, done: true }\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面代码一共调用了四次\u003ccode\u003enext\u003c/code\u003e方法。\u003c/p\u003e\n\u003cp\u003e第一次调用，Generator 函数开始执行，直到遇到第一个 \u003ccode\u003eyield\u003c/code\u003e 表达式为止。\u003ccode\u003enext\u003c/code\u003e 方法返回一个对象，它的\u003ccode\u003evalue\u003c/code\u003e 属性就是当前 \u003ccode\u003eyield\u003c/code\u003e 表达式的值 \u003ccode\u003eHello\u003c/code\u003e，\u003ccode\u003edone\u003c/code\u003e 属性的值 \u003ccode\u003efalse\u003c/code\u003e，表示遍历还没有结束。\u003c/p\u003e\n\u003cp\u003e第二次调用，Generator 函数从上次 \u003ccode\u003eyield\u003c/code\u003e 表达式停下的地方，一直执行到下一个 \u003ccode\u003eyield\u003c/code\u003e 表达式。\u003ccode\u003enext\u003c/code\u003e 方法返回的对象的 \u003ccode\u003evalue\u003c/code\u003e 属性就是当前 \u003ccode\u003eyield\u003c/code\u003e 表达式的值 \u003ccode\u003eWorld\u003c/code\u003e，\u003ccode\u003edone\u003c/code\u003e 属性的值 \u003ccode\u003efalse\u003c/code\u003e，表示遍历还没有结束。\u003c/p\u003e\n\u003cp\u003e第三次调用，Generator 函数从上次 \u003ccode\u003eyield\u003c/code\u003e 表达式停下的地方，一直执行到 \u003ccode\u003ereturn\u003c/code\u003e 语句（如果没有 \u003ccode\u003ereturn\u003c/code\u003e 语句，就执行到函数结束）。\u003ccode\u003enext\u003c/code\u003e 方法返回的对象的 \u003ccode\u003evalue\u003c/code\u003e 属性，就是紧跟在 \u003ccode\u003ereturn\u003c/code\u003e 语句后面的表达式的值（如果没有 \u003ccode\u003ereturn\u003c/code\u003e 语句，则 \u003ccode\u003evalue\u003c/code\u003e 属性的值为 \u003ccode\u003eundefined\u003c/code\u003e），\u003ccode\u003edone\u003c/code\u003e 属性的值 \u003ccode\u003etrue\u003c/code\u003e，表示遍历已经结束。\u003c/p\u003e\n\u003cp\u003e第四次调用，此时 Generator 函数已经运行完毕，\u003ccode\u003enext\u003c/code\u003e 方法返回对象的 \u003ccode\u003evalue\u003c/code\u003e 属性为 \u003ccode\u003eundefined\u003c/code\u003e，\u003ccode\u003edone\u003c/code\u003e 属性为 \u003ccode\u003etrue\u003c/code\u003e。以后再调用 \u003ccode\u003enext\u003c/code\u003e 方法，返回的都是这个值。\u003c/p\u003e\n\u003cp\u003e总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 \u003ccode\u003enext\u003c/code\u003e 方法，就会返回一个有着 \u003ccode\u003evalue\u003c/code\u003e 和 \u003ccode\u003edone\u003c/code\u003e 两个属性的对象。\u003ccode\u003evalue\u003c/code\u003e属性表示当前的内部状态的值，是 \u003ccode\u003eyield\u003c/code\u003e 表达式后面那个表达式的值；\u003ccode\u003edone\u003c/code\u003e 属性是一个布尔值，表示是否遍历结束。\u003c/p\u003e\n\u003ch2\u003eyield 表达式\u003c/h2\u003e\n\u003cp\u003e由于 Generator 函数返回的遍历器对象，只有调用 \u003ccode\u003enext\u003c/code\u003e 方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。\u003ccode\u003eyield\u003c/code\u003e 表达式就是暂停标志。\u003c/p\u003e\n\u003cp\u003e遍历器对象的 \u003ccode\u003enext\u003c/code\u003e 方法的运行逻辑如下。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e\n\u003cp\u003e遇到 \u003ccode\u003eyield\u003c/code\u003e 表达式，就暂停执行后面的操作，并将紧跟在 \u003ccode\u003eyield\u003c/code\u003e 后面的那个表达式的值，作为返回的对象的 \u003ccode\u003evalue\u003c/code\u003e 属性值。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e下一次调用 \u003ccode\u003enext\u003c/code\u003e 方法时，再继续往下执行，直到遇到下一个 \u003ccode\u003eyield\u003c/code\u003e 表达式。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e如果没有再遇到新的 \u003ccode\u003eyield\u003c/code\u003e 表达式，就一直运行到函数结束，直到 \u003ccode\u003ereturn\u003c/code\u003e 语句为止，并将 \u003ccode\u003ereturn\u003c/code\u003e 语句后面的表达式的值，作为返回的对象的 \u003ccode\u003evalue\u003c/code\u003e 属性值。\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e如果该函数没有 \u003ccode\u003ereturn\u003c/code\u003e 语句，则返回的对象的 \u003ccode\u003evalue\u003c/code\u003e 属性值为 \u003ccode\u003eundefined\u003c/code\u003e。\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e需要注意的是，\u003ccode\u003eyield\u003c/code\u003e 表达式后面的表达式，只有当调用 \u003ccode\u003enext\u003c/code\u003e 方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“\u003cstrong\u003e惰性求值\u003c/strong\u003e”（Lazy Evaluation）的语法功能。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e* \u003cspan class=\"hljs-title function_\"\u003egen\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eyield\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e123\u003c/span\u003e + \u003cspan class=\"hljs-number\"\u003e456\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面代码中，\u003ccode\u003eyield\u003c/code\u003e 后面的表达式 \u003ccode\u003e123 + 456\u003c/code\u003e，不会立即求值，只会在\u003ccode\u003enext\u003c/code\u003e方法将指针移到这一句时，才会求值。\u003c/p\u003e\n\u003ch3\u003eyield 与 return\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eyield\u003c/code\u003e 表达式与 \u003ccode\u003ereturn\u003c/code\u003e 语句既有相似之处，也有区别。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e相似\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e两种语句表达式都能返回紧跟在语句后面的那个表达式的值。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e区别\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e记忆功能\u003c/strong\u003e：每次遇到 \u003ccode\u003eyield\u003c/code\u003e，函数暂停执行，下一次再从该位置继续向后执行，而 \u003ccode\u003ereturn\u003c/code\u003e 语句不具备位置记忆的功能。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e执行次数\u003c/strong\u003e：一个函数里面，只能执行一次（或者说一个）\u003ccode\u003ereturn\u003c/code\u003e 语句，但是可以执行多次（或者说多个）\u003ccode\u003eyield\u003c/code\u003e 表达式。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e返回次数\u003c/strong\u003e：正常函数只能返回一个值，因为只能执行一次 \u003ccode\u003ereturn\u003c/code\u003e ；Generator 函数可以返回一系列的值，因为可以有任意多个\u003ccode\u003eyield\u003c/code\u003e。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e暂缓执行函数\u003c/h3\u003e\n\u003cp\u003eGenerator 函数可以不用 \u003ccode\u003eyield\u003c/code\u003e 表达式，这时就变成了一个单纯的\u003cstrong\u003e暂缓执行函数\u003c/strong\u003e。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e* \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;执行了！\u0026#x27;\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e generator = \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e();\n\n\u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  generator.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e();\n}, \u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面代码中，函数 \u003ccode\u003efn\u003c/code\u003e 如果是普通函数，在为变量 \u003ccode\u003egenerator\u003c/code\u003e 赋值时就会执行。但是，函数 \u003ccode\u003efn\u003c/code\u003e 是一个 Generator 函数，就变成只有调用 \u003ccode\u003enext\u003c/code\u003e 方法时，函数 \u003ccode\u003efn\u003c/code\u003e 才会执行。\u003c/p\u003e\n\u003ch3\u003e表达式规范\u003c/h3\u003e\n\u003cp\u003e另外需要注意，\u003cstrong\u003e\u003ccode\u003eyield\u003c/code\u003e表达式只能用在 Generator 函数里面\u003c/strong\u003e，用在其他地方都会报错。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e){\n  \u003cspan class=\"hljs-keyword\"\u003eyield\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n})()\n\u003cspan class=\"hljs-comment\"\u003e// SyntaxError: Unexpected number\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面代码在一个普通函数中使用 \u003ccode\u003eyield\u003c/code\u003e 表达式，结果产生一个句法错误。\u003c/p\u003e\n\u003ch3\u003e嵌套表达式\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eyield\u003c/code\u003e 表达式如果用在另一个表达式之中，必须放在\u003cstrong\u003e圆括号\u003c/strong\u003e里面。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e* \u003cspan class=\"hljs-title function_\"\u003edemo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Hello\u0026#x27;\u003c/span\u003e + \u003cspan class=\"hljs-keyword\"\u003eyield\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// SyntaxError\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Hello\u0026#x27;\u003c/span\u003e + \u003cspan class=\"hljs-keyword\"\u003eyield\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e123\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// SyntaxError\u003c/span\u003e\n\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Hello\u0026#x27;\u003c/span\u003e + (\u003cspan class=\"hljs-keyword\"\u003eyield\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// OK\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Hello\u0026#x27;\u003c/span\u003e + (\u003cspan class=\"hljs-keyword\"\u003eyield\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e123\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// OK\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003eyield\u003c/code\u003e 表达式用作\u003cstrong\u003e函数参数\u003c/strong\u003e或放在\u003cstrong\u003e赋值表达式\u003c/strong\u003e的右边，可以不加括号。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e* \u003cspan class=\"hljs-title function_\"\u003edemo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eyield\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;a\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003eyield\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;b\u0026#x27;\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// OK\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e input = \u003cspan class=\"hljs-keyword\"\u003eyield\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// OK\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e原型方法\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/front-end/standard-built-in-objects/control-abstraction-objects/generator/properties-of-the-promise-prototype-object/next\"\u003eGenerator.prototype.next\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/front-end/standard-built-in-objects/control-abstraction-objects/generator/properties-of-the-promise-prototype-object/return\"\u003eGenerator.prototype.return\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/front-end/standard-built-in-objects/control-abstraction-objects/generator/properties-of-the-promise-prototype-object/throw\"\u003eGenerator.prototype.throw\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e原型方法共同点\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e三者的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换 \u003ccode\u003eyield\u003c/code\u003e 表达式。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003enext()\u003c/code\u003e 是将 \u003ccode\u003eyield\u003c/code\u003e 表达式替换成一个值。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e generator = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e*(x, y) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e result = \u003cspan class=\"hljs-keyword\"\u003eyield\u003c/span\u003e x + y;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result;\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e gen = \u003cspan class=\"hljs-title function_\"\u003egenerator\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n\ngen.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// Object {value: 3, done: false}\u003c/span\u003e\n\ngen.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// Object {value: 1, done: true}\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 相当于将 let result = yield x + y\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 替换成 let result = 1;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面代码中，第二个 \u003ccode\u003enext(1)\u003c/code\u003e 方法就相当于将 \u003ccode\u003eyield\u003c/code\u003e 表达式替换成一个值 \u003ccode\u003e1\u003c/code\u003e。如果 \u003ccode\u003enext\u003c/code\u003e 方法没有参数，就相当于替换成 \u003ccode\u003eundefined\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ethrow()\u003c/code\u003e 是将 \u003ccode\u003eyield\u003c/code\u003e 表达式替换成一个 \u003ccode\u003ethrow\u003c/code\u003e 语句。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003egen.\u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;出错了\u0026#x27;\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// Uncaught Error: 出错了\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 相当于将 let result = yield x + y\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 替换成 let result = throw(new Error(\u0026#x27;出错了\u0026#x27;));\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ereturn()\u003c/code\u003e 是将 \u003ccode\u003eyield\u003c/code\u003e 表达式替换成一个 \u003ccode\u003ereturn\u003c/code\u003e 语句。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003egen.\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// Object {value: 2, done: true}\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 相当于将 let result = yield x + y\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 替换成 let result = return 2;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e作为对象的函数\u003c/h2\u003e\n\u003cp\u003e如果一个对象的属性是 Generator 函数，可以简写成下面的形式。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e obj = {\n  *\u003cspan class=\"hljs-title function_\"\u003egenerator\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// ···\u003c/span\u003e\n  },\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面代码中，\u003ccode\u003egenerator\u003c/code\u003e 属性前面有一个星号，表示这个属性是一个 Generator 函数。\u003c/p\u003e\n\u003cp\u003e它的完整形式如下，与上面的写法是等价的。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e obj = {\n  \u003cspan class=\"hljs-attr\"\u003emyGeneratorMethod\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e*() {\n    \u003cspan class=\"hljs-comment\"\u003e// ···\u003c/span\u003e\n  },\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e判断方法\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e生成器对象的判断方法\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisGenerator\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eobj\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e obj \u0026amp;\u0026amp; \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e obj.\u003cspan class=\"hljs-property\"\u003enext\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e\u0026#x27;function\u0026#x27;\u003c/span\u003e \u0026amp;\u0026amp; \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e obj.\u003cspan class=\"hljs-property\"\u003ethrow\u003c/span\u003e === \u003cspan class=\"hljs-string\"\u003e\u0026#x27;function\u0026#x27;\u003c/span\u003e;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e生成器函数的判断方法\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisGeneratorFunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e constructor = obj.\u003cspan class=\"hljs-property\"\u003econstructor\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!constructor) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-string\"\u003e\u0026#x27;GeratorFunction\u0026#x27;\u003c/span\u003e === constructor.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e || \u003cspan class=\"hljs-string\"\u003e\u0026#x27;GeneratorFunction\u0026#x27;\u003c/span\u003e === constructor.\u003cspan class=\"hljs-property\"\u003edisplayName\u003c/span\u003e)\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eisGenerator\u003c/span\u003e(constructor.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e利用函数的 \u003ccode\u003econstructor\u003c/code\u003e 构造器的名字来判断，为了兼容性使用 \u003ccode\u003ename\u003c/code\u003e 与 \u003ccode\u003edisplayName\u003c/code\u003e 两个属性来进行判断. 这里递归调用 \u003ccode\u003eisGenerator\u003c/code\u003e 判断 \u003ccode\u003econstructor\u003c/code\u003e 的原型是因为有自定义迭代器的存在。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e参考书籍：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://es6.ruanyifeng.com/#docs/generator\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e《ECMAScript 6 入门》阮一峰著\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"markdown-body\",\"children\":[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"front-end\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"front-end knowledge\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>