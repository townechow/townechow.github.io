1:"$Sreact.fragment"
2:I[5244,[],""]
3:I[3866,[],""]
5:I[6213,[],"OutletBoundary"]
7:I[6213,[],"MetadataBoundary"]
9:I[6213,[],"ViewportBoundary"]
b:I[4835,[],""]
:HL["/_next/static/media/569ce4b8f30dc480-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/ec0a9d078e716e00.css","style"]
:HL["/_next/static/css/485ff6fe79292a08.css","style"]
:HL["/_next/static/css/0ff121a467c0636f.css","style"]
0:{"P":null,"b":"ToCgoFiTXvECVEVLCeZww","p":"","c":["","front-end","standard-built-in-objects","control-abstraction-objects","generator","generator"],"i":false,"f":[[["",{"children":["front-end",{"children":[["slug","standard-built-in-objects/control-abstraction-objects/generator/generator","oc"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/ec0a9d078e716e00.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__variable_4d318d __variable_ea5f4b antialiased","children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[],[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]]}],{"children":["front-end",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/485ff6fe79292a08.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/0ff121a467c0636f.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","main",null,{"children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","front-end","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]}]]}],{"children":[["slug","standard-built-in-objects/control-abstraction-objects/generator/generator","oc"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","front-end","children","$0:f:0:1:2:children:2:children:0","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L4",null,["$","$L5",null,{"children":"$L6"}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","Xf5PTDHsrNbbQXZF_z_C9",{"children":[["$","$L7",null,{"children":"$L8"}],["$","$L9",null,{"children":"$La"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}]]}],false]],"m":"$undefined","G":["$b","$undefined"],"s":false,"S":true}
c:T4876,<h1>Generator</h1>
<p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p>
<blockquote>
<p>本篇着重介绍 语法及 API，异步编程应用参考 <a href="/front-end/standard-built-in-objects/control-abstraction-objects/generator/generator-async">Generator 函数的异步应用</a></p>
</blockquote>
<h2>状态机</h2>
<p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p>
<p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个 <a href="/front-end/standard-built-in-objects/control-abstraction-objects/iterator-objects/iterator">遍历器对象</a> 生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
<h3>函数特征</h3>
<p>形式上，Generator 函数是一个普通函数，但是有两个特征</p>
<ul>
<li><code>function</code> 关键字与函数名之间有一个星号（<code>*</code>）</li>
<li>函数体内部使用 <code>yield</code>（中文 <code>生产/产出</code> 的意思）表单式，定义不同的内部状态</li>
</ul>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">helloWorldGenerator</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;Hello&#x27;</span>;
  <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;World&#x27;</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Ending&#x27;</span>;
}

<span class="hljs-keyword">const</span> hw = <span class="hljs-title function_">helloWorldGenerator</span>();
</code></pre>
<p>代码定义了一个 Generator 函数 <code>helloWorldGenerator</code>，它内部有两个 <code>yield</code> 表达式（<code>hello</code> 和 <code>world</code>），即该函数有三个状态：<code>hello</code>、<code>world</code> 和 <code>return</code> 语句（结束执行）。</p>
<h3>调用方法</h3>
<p>Generator 函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用 Generator 函数后，该函数并<strong>不执行</strong>，返回的也不是函数运行结果，而是一个<strong>指向内部状态的指针对象</strong>，也就是 <a href="/front-end/standard-built-in-objects/control-abstraction-objects/iterator-objects/iterator">遍历器对象</a>（Iterator Object）。</p>
<p>下一步，必须调用遍历器对象的 <code>next</code> 方法，使得指针移向下一个状态。也就是说，每次调用 <code>next</code> 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个 <code>yield</code> 表达式（或 <code>return</code> 语句）为止。换言之，Generator 函数是分段执行的，<code>yield</code> 表达式是暂停执行的标记，而 <code>next</code> 方法可以恢复执行。</p>
<pre class="hljs"><code class="language-js">hw.<span class="hljs-title function_">next</span>();
<span class="hljs-comment">// { value: &#x27;Hello&#x27;, done: false }</span>

hw.<span class="hljs-title function_">next</span>();
<span class="hljs-comment">// { value: &#x27;World&#x27;, done: false }</span>

hw.<span class="hljs-title function_">next</span>();
<span class="hljs-comment">// { value: &#x27;Ending&#x27;, done: true }</span>

hw.<span class="hljs-title function_">next</span>();
<span class="hljs-comment">// { value: undefined, done: true }</span>
</code></pre>
<p>上面代码一共调用了四次<code>next</code>方法。</p>
<p>第一次调用，Generator 函数开始执行，直到遇到第一个 <code>yield</code> 表达式为止。<code>next</code> 方法返回一个对象，它的<code>value</code> 属性就是当前 <code>yield</code> 表达式的值 <code>Hello</code>，<code>done</code> 属性的值 <code>false</code>，表示遍历还没有结束。</p>
<p>第二次调用，Generator 函数从上次 <code>yield</code> 表达式停下的地方，一直执行到下一个 <code>yield</code> 表达式。<code>next</code> 方法返回的对象的 <code>value</code> 属性就是当前 <code>yield</code> 表达式的值 <code>World</code>，<code>done</code> 属性的值 <code>false</code>，表示遍历还没有结束。</p>
<p>第三次调用，Generator 函数从上次 <code>yield</code> 表达式停下的地方，一直执行到 <code>return</code> 语句（如果没有 <code>return</code> 语句，就执行到函数结束）。<code>next</code> 方法返回的对象的 <code>value</code> 属性，就是紧跟在 <code>return</code> 语句后面的表达式的值（如果没有 <code>return</code> 语句，则 <code>value</code> 属性的值为 <code>undefined</code>），<code>done</code> 属性的值 <code>true</code>，表示遍历已经结束。</p>
<p>第四次调用，此时 Generator 函数已经运行完毕，<code>next</code> 方法返回对象的 <code>value</code> 属性为 <code>undefined</code>，<code>done</code> 属性为 <code>true</code>。以后再调用 <code>next</code> 方法，返回的都是这个值。</p>
<p>总结一下，调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后，每次调用遍历器对象的 <code>next</code> 方法，就会返回一个有着 <code>value</code> 和 <code>done</code> 两个属性的对象。<code>value</code>属性表示当前的内部状态的值，是 <code>yield</code> 表达式后面那个表达式的值；<code>done</code> 属性是一个布尔值，表示是否遍历结束。</p>
<h2>yield 表达式</h2>
<p>由于 Generator 函数返回的遍历器对象，只有调用 <code>next</code> 方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。<code>yield</code> 表达式就是暂停标志。</p>
<p>遍历器对象的 <code>next</code> 方法的运行逻辑如下。</p>
<ol>
<li>
<p>遇到 <code>yield</code> 表达式，就暂停执行后面的操作，并将紧跟在 <code>yield</code> 后面的那个表达式的值，作为返回的对象的 <code>value</code> 属性值。</p>
</li>
<li>
<p>下一次调用 <code>next</code> 方法时，再继续往下执行，直到遇到下一个 <code>yield</code> 表达式。</p>
</li>
<li>
<p>如果没有再遇到新的 <code>yield</code> 表达式，就一直运行到函数结束，直到 <code>return</code> 语句为止，并将 <code>return</code> 语句后面的表达式的值，作为返回的对象的 <code>value</code> 属性值。</p>
</li>
<li>
<p>如果该函数没有 <code>return</code> 语句，则返回的对象的 <code>value</code> 属性值为 <code>undefined</code>。</p>
</li>
</ol>
<p>需要注意的是，<code>yield</code> 表达式后面的表达式，只有当调用 <code>next</code> 方法、内部指针指向该语句时才会执行，因此等于为 JavaScript 提供了手动的“<strong>惰性求值</strong>”（Lazy Evaluation）的语法功能。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">gen</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">yield</span> <span class="hljs-number">123</span> + <span class="hljs-number">456</span>;
}
</code></pre>
<p>上面代码中，<code>yield</code> 后面的表达式 <code>123 + 456</code>，不会立即求值，只会在<code>next</code>方法将指针移到这一句时，才会求值。</p>
<h3>yield 与 return</h3>
<p><code>yield</code> 表达式与 <code>return</code> 语句既有相似之处，也有区别。</p>
<ul>
<li>
<p>相似</p>
<ul>
<li>两种语句表达式都能返回紧跟在语句后面的那个表达式的值。</li>
</ul>
</li>
<li>
<p>区别</p>
<ul>
<li><strong>记忆功能</strong>：每次遇到 <code>yield</code>，函数暂停执行，下一次再从该位置继续向后执行，而 <code>return</code> 语句不具备位置记忆的功能。</li>
<li><strong>执行次数</strong>：一个函数里面，只能执行一次（或者说一个）<code>return</code> 语句，但是可以执行多次（或者说多个）<code>yield</code> 表达式。</li>
<li><strong>返回次数</strong>：正常函数只能返回一个值，因为只能执行一次 <code>return</code> ；Generator 函数可以返回一系列的值，因为可以有任意多个<code>yield</code>。从另一个角度看，也可以说 Generator 生成了一系列的值，这也就是它的名称的来历。</li>
</ul>
</li>
</ul>
<h3>暂缓执行函数</h3>
<p>Generator 函数可以不用 <code>yield</code> 表达式，这时就变成了一个单纯的<strong>暂缓执行函数</strong>。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;执行了！&#x27;</span>);
}

<span class="hljs-keyword">var</span> generator = <span class="hljs-title function_">fn</span>();

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
  generator.<span class="hljs-title function_">next</span>();
}, <span class="hljs-number">2000</span>);
</code></pre>
<p>上面代码中，函数 <code>fn</code> 如果是普通函数，在为变量 <code>generator</code> 赋值时就会执行。但是，函数 <code>fn</code> 是一个 Generator 函数，就变成只有调用 <code>next</code> 方法时，函数 <code>fn</code> 才会执行。</p>
<h3>表达式规范</h3>
<p>另外需要注意，<strong><code>yield</code>表达式只能用在 Generator 函数里面</strong>，用在其他地方都会报错。</p>
<pre class="hljs"><code class="language-js">(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>){
  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span>;
})()
<span class="hljs-comment">// SyntaxError: Unexpected number</span>
</code></pre>
<p>上面代码在一个普通函数中使用 <code>yield</code> 表达式，结果产生一个句法错误。</p>
<h3>嵌套表达式</h3>
<p><code>yield</code> 表达式如果用在另一个表达式之中，必须放在<strong>圆括号</strong>里面。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello&#x27;</span> + <span class="hljs-keyword">yield</span>); <span class="hljs-comment">// SyntaxError</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello&#x27;</span> + <span class="hljs-keyword">yield</span> <span class="hljs-number">123</span>); <span class="hljs-comment">// SyntaxError</span>

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello&#x27;</span> + (<span class="hljs-keyword">yield</span>)); <span class="hljs-comment">// OK</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello&#x27;</span> + (<span class="hljs-keyword">yield</span> <span class="hljs-number">123</span>)); <span class="hljs-comment">// OK</span>
}
</code></pre>
<p><code>yield</code> 表达式用作<strong>函数参数</strong>或放在<strong>赋值表达式</strong>的右边，可以不加括号。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">demo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">foo</span>(<span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;b&#x27;</span>); <span class="hljs-comment">// OK</span>
  <span class="hljs-keyword">let</span> input = <span class="hljs-keyword">yield</span>; <span class="hljs-comment">// OK</span>
}
</code></pre>
<h2>原型方法</h2>
<ul>
<li><a href="/front-end/standard-built-in-objects/control-abstraction-objects/generator/properties-of-the-promise-prototype-object/next">Generator.prototype.next</a></li>
<li><a href="/front-end/standard-built-in-objects/control-abstraction-objects/generator/properties-of-the-promise-prototype-object/return">Generator.prototype.return</a></li>
<li><a href="/front-end/standard-built-in-objects/control-abstraction-objects/generator/properties-of-the-promise-prototype-object/throw">Generator.prototype.throw</a></li>
</ul>
<p><strong>原型方法共同点</strong></p>
<p>三者的作用都是让 Generator 函数恢复执行，并且使用不同的语句替换 <code>yield</code> 表达式。</p>
<p><code>next()</code> 是将 <code>yield</code> 表达式替换成一个值。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> generator = <span class="hljs-keyword">function</span>*(x, y) {
  <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">yield</span> x + y;
  <span class="hljs-keyword">return</span> result;
};

<span class="hljs-keyword">const</span> gen = <span class="hljs-title function_">generator</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);

gen.<span class="hljs-title function_">next</span>(); <span class="hljs-comment">// Object {value: 3, done: false}</span>

gen.<span class="hljs-title function_">next</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// Object {value: 1, done: true}</span>

<span class="hljs-comment">// 相当于将 let result = yield x + y</span>
<span class="hljs-comment">// 替换成 let result = 1;</span>
</code></pre>
<p>上面代码中，第二个 <code>next(1)</code> 方法就相当于将 <code>yield</code> 表达式替换成一个值 <code>1</code>。如果 <code>next</code> 方法没有参数，就相当于替换成 <code>undefined</code>。</p>
<p><code>throw()</code> 是将 <code>yield</code> 表达式替换成一个 <code>throw</code> 语句。</p>
<pre class="hljs"><code class="language-js">gen.<span class="hljs-keyword">throw</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;出错了&#x27;</span>)); <span class="hljs-comment">// Uncaught Error: 出错了</span>

<span class="hljs-comment">// 相当于将 let result = yield x + y</span>
<span class="hljs-comment">// 替换成 let result = throw(new Error(&#x27;出错了&#x27;));</span>
</code></pre>
<p><code>return()</code> 是将 <code>yield</code> 表达式替换成一个 <code>return</code> 语句。</p>
<pre class="hljs"><code class="language-js">gen.<span class="hljs-keyword">return</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// Object {value: 2, done: true}</span>

<span class="hljs-comment">// 相当于将 let result = yield x + y</span>
<span class="hljs-comment">// 替换成 let result = return 2;</span>
</code></pre>
<h2>作为对象的函数</h2>
<p>如果一个对象的属性是 Generator 函数，可以简写成下面的形式。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">let</span> obj = {
  *<span class="hljs-title function_">generator</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// ···</span>
  },
};
</code></pre>
<p>上面代码中，<code>generator</code> 属性前面有一个星号，表示这个属性是一个 Generator 函数。</p>
<p>它的完整形式如下，与上面的写法是等价的。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">let</span> obj = {
  <span class="hljs-attr">myGeneratorMethod</span>: <span class="hljs-keyword">function</span>*() {
    <span class="hljs-comment">// ···</span>
  },
};
</code></pre>
<h2>判断方法</h2>
<p><strong>生成器对象的判断方法</strong></p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isGenerator</span>(<span class="hljs-params">obj</span>) {
  <span class="hljs-keyword">return</span> obj &amp;&amp; <span class="hljs-keyword">typeof</span> obj.<span class="hljs-property">next</span> === <span class="hljs-string">&#x27;function&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> obj.<span class="hljs-property">throw</span> === <span class="hljs-string">&#x27;function&#x27;</span>;
}
</code></pre>
<p><strong>生成器函数的判断方法</strong></p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">isGeneratorFunction</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> constructor = obj.<span class="hljs-property">constructor</span>;
  <span class="hljs-keyword">if</span> (!constructor) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
  <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;GeratorFunction&#x27;</span> === constructor.<span class="hljs-property">name</span> || <span class="hljs-string">&#x27;GeneratorFunction&#x27;</span> === constructor.<span class="hljs-property">displayName</span>)
    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">isGenerator</span>(constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);
}
</code></pre>
<p>利用函数的 <code>constructor</code> 构造器的名字来判断，为了兼容性使用 <code>name</code> 与 <code>displayName</code> 两个属性来进行判断. 这里递归调用 <code>isGenerator</code> 判断 <code>constructor</code> 的原型是因为有自定义迭代器的存在。</p>
<hr>
<p><strong>参考书籍：</strong></p>
<ul>
<li><a href="http://es6.ruanyifeng.com/#docs/generator" target="_blank" rel="noopener noreferrer nofollow">《ECMAScript 6 入门》阮一峰著</a></li>
</ul>
4:["$","div",null,{"className":"markdown-body","children":[["$","h1",null,{"children":"Generator"}],["$","article",null,{"dangerouslySetInnerHTML":{"__html":"$c"}}]]}]
a:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
8:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"front-end"}],["$","meta","2",{"name":"description","content":"front-end knowledge"}],["$","link","3",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
6:null
