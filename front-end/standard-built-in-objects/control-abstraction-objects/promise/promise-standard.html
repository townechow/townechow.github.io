<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/ec0a9d078e716e00.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/485ff6fe79292a08.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/0ff121a467c0636f.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-53834dba86d90934.js"/><script src="/_next/static/chunks/4bd1b696-20882bf820444624.js" async=""></script><script src="/_next/static/chunks/517-98ed787e5f259f2c.js" async=""></script><script src="/_next/static/chunks/main-app-f33d3e3aed85e21f.js" async=""></script><meta name="next-size-adjust" content=""/><title>front-end</title><meta name="description" content="front-end knowledge"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><main><div class="markdown-body"><h1>Promise/A+ 规范</h1><article><h1>Promise/A+ 规范</h1>
<p>Promise 表示一个异步操作的最终结果，与之进行交互的方式主要是 <code>.then</code> 方法，该方法注册了两个回调函数，用于接收 Promise 的终值或本 Promise 不能执行的原因。</p>
<p>本规范详细列出了 <code>.then</code> 方法的执行过程，所有遵循 Promises/A+ 规范实现的 Promise 均可以本标准作为参照基础来实施 <code>.then</code> 方法。因而本规范是十分稳定的。尽管 Promise/A+ 组织有时可能会修订本规范，但主要是为了处理一些特殊的边界情况，且这些改动都是微小且向下兼容的。如果我们要进行大规模不兼容的更新，我们一定会在事先进行谨慎地考虑、详尽的探讨和严格的测试。</p>
<p>从历史上说，本规范实际上是把之前 Promise/A 规范 中的建议明确成为了行为标准：我们一方面扩展了原有规范约定俗成的行为，一方面删减了原规范的一些特例情况和有问题的部分。</p>
<p>最后，核心的 Promises/A+ 规范不设计如何创建、解决和拒绝 Promise，而是专注于提供一个通用的 <code>.then</code> 方法。上述对于 Promises 的操作方法将来在其他规范中可能会提及。</p>
<h2>规范术语</h2>
<ul>
<li><strong>解决（fulfill）</strong>：指一个 Promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 fulfill 来表示解决，但在后世的 Promise 实现多以 resolve 来指代之。</li>
<li><strong>拒绝（reject）</strong>：指一个 Promise 失败时进行的一系列操作。</li>
<li><strong>终值（eventual value）</strong>：所谓终值，指的是 Promise 被解决时传递给解决回调的值，由于 Promise 有一次性的特征，因此当这个值被传递时，标志着 Promise 等待态的结束，故称之终值，有时也直接简称为值（value）。</li>
<li><strong>拒因（reason）</strong>：也就是拒绝原因，指在 Promise 被拒绝时传递给拒绝回调的值。</li>
</ul>
<h2>术语</h2>
<ul>
<li><strong>Promise</strong>：Promise 是一个拥有 <code>.then</code> 方法的对象或函数，其行为符合本规范；</li>
<li><strong>thenable</strong>：是一个定义了 <code>.then</code> 方法的对象或函数，文中译作&quot;拥有 <code>.then</code> 方法&quot;；</li>
<li><strong>值（value）</strong>：指任何 JavaScript 的合法值（包括 undefined、thenable 和 Promise）；</li>
<li><strong>异常（exception）</strong>：是使用 <code>throw</code> 语句抛出的一个值。</li>
<li><strong>拒因（reason）</strong>：表示一个 Promise 的拒绝原因。</li>
</ul>
<h2>状态</h2>
<p>一个 Promise 的当前状态必须为以下三种状态中的一种：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。</p>
<h3>等待态（Pending）</h3>
<p>处于等待态时，Promise 需满足以下条件：</p>
<ul>
<li>可以迁移至执行态或拒绝态</li>
</ul>
<h3>执行态（Fulfilled）</h3>
<p>处于执行态时，Promise 需满足以下条件：</p>
<ul>
<li>不能迁移至其他任何状态</li>
<li>必须拥有一个不可变的终值</li>
</ul>
<h3>拒绝态（Rejected）</h3>
<p>处于拒绝态时，Promise 需满足以下条件：</p>
<ul>
<li>不能迁移至其他任何状态</li>
<li>必须拥有一个不可变的拒因</li>
</ul>
<p>这里的不可变指的是恒等（即可用 <code>===</code> 判断相等），而不是意味着更深层次的不可变（译者注：盖指当 value 或 reason 不是基本数据类型时，只要求其引用地址相等，但属性值可被更改）。</p>
<h2>Then 方法</h2>
<p>一个 Promise 必须提供一个 <code>then</code> 方法以访问其<strong>当前值</strong>、<strong>终值</strong>和<strong>拒因</strong>。</p>
<p>Promise 的 then 方法接受两个参数：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">then</span>(onFulfilled, onRejected);
</code></pre>
<h3>参数可选</h3>
<p>onFulfilled 和 onRejected 都是可选参数。</p>
<ul>
<li>如果 onFulfilled 不是函数，其必须被忽略</li>
<li>如果 onRejected 不是函数，其必须被忽略</li>
</ul>
<h3>onFulfilled 特性</h3>
<p>如果 onFulfilled 是函数：</p>
<ul>
<li>当 Promise 执行结束后其必须被调用，其第一个参数为 Promise 的终值</li>
<li>在 Promise 执行结束前其不可被调用</li>
<li>其调用次数不可超过一次</li>
</ul>
<h3>onRejected 特性</h3>
<p>如果 onRejected 是函数：</p>
<ul>
<li>当 Promise 被拒绝执行后其必须被调用，其第一个参数为 Promise 的拒因</li>
<li>在 Promise 被拒绝执行前其不可被调用</li>
<li>其调用次数不可超过一次</li>
</ul>
<h3>调用时机</h3>
<p>onFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用。<a href="#%E6%B3%A81">注 1</a></p>
<h3>调用要求</h3>
<p>onFulfilled 和 onRejected 必须被作为函数调用（即没有 this 值）<a href="#%E6%B3%A82">注 2</a></p>
<h3>多次调用</h3>
<p><code>then</code> 方法可以被同一个 Promise 调用多次</p>
<ul>
<li>当 Promise 成功执行时，所有 onFulfilled 需按照其注册顺序依次回调</li>
<li>当 Promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调</li>
</ul>
<h3>返回</h3>
<p><code>then</code> 方法必须返回一个 Promise 对象<a href="#%E6%B3%A83">注 3</a></p>
<pre class="hljs"><code class="language-js">promise2 = promise1.<span class="hljs-title function_">then</span>(onFulfilled, onRejected);
</code></pre>
<ul>
<li>如果 onFulfilled 或者 onRejected 返回一个值 <code>x</code> ，则运行下面的 Promise 解决过程：<code>[[Resolve]](Promise2, x)</code></li>
<li>如果 onFulfilled 或者 onRejected 抛出一个异常 <code>e</code> ，则 promise2 必须拒绝执行，并返回拒因 <code>e</code></li>
<li>如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值</li>
<li>如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的拒因</li>
</ul>
<p><strong>译者注</strong>：理解上面的&quot;返回&quot;部分非常重要，即：<strong>不论 <code>promise1</code> 被 reject 还是被 resolve 时 <code>promise2</code> 都会被 resolve，只有出现异常时才会被 rejected。</strong></p>
<h2>解决过程</h2>
<p><strong>Promise 解决过程</strong>是一个抽象的操作，其需输入一个 Promise 和一个值，我们表示为 <code>[[Resolve]](Promise, x)</code>，如果 <code>x</code> 有 <code>then</code> 方法且看上去像一个 Promise ，解决程序即尝试使 Promise 接受 <code>x</code> 的状态；否则其用 <code>x</code> 的值来执行 Promise 。</p>
<p>这种 thenable 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 <code>then</code> 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。</p>
<p>运行 <code>[[Resolve]](Promise, x)</code> 需遵循以下步骤：</p>
<h3>x 与 Promise 相等</h3>
<p>如果 Promise 和 x 指向同一对象，以 TypeError 为拒因拒绝执行 Promise</p>
<h3>x 为 Promise</h3>
<p>如果 x 为 Promise ，则使 Promise 接受 x 的状态 <a href="#%E6%B3%A84">注 4</a>：</p>
<ul>
<li>如果 x 处于等待态，Promise 需保持为等待态直至 x 被执行或拒绝</li>
<li>如果 x 处于执行态，用相同的值执行 Promise</li>
<li>如果 x 处于拒绝态，用相同的拒因拒绝 Promise</li>
</ul>
<h3>x 为对象或函数</h3>
<p>如果 x 为对象或者函数：</p>
<ul>
<li>把 <code>x.then</code> 赋值给 <code>then</code> <a href="#%E6%B3%A85">注 5</a></li>
<li>如果取 <code>x.then</code> 的值时抛出错误 <code>e</code> ，则以 <code>e</code> 为拒因拒绝 Promise</li>
<li>如果 <code>then</code> 是函数，将 <code>x</code> 作为函数的作用域 <code>this</code> 调用之。传递两个回调函数作为参数，第一个参数叫做 <code>resolvePromise</code> ，第二个参数叫做 <code>rejectPromise</code>:
<ul>
<li>如果 <code>resolvePromise</code> 以值 <code>y</code> 为参数被调用，则运行 [[Resolve]](Promise, y)</li>
<li>如果 <code>rejectPromise</code> 以拒因 r 为参数被调用，则以拒因 r 拒绝 Promise</li>
<li>如果 <code>resolvePromise</code> 和 <code>rejectPromise</code> 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用</li>
<li>如果调用 <code>then</code> 方法抛出了异常 <code>e</code>：
<ul>
<li>如果 <code>resolvePromise</code> 或 <code>rejectPromise</code> 已经被调用，则忽略之</li>
<li>否则以 <code>e</code> 为拒因拒绝 Promise</li>
</ul>
</li>
<li>如果 then 不是函数，以 x 为参数执行 Promise</li>
</ul>
</li>
<li>如果 x 不为对象或者函数，以 x 为参数执行 Promise</li>
</ul>
<p>如果一个 Promise 被一个循环的 thenable 链中的对象解决，而 <code>[[Resolve]](Promise, thenable)</code> 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 TypeError 为拒因来拒绝 Promise <a href="#%E6%B3%A86">注 6</a>。</p>
<h2>注释</h2>
<h3>注 1</h3>
<p>这里的<strong>平台代码</strong>指的是引擎、环境以及 promise 的实施代码。实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。这个事件队列可以采用 <strong>宏任务（macro-task）</strong> 机制或者 <strong>微任务（micro-task）</strong> 机制来实现。由于 Promise 的实施代码本身就是平台代码（<strong>译者注</strong>：即都是 JavaScript），故代码自身在处理在处理程序时可能已经包含一个任务调度队列。</p>
<p><strong>译者注</strong>：这里提及了 <code>macrotask</code> 和 <code>microtask</code> 两个概念，这表示异步任务的两种分类。在挂起任务时，JavaScript 引擎会将所有任务按照类别分到这两个队列中，首先在 <code>macrotask</code> 的队列（这个队列也被叫做 <code>task queue</code> 任务队列）中取出第一个任务，执行完毕后取出 <code>microtask</code> 队列中的所有任务顺序执行；之后再取 <code>macrotask</code> 任务，周而复始，直至两个队列的任务都取完。</p>
<p>两个类别的具体分类如下：</p>
<ul>
<li><strong>macro-task</strong>: script（整体代码）、<code>setTimeout</code>、<code>setInterval</code>、setImmediate、I/O、UI rendering</li>
<li><strong>micro-task</strong>: process.nextTick、Promise（这里指浏览器实现的原生 Promise）、Object.observe、MutationObserver</li>
</ul>
<h3>注 2</h3>
<p>在严格模式（<code>strict</code>）中，函数 <code>this</code> 的值为 <code>undefined</code>；在非严格模式中其为全局对象。</p>
<h3>注 3</h3>
<p>代码实现在满足所有要求的情况下可以允许 <code>promise2 === promise1</code> 。每个实现都要文档说明其是否允许以及在何种条件下允许 <code>promise2 === promise1</code>。</p>
<h3>注 4</h3>
<p>总体来说，如果 <code>x</code> 符合当前实现，我们才认为它是真正的 Promise 。这一规则允许那些特例实现接受符合已知要求的 Promise 状态。</p>
<h3>注 5</h3>
<p>这步我们先是存储了一个指向 <code>x.then</code> 的引用，然后测试并调用该引用，以避免多次访问 <code>x.then</code> 属性。这种预防措施确保了该属性的一致性，因为其值可能在检索调用时被改变。</p>
<h3>注 6</h3>
<p>实现不应该对 thenable 链的深度设限，并假定超出本限制的递归就是无限循环。只有真正的循环递归才应能导致 TypeError 异常；如果一条无限长的链上 thenable 均不相同，那么递归下去永远是正确的行为。</p>
<h2>参考资料</h2>
<ul>
<li><a href="https://Promisesaplus.com/">📖 Promise/A+ 规范原文</a></li>
<li><a href="http://www.ituring.com.cn/article/66566">📖 Promise/A+ 规范译文</a></li>
<li><a href="https://juejin.im/post/6844904116913700877">📝 手写一个 Promise/A+，完美通过官方 872 个测试用例</a></li>
<li><a href="https://juejin.im/post/6856213486633304078">📝 手写 Promise 核心原理</a></li>
</ul>
</article></div></main><script src="/_next/static/chunks/webpack-53834dba86d90934.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5244,[],\"\"]\n3:I[3866,[],\"\"]\n5:I[6213,[],\"OutletBoundary\"]\n7:I[6213,[],\"MetadataBoundary\"]\n9:I[6213,[],\"ViewportBoundary\"]\nb:I[4835,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/ec0a9d078e716e00.css\",\"style\"]\n:HL[\"/_next/static/css/485ff6fe79292a08.css\",\"style\"]\n:HL[\"/_next/static/css/0ff121a467c0636f.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"P2aiewlOc1Z9OPuSRFf3D\",\"p\":\"\",\"c\":[\"\",\"front-end\",\"standard-built-in-objects\",\"control-abstraction-objects\",\"promise\",\"promise-standard\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"front-end\",{\"children\":[[\"slug\",\"standard-built-in-objects/control-abstraction-objects/promise/promise-standard\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/ec0a9d078e716e00.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"front-end\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/485ff6fe79292a08.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0ff121a467c0636f.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"main\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[[\"slug\",\"standard-built-in-objects/control-abstraction-objects/promise/promise-standard\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"jjruH7FF0MIFaGC7wc5tN\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:T31db,"])</script><script>self.__next_f.push([1,"\u003ch1\u003ePromise/A+ 规范\u003c/h1\u003e\n\u003cp\u003ePromise 表示一个异步操作的最终结果，与之进行交互的方式主要是 \u003ccode\u003e.then\u003c/code\u003e 方法，该方法注册了两个回调函数，用于接收 Promise 的终值或本 Promise 不能执行的原因。\u003c/p\u003e\n\u003cp\u003e本规范详细列出了 \u003ccode\u003e.then\u003c/code\u003e 方法的执行过程，所有遵循 Promises/A+ 规范实现的 Promise 均可以本标准作为参照基础来实施 \u003ccode\u003e.then\u003c/code\u003e 方法。因而本规范是十分稳定的。尽管 Promise/A+ 组织有时可能会修订本规范，但主要是为了处理一些特殊的边界情况，且这些改动都是微小且向下兼容的。如果我们要进行大规模不兼容的更新，我们一定会在事先进行谨慎地考虑、详尽的探讨和严格的测试。\u003c/p\u003e\n\u003cp\u003e从历史上说，本规范实际上是把之前 Promise/A 规范 中的建议明确成为了行为标准：我们一方面扩展了原有规范约定俗成的行为，一方面删减了原规范的一些特例情况和有问题的部分。\u003c/p\u003e\n\u003cp\u003e最后，核心的 Promises/A+ 规范不设计如何创建、解决和拒绝 Promise，而是专注于提供一个通用的 \u003ccode\u003e.then\u003c/code\u003e 方法。上述对于 Promises 的操作方法将来在其他规范中可能会提及。\u003c/p\u003e\n\u003ch2\u003e规范术语\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e解决（fulfill）\u003c/strong\u003e：指一个 Promise 成功时进行的一系列操作，如状态的改变、回调的执行。虽然规范中用 fulfill 来表示解决，但在后世的 Promise 实现多以 resolve 来指代之。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e拒绝（reject）\u003c/strong\u003e：指一个 Promise 失败时进行的一系列操作。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e终值（eventual value）\u003c/strong\u003e：所谓终值，指的是 Promise 被解决时传递给解决回调的值，由于 Promise 有一次性的特征，因此当这个值被传递时，标志着 Promise 等待态的结束，故称之终值，有时也直接简称为值（value）。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e拒因（reason）\u003c/strong\u003e：也就是拒绝原因，指在 Promise 被拒绝时传递给拒绝回调的值。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e术语\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003ePromise\u003c/strong\u003e：Promise 是一个拥有 \u003ccode\u003e.then\u003c/code\u003e 方法的对象或函数，其行为符合本规范；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003ethenable\u003c/strong\u003e：是一个定义了 \u003ccode\u003e.then\u003c/code\u003e 方法的对象或函数，文中译作\u0026quot;拥有 \u003ccode\u003e.then\u003c/code\u003e 方法\u0026quot;；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e值（value）\u003c/strong\u003e：指任何 JavaScript 的合法值（包括 undefined、thenable 和 Promise）；\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e异常（exception）\u003c/strong\u003e：是使用 \u003ccode\u003ethrow\u003c/code\u003e 语句抛出的一个值。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e拒因（reason）\u003c/strong\u003e：表示一个 Promise 的拒绝原因。\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e状态\u003c/h2\u003e\n\u003cp\u003e一个 Promise 的当前状态必须为以下三种状态中的一种：等待态（Pending）、执行态（Fulfilled）和拒绝态（Rejected）。\u003c/p\u003e\n\u003ch3\u003e等待态（Pending）\u003c/h3\u003e\n\u003cp\u003e处于等待态时，Promise 需满足以下条件：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e可以迁移至执行态或拒绝态\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e执行态（Fulfilled）\u003c/h3\u003e\n\u003cp\u003e处于执行态时，Promise 需满足以下条件：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e不能迁移至其他任何状态\u003c/li\u003e\n\u003cli\u003e必须拥有一个不可变的终值\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e拒绝态（Rejected）\u003c/h3\u003e\n\u003cp\u003e处于拒绝态时，Promise 需满足以下条件：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e不能迁移至其他任何状态\u003c/li\u003e\n\u003cli\u003e必须拥有一个不可变的拒因\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e这里的不可变指的是恒等（即可用 \u003ccode\u003e===\u003c/code\u003e 判断相等），而不是意味着更深层次的不可变（译者注：盖指当 value 或 reason 不是基本数据类型时，只要求其引用地址相等，但属性值可被更改）。\u003c/p\u003e\n\u003ch2\u003eThen 方法\u003c/h2\u003e\n\u003cp\u003e一个 Promise 必须提供一个 \u003ccode\u003ethen\u003c/code\u003e 方法以访问其\u003cstrong\u003e当前值\u003c/strong\u003e、\u003cstrong\u003e终值\u003c/strong\u003e和\u003cstrong\u003e拒因\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003ePromise 的 then 方法接受两个参数：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(onFulfilled, onRejected);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e参数可选\u003c/h3\u003e\n\u003cp\u003eonFulfilled 和 onRejected 都是可选参数。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果 onFulfilled 不是函数，其必须被忽略\u003c/li\u003e\n\u003cli\u003e如果 onRejected 不是函数，其必须被忽略\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eonFulfilled 特性\u003c/h3\u003e\n\u003cp\u003e如果 onFulfilled 是函数：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e当 Promise 执行结束后其必须被调用，其第一个参数为 Promise 的终值\u003c/li\u003e\n\u003cli\u003e在 Promise 执行结束前其不可被调用\u003c/li\u003e\n\u003cli\u003e其调用次数不可超过一次\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eonRejected 特性\u003c/h3\u003e\n\u003cp\u003e如果 onRejected 是函数：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e当 Promise 被拒绝执行后其必须被调用，其第一个参数为 Promise 的拒因\u003c/li\u003e\n\u003cli\u003e在 Promise 被拒绝执行前其不可被调用\u003c/li\u003e\n\u003cli\u003e其调用次数不可超过一次\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e调用时机\u003c/h3\u003e\n\u003cp\u003eonFulfilled 和 onRejected 只有在执行环境堆栈仅包含平台代码时才可被调用。\u003ca href=\"#%E6%B3%A81\"\u003e注 1\u003c/a\u003e\u003c/p\u003e\n\u003ch3\u003e调用要求\u003c/h3\u003e\n\u003cp\u003eonFulfilled 和 onRejected 必须被作为函数调用（即没有 this 值）\u003ca href=\"#%E6%B3%A82\"\u003e注 2\u003c/a\u003e\u003c/p\u003e\n\u003ch3\u003e多次调用\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ethen\u003c/code\u003e 方法可以被同一个 Promise 调用多次\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e当 Promise 成功执行时，所有 onFulfilled 需按照其注册顺序依次回调\u003c/li\u003e\n\u003cli\u003e当 Promise 被拒绝执行时，所有的 onRejected 需按照其注册顺序依次回调\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e返回\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003ethen\u003c/code\u003e 方法必须返回一个 Promise 对象\u003ca href=\"#%E6%B3%A83\"\u003e注 3\u003c/a\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003epromise2 = promise1.\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(onFulfilled, onRejected);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e如果 onFulfilled 或者 onRejected 返回一个值 \u003ccode\u003ex\u003c/code\u003e ，则运行下面的 Promise 解决过程：\u003ccode\u003e[[Resolve]](Promise2, x)\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e如果 onFulfilled 或者 onRejected 抛出一个异常 \u003ccode\u003ee\u003c/code\u003e ，则 promise2 必须拒绝执行，并返回拒因 \u003ccode\u003ee\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e如果 onFulfilled 不是函数且 promise1 成功执行， promise2 必须成功执行并返回相同的值\u003c/li\u003e\n\u003cli\u003e如果 onRejected 不是函数且 promise1 拒绝执行， promise2 必须拒绝执行并返回相同的拒因\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e译者注\u003c/strong\u003e：理解上面的\u0026quot;返回\u0026quot;部分非常重要，即：\u003cstrong\u003e不论 \u003ccode\u003epromise1\u003c/code\u003e 被 reject 还是被 resolve 时 \u003ccode\u003epromise2\u003c/code\u003e 都会被 resolve，只有出现异常时才会被 rejected。\u003c/strong\u003e\u003c/p\u003e\n\u003ch2\u003e解决过程\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003ePromise 解决过程\u003c/strong\u003e是一个抽象的操作，其需输入一个 Promise 和一个值，我们表示为 \u003ccode\u003e[[Resolve]](Promise, x)\u003c/code\u003e，如果 \u003ccode\u003ex\u003c/code\u003e 有 \u003ccode\u003ethen\u003c/code\u003e 方法且看上去像一个 Promise ，解决程序即尝试使 Promise 接受 \u003ccode\u003ex\u003c/code\u003e 的状态；否则其用 \u003ccode\u003ex\u003c/code\u003e 的值来执行 Promise 。\u003c/p\u003e\n\u003cp\u003e这种 thenable 的特性使得 Promise 的实现更具有通用性：只要其暴露出一个遵循 Promise/A+ 协议的 \u003ccode\u003ethen\u003c/code\u003e 方法即可；这同时也使遵循 Promise/A+ 规范的实现可以与那些不太规范但可用的实现能良好共存。\u003c/p\u003e\n\u003cp\u003e运行 \u003ccode\u003e[[Resolve]](Promise, x)\u003c/code\u003e 需遵循以下步骤：\u003c/p\u003e\n\u003ch3\u003ex 与 Promise 相等\u003c/h3\u003e\n\u003cp\u003e如果 Promise 和 x 指向同一对象，以 TypeError 为拒因拒绝执行 Promise\u003c/p\u003e\n\u003ch3\u003ex 为 Promise\u003c/h3\u003e\n\u003cp\u003e如果 x 为 Promise ，则使 Promise 接受 x 的状态 \u003ca href=\"#%E6%B3%A84\"\u003e注 4\u003c/a\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e如果 x 处于等待态，Promise 需保持为等待态直至 x 被执行或拒绝\u003c/li\u003e\n\u003cli\u003e如果 x 处于执行态，用相同的值执行 Promise\u003c/li\u003e\n\u003cli\u003e如果 x 处于拒绝态，用相同的拒因拒绝 Promise\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003ex 为对象或函数\u003c/h3\u003e\n\u003cp\u003e如果 x 为对象或者函数：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e把 \u003ccode\u003ex.then\u003c/code\u003e 赋值给 \u003ccode\u003ethen\u003c/code\u003e \u003ca href=\"#%E6%B3%A85\"\u003e注 5\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e如果取 \u003ccode\u003ex.then\u003c/code\u003e 的值时抛出错误 \u003ccode\u003ee\u003c/code\u003e ，则以 \u003ccode\u003ee\u003c/code\u003e 为拒因拒绝 Promise\u003c/li\u003e\n\u003cli\u003e如果 \u003ccode\u003ethen\u003c/code\u003e 是函数，将 \u003ccode\u003ex\u003c/code\u003e 作为函数的作用域 \u003ccode\u003ethis\u003c/code\u003e 调用之。传递两个回调函数作为参数，第一个参数叫做 \u003ccode\u003eresolvePromise\u003c/code\u003e ，第二个参数叫做 \u003ccode\u003erejectPromise\u003c/code\u003e:\n\u003cul\u003e\n\u003cli\u003e如果 \u003ccode\u003eresolvePromise\u003c/code\u003e 以值 \u003ccode\u003ey\u003c/code\u003e 为参数被调用，则运行 [[Resolve]](Promise, y)\u003c/li\u003e\n\u003cli\u003e如果 \u003ccode\u003erejectPromise\u003c/code\u003e 以拒因 r 为参数被调用，则以拒因 r 拒绝 Promise\u003c/li\u003e\n\u003cli\u003e如果 \u003ccode\u003eresolvePromise\u003c/code\u003e 和 \u003ccode\u003erejectPromise\u003c/code\u003e 均被调用，或者被同一参数调用了多次，则优先采用首次调用并忽略剩下的调用\u003c/li\u003e\n\u003cli\u003e如果调用 \u003ccode\u003ethen\u003c/code\u003e 方法抛出了异常 \u003ccode\u003ee\u003c/code\u003e：\n\u003cul\u003e\n\u003cli\u003e如果 \u003ccode\u003eresolvePromise\u003c/code\u003e 或 \u003ccode\u003erejectPromise\u003c/code\u003e 已经被调用，则忽略之\u003c/li\u003e\n\u003cli\u003e否则以 \u003ccode\u003ee\u003c/code\u003e 为拒因拒绝 Promise\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e如果 then 不是函数，以 x 为参数执行 Promise\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e如果 x 不为对象或者函数，以 x 为参数执行 Promise\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e如果一个 Promise 被一个循环的 thenable 链中的对象解决，而 \u003ccode\u003e[[Resolve]](Promise, thenable)\u003c/code\u003e 的递归性质又使得其被再次调用，根据上述的算法将会陷入无限递归之中。算法虽不强制要求，但也鼓励施者检测这样的递归是否存在，若检测到存在则以一个可识别的 TypeError 为拒因来拒绝 Promise \u003ca href=\"#%E6%B3%A86\"\u003e注 6\u003c/a\u003e。\u003c/p\u003e\n\u003ch2\u003e注释\u003c/h2\u003e\n\u003ch3\u003e注 1\u003c/h3\u003e\n\u003cp\u003e这里的\u003cstrong\u003e平台代码\u003c/strong\u003e指的是引擎、环境以及 promise 的实施代码。实践中要确保 onFulfilled 和 onRejected 方法异步执行，且应该在 then 方法被调用的那一轮事件循环之后的新执行栈中执行。这个事件队列可以采用 \u003cstrong\u003e宏任务（macro-task）\u003c/strong\u003e 机制或者 \u003cstrong\u003e微任务（micro-task）\u003c/strong\u003e 机制来实现。由于 Promise 的实施代码本身就是平台代码（\u003cstrong\u003e译者注\u003c/strong\u003e：即都是 JavaScript），故代码自身在处理在处理程序时可能已经包含一个任务调度队列。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e译者注\u003c/strong\u003e：这里提及了 \u003ccode\u003emacrotask\u003c/code\u003e 和 \u003ccode\u003emicrotask\u003c/code\u003e 两个概念，这表示异步任务的两种分类。在挂起任务时，JavaScript 引擎会将所有任务按照类别分到这两个队列中，首先在 \u003ccode\u003emacrotask\u003c/code\u003e 的队列（这个队列也被叫做 \u003ccode\u003etask queue\u003c/code\u003e 任务队列）中取出第一个任务，执行完毕后取出 \u003ccode\u003emicrotask\u003c/code\u003e 队列中的所有任务顺序执行；之后再取 \u003ccode\u003emacrotask\u003c/code\u003e 任务，周而复始，直至两个队列的任务都取完。\u003c/p\u003e\n\u003cp\u003e两个类别的具体分类如下：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003emacro-task\u003c/strong\u003e: script（整体代码）、\u003ccode\u003esetTimeout\u003c/code\u003e、\u003ccode\u003esetInterval\u003c/code\u003e、setImmediate、I/O、UI rendering\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003emicro-task\u003c/strong\u003e: process.nextTick、Promise（这里指浏览器实现的原生 Promise）、Object.observe、MutationObserver\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e注 2\u003c/h3\u003e\n\u003cp\u003e在严格模式（\u003ccode\u003estrict\u003c/code\u003e）中，函数 \u003ccode\u003ethis\u003c/code\u003e 的值为 \u003ccode\u003eundefined\u003c/code\u003e；在非严格模式中其为全局对象。\u003c/p\u003e\n\u003ch3\u003e注 3\u003c/h3\u003e\n\u003cp\u003e代码实现在满足所有要求的情况下可以允许 \u003ccode\u003epromise2 === promise1\u003c/code\u003e 。每个实现都要文档说明其是否允许以及在何种条件下允许 \u003ccode\u003epromise2 === promise1\u003c/code\u003e。\u003c/p\u003e\n\u003ch3\u003e注 4\u003c/h3\u003e\n\u003cp\u003e总体来说，如果 \u003ccode\u003ex\u003c/code\u003e 符合当前实现，我们才认为它是真正的 Promise 。这一规则允许那些特例实现接受符合已知要求的 Promise 状态。\u003c/p\u003e\n\u003ch3\u003e注 5\u003c/h3\u003e\n\u003cp\u003e这步我们先是存储了一个指向 \u003ccode\u003ex.then\u003c/code\u003e 的引用，然后测试并调用该引用，以避免多次访问 \u003ccode\u003ex.then\u003c/code\u003e 属性。这种预防措施确保了该属性的一致性，因为其值可能在检索调用时被改变。\u003c/p\u003e\n\u003ch3\u003e注 6\u003c/h3\u003e\n\u003cp\u003e实现不应该对 thenable 链的深度设限，并假定超出本限制的递归就是无限循环。只有真正的循环递归才应能导致 TypeError 异常；如果一条无限长的链上 thenable 均不相同，那么递归下去永远是正确的行为。\u003c/p\u003e\n\u003ch2\u003e参考资料\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://Promisesaplus.com/\"\u003e📖 Promise/A+ 规范原文\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"http://www.ituring.com.cn/article/66566\"\u003e📖 Promise/A+ 规范译文\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.im/post/6844904116913700877\"\u003e📝 手写一个 Promise/A+，完美通过官方 872 个测试用例\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.im/post/6856213486633304078\"\u003e📝 手写 Promise 核心原理\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"markdown-body\",\"children\":[[\"$\",\"h1\",null,{\"children\":\"Promise/A+ 规范\"}],[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"front-end\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"front-end knowledge\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>