<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/ec0a9d078e716e00.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/485ff6fe79292a08.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/0ff121a467c0636f.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-038c2e688b596d0e.js"/><script src="/_next/static/chunks/4bd1b696-20882bf820444624.js" async=""></script><script src="/_next/static/chunks/517-98ed787e5f259f2c.js" async=""></script><script src="/_next/static/chunks/main-app-f33d3e3aed85e21f.js" async=""></script><meta name="next-size-adjust" content=""/><title>front-end</title><meta name="description" content="front-end knowledge"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><main><div class="markdown-body"><h1>函数节流</h1><article><h1>函数节流</h1>
<p><strong>函数节流</strong>：规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。简单来说，触发后立即执行，但如果要执行下一次，需要在离上次执行时间间隔设定时间后再出发才能执行。</p>
<p>🏕 <strong>生活中的实例：</strong></p>
<p>我们知道目前的一种说法是当 1 秒内连续播放 24 张以上的图片时，在人眼的视觉中就会形成一个连贯的动画，所以在电影的播放中基本是以每秒 24 张的速度播放的，为什么不是 100 张或更多呢，主要是因为 24 张就可以满足人类视觉需求的时候，100 张就会显得很浪费资源。</p>
<h2>目的</h2>
<p>从字面上就可以理解，函数节流就是用来节流函数从而一定程度上优化性能的。</p>
<p>例如，DOM  操作比起非 DOM  交互需要占用更多的内存空间和消耗更多的 CPU  时间。连续尝试进行过多的 DOM  相关操作可能会导致浏览器卡顿，有时候甚至会崩溃。尤其在 IE  中使用 <code>onresize</code>  事件处理程序的时候容易发生，当调整浏览器大小的时候，该事件会连续触发。在 <code>onresize</code>  事件处理程序内部如果尝试进行 DOM  操作，其高频率的更改可能会让浏览器崩溃。</p>
<h2>代码实现</h2>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">/**
 * 实现函数的节流（目的是频繁触发中缩减频率）
 * <span class="hljs-doctag">@param</span> fn {Function} 实际要执行的函数
 * <span class="hljs-doctag">@param</span> wait {Number} 执行间隔，单位是毫秒(ms)，默认100ms
 * <span class="hljs-doctag">@return</span> {<span class="hljs-type">Function</span>} 可被调用执行的函数
 */</span>

<span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, wait = <span class="hljs-number">500</span></span>) {
  <span class="hljs-comment">// 利用闭包保存定时器和上次执行时间</span>
  <span class="hljs-comment">// 上次执行时间</span>
  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>,
    last;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) {
    <span class="hljs-keyword">const</span> now = +<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();

    <span class="hljs-keyword">if</span> (last &amp;&amp; now &lt; last + timeout) {
      <span class="hljs-built_in">clearTimeout</span>(timer);
      timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
        last = now;
        fun.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
      }, timeout);
    } <span class="hljs-keyword">else</span> {
      last = now;
      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, args);
    }
  };
}
</code></pre>
<h2>应用实践</h2>
<h3>原生实现应用</h3>
<p>首次点击按钮触发 <code>trigger</code> 函数，在 1000 毫秒内频繁点击按钮也不会再次执行 <code>trigger</code> 函数，直到 1000 毫秒之后再次点击才会再次执行 <code>trigger</code> 函数。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;button&#x27;</span>);

<span class="hljs-keyword">function</span> <span class="hljs-title function_">trigger</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;click&#x27;</span>);
}

button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-title function_">throttle</span>(trigger, <span class="hljs-number">1000</span>));
</code></pre>
<h3>React 应用</h3>
<p>在 React 中使用，下面监听窗口的 <code>resize</code> 和输入框的 <code>onChange</code> 事件：</p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, { <span class="hljs-title class_">Component</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> { throttle } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@utils/throttle&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Invoke</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Component</span> {
  <span class="hljs-title function_">constructor</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">super</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-property">change</span> = <span class="hljs-title function_">throttle</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span>);
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;throttle&#x27;</span>);
    }, <span class="hljs-number">100</span>);
  }
  <span class="hljs-title function_">handleWindowResize</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;resize&#x27;</span>);
  }
  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, <span class="hljs-title function_">throttle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">handleWindowResize</span>, <span class="hljs-number">100</span>));
  }
  <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">removeEvenetListener</span>(<span class="hljs-string">&#x27;resize&#x27;</span>, <span class="hljs-title function_">throttle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">handleWindowResize</span>), <span class="hljs-number">100</span>);
  }
  handleInputChange = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> {
    <span class="hljs-comment">// 持久化</span>
    e.<span class="hljs-title function_">persist</span>();
    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">change</span>(e);
  };

  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">onChange</span>=<span class="hljs-string">{this.handleInputChange}</span> /&gt;</span></span>;
  }
}
</code></pre>
<p>其他框架库的实现：</p>
<ul>
<li><a href="https://github.com/lodash/lodash/blob/master/throttle.js" target="_blank" rel="noopener noreferrer nofollow">Lodash - throttle</a></li>
<li><a href="https://underscorejs.org/#throttle" target="_blank" rel="noopener noreferrer nofollow">Underscore - throttle</a></li>
</ul>
<h3>应用场景</h3>
<p>常见的高频触发监听事件的应用场景：</p>
<ul>
<li>动画场景：避免短时间内多次触发动画引起性能问题</li>
<li>拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动（<code>mousemove</code>）</li>
<li>缩放场景：监控浏览器窗口大小（<code>resize</code>）</li>
<li>滚轮场景：鼠标滚轮事件（<code>wheel</code>）</li>
<li>Canvas 画笔功能</li>
</ul>
<blockquote>
<p>总结：适合大量事件按时间做平均分配触发</p>
</blockquote>
<h2>应用实践</h2>
<h3>页面滚动事件</h3>
<p>这里以判断页面是否滚动到底部为例，普通的做法就是监听 Window 对象的 <code>scroll</code> 事件，然后在函数体中写入判断是否滚动到底部的逻辑。</p>
<pre class="hljs"><code class="language-js">$(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 判断是否滚动到底部的逻辑</span>
  <span class="hljs-keyword">let</span> pageHeight = $(<span class="hljs-string">&#x27;body&#x27;</span>).<span class="hljs-title function_">height</span>(),
    scrollTop = $(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">scrollTop</span>(),
    winHeight = $(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">height</span>(),
    thresold = pageHeight - scrollTop - winHeight;

  <span class="hljs-keyword">if</span> (thresod &gt; -<span class="hljs-number">100</span> &amp;&amp; thresold &lt;= <span class="hljs-number">20</span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;The end&#x27;</span>);
  }
});
</code></pre>
<p>这样做的一个缺点就是比较消耗性能，因为当在滚动的时候，浏览器会无时无刻地在计算判断是否滚动到底部的逻辑，而在实际场景中是不需要这么做的，在实际场景中可能是这样的：在滚动过程中，每隔一段时间再去计算这个判断逻辑。而函数节流所做的工作就是每隔一段时间去执行一次原本需要无时无刻地在执行的函数，所以在滚动事件中引入函数的节流是一个非常好的实践。</p>
<pre class="hljs"><code class="language-js">$(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">on</span>(
  <span class="hljs-string">&#x27;scroll&#x27;</span>,
  <span class="hljs-title function_">throttle</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 判断是否滚动到底部的逻辑</span>
    <span class="hljs-keyword">let</span> pageHeight = $(<span class="hljs-string">&#x27;body&#x27;</span>).<span class="hljs-title function_">height</span>(),
      scrollTop = $(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">scrollTop</span>(),
      winHeight = $(<span class="hljs-variable language_">window</span>).<span class="hljs-title function_">height</span>(),
      thresold = pageHeight - scrollTop - winHeight;
    <span class="hljs-keyword">if</span> (thresold &gt; -<span class="hljs-number">100</span> &amp;&amp; thresold &lt;= <span class="hljs-number">20</span>) {
      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;end&#x27;</span>);
    }
  }, <span class="hljs-number">300</span>)
);
</code></pre>
<p>加入函数节流之后，当页面再滚动的时候，每隔 300ms 才会执行一次判断逻辑。</p>
<p>简单来说，函数的节流就是通过闭包保存一个标记（通常是定时器标识），在函数的开头判断这个标记是否为 <code>true</code> ，如果为 <code>true</code> 的话就继续执行函数，否则则 <code>return</code> 掉，判断完标记后立即把这个标记设为 <code>false</code> ，然后把外部传入的函数的执行包在一个 <code>setTimeout</code> 中，最后在 <code>setTimeout</code> 执行完毕后再把标记设置为 <code>true</code> （这里很关键），表示可以执行下一次的循环了。当 <code>setTimeout</code> 还未执行的时候，<code>canRun</code> 这个标记始终为 <code>false</code>，在开头的判断中被 <code>return</code> 掉。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, interval = <span class="hljs-number">300</span></span>) {
  <span class="hljs-keyword">let</span> canRun = <span class="hljs-literal">true</span>;
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-keyword">if</span> (!canRun) <span class="hljs-keyword">return</span>;
    canRun = <span class="hljs-literal">false</span>;
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      fn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">arguments</span>);
      canRun = <span class="hljs-literal">true</span>;
    }, interval);
  };
}
</code></pre>
<h2>参考资料</h2>
<ul>
<li><a href="http://demo.nimius.net/debounce_throttle/" target="_blank" rel="noopener noreferrer nofollow">📝 函数节流和函数防抖的可视化区别</a></li>
<li><a href="https://juejin.im/post/5a35ed25f265da431d3cc1b1" target="_blank" rel="noopener noreferrer nofollow">📝 轻松理解 JavaScript 函数节流和函数防抖</a></li>
</ul>
</article></div></main><script src="/_next/static/chunks/webpack-038c2e688b596d0e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5244,[],\"\"]\n3:I[3866,[],\"\"]\n5:I[6213,[],\"OutletBoundary\"]\n7:I[6213,[],\"MetadataBoundary\"]\n9:I[6213,[],\"ViewportBoundary\"]\nb:I[4835,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/ec0a9d078e716e00.css\",\"style\"]\n:HL[\"/_next/static/css/485ff6fe79292a08.css\",\"style\"]\n:HL[\"/_next/static/css/0ff121a467c0636f.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"ToCgoFiTXvECVEVLCeZww\",\"p\":\"\",\"c\":[\"\",\"front-end\",\"core-modules\",\"ecmascript-function-objects\",\"function-types\",\"throttle\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"front-end\",{\"children\":[[\"slug\",\"core-modules/ecmascript-function-objects/function-types/throttle\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/ec0a9d078e716e00.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"front-end\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/485ff6fe79292a08.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0ff121a467c0636f.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"main\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[[\"slug\",\"core-modules/ecmascript-function-objects/function-types/throttle\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"-KKuQ2Mt3XzlwGXI6P5tM\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:T3732,"])</script><script>self.__next_f.push([1,"\u003ch1\u003e函数节流\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e函数节流\u003c/strong\u003e：规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。简单来说，触发后立即执行，但如果要执行下一次，需要在离上次执行时间间隔设定时间后再出发才能执行。\u003c/p\u003e\n\u003cp\u003e🏕 \u003cstrong\u003e生活中的实例：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e我们知道目前的一种说法是当 1 秒内连续播放 24 张以上的图片时，在人眼的视觉中就会形成一个连贯的动画，所以在电影的播放中基本是以每秒 24 张的速度播放的，为什么不是 100 张或更多呢，主要是因为 24 张就可以满足人类视觉需求的时候，100 张就会显得很浪费资源。\u003c/p\u003e\n\u003ch2\u003e目的\u003c/h2\u003e\n\u003cp\u003e从字面上就可以理解，函数节流就是用来节流函数从而一定程度上优化性能的。\u003c/p\u003e\n\u003cp\u003e例如，DOM  操作比起非 DOM  交互需要占用更多的内存空间和消耗更多的 CPU  时间。连续尝试进行过多的 DOM  相关操作可能会导致浏览器卡顿，有时候甚至会崩溃。尤其在 IE  中使用 \u003ccode\u003eonresize\u003c/code\u003e  事件处理程序的时候容易发生，当调整浏览器大小的时候，该事件会连续触发。在 \u003ccode\u003eonresize\u003c/code\u003e  事件处理程序内部如果尝试进行 DOM  操作，其高频率的更改可能会让浏览器崩溃。\u003c/p\u003e\n\u003ch2\u003e代码实现\u003c/h2\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e/**\n * 实现函数的节流（目的是频繁触发中缩减频率）\n * \u003cspan class=\"hljs-doctag\"\u003e@param\u003c/span\u003e fn {Function} 实际要执行的函数\n * \u003cspan class=\"hljs-doctag\"\u003e@param\u003c/span\u003e wait {Number} 执行间隔，单位是毫秒(ms)，默认100ms\n * \u003cspan class=\"hljs-doctag\"\u003e@return\u003c/span\u003e {\u003cspan class=\"hljs-type\"\u003eFunction\u003c/span\u003e} 可被调用执行的函数\n */\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ethrottle\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efn, wait = \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 利用闭包保存定时器和上次执行时间\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 上次执行时间\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e timer = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e,\n    last;\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e...args\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e now = +\u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e();\n\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (last \u0026amp;\u0026amp; now \u0026lt; last + timeout) {\n      \u003cspan class=\"hljs-built_in\"\u003eclearTimeout\u003c/span\u003e(timer);\n      timer = \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n        last = now;\n        fun.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, args);\n      }, timeout);\n    } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n      last = now;\n      fn.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, args);\n    }\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e应用实践\u003c/h2\u003e\n\u003ch3\u003e原生实现应用\u003c/h3\u003e\n\u003cp\u003e首次点击按钮触发 \u003ccode\u003etrigger\u003c/code\u003e 函数，在 1000 毫秒内频繁点击按钮也不会再次执行 \u003ccode\u003etrigger\u003c/code\u003e 函数，直到 1000 毫秒之后再次点击才会再次执行 \u003ccode\u003etrigger\u003c/code\u003e 函数。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e button = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementById\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;button\u0026#x27;\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etrigger\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;click\u0026#x27;\u003c/span\u003e);\n}\n\nbutton.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;click\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003ethrottle\u003c/span\u003e(trigger, \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e));\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003eReact 应用\u003c/h3\u003e\n\u003cp\u003e在 React 中使用，下面监听窗口的 \u003ccode\u003eresize\u003c/code\u003e 和输入框的 \u003ccode\u003eonChange\u003c/code\u003e 事件：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e, { \u003cspan class=\"hljs-title class_\"\u003eComponent\u003c/span\u003e } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e { throttle } \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;@utils/throttle\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003edefault\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eclass\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eInvoke\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eextends\u003c/span\u003e \u003cspan class=\"hljs-title class_ inherited__\"\u003eComponent\u003c/span\u003e {\n  \u003cspan class=\"hljs-title function_\"\u003econstructor\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003esuper\u003c/span\u003e();\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003echange\u003c/span\u003e = \u003cspan class=\"hljs-title function_\"\u003ethrottle\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(e.\u003cspan class=\"hljs-property\"\u003etarget\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e);\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;throttle\u0026#x27;\u003c/span\u003e);\n    }, \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e);\n  }\n  \u003cspan class=\"hljs-title function_\"\u003ehandleWindowResize\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;resize\u0026#x27;\u003c/span\u003e);\n  }\n  \u003cspan class=\"hljs-title function_\"\u003ecomponentDidMount\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;resize\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003ethrottle\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ehandleWindowResize\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e));\n  }\n  \u003cspan class=\"hljs-title function_\"\u003ecomponentWillUnmount\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eremoveEvenetListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;resize\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-title function_\"\u003ethrottle\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ehandleWindowResize\u003c/span\u003e), \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e);\n  }\n  handleInputChange = \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// 持久化\u003c/span\u003e\n    e.\u003cspan class=\"hljs-title function_\"\u003epersist\u003c/span\u003e();\n    \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003echange\u003c/span\u003e(e);\n  };\n\n  \u003cspan class=\"hljs-title function_\"\u003erender\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003einput\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonChange\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{this.handleInputChange}\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其他框架库的实现：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/lodash/lodash/blob/master/throttle.js\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003eLodash - throttle\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://underscorejs.org/#throttle\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003eUnderscore - throttle\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e应用场景\u003c/h3\u003e\n\u003cp\u003e常见的高频触发监听事件的应用场景：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e动画场景：避免短时间内多次触发动画引起性能问题\u003c/li\u003e\n\u003cli\u003e拖拽场景：固定时间内只执行一次，防止超高频次触发位置变动（\u003ccode\u003emousemove\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e缩放场景：监控浏览器窗口大小（\u003ccode\u003eresize\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003e滚轮场景：鼠标滚轮事件（\u003ccode\u003ewheel\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003eCanvas 画笔功能\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e总结：适合大量事件按时间做平均分配触发\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003ch2\u003e应用实践\u003c/h2\u003e\n\u003ch3\u003e页面滚动事件\u003c/h3\u003e\n\u003cp\u003e这里以判断页面是否滚动到底部为例，普通的做法就是监听 Window 对象的 \u003ccode\u003escroll\u003c/code\u003e 事件，然后在函数体中写入判断是否滚动到底部的逻辑。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e$(\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eon\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;scroll\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 判断是否滚动到底部的逻辑\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e pageHeight = $(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;body\u0026#x27;\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eheight\u003c/span\u003e(),\n    scrollTop = $(\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003escrollTop\u003c/span\u003e(),\n    winHeight = $(\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eheight\u003c/span\u003e(),\n    thresold = pageHeight - scrollTop - winHeight;\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (thresod \u0026gt; -\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e \u0026amp;\u0026amp; thresold \u0026lt;= \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;The end\u0026#x27;\u003c/span\u003e);\n  }\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这样做的一个缺点就是比较消耗性能，因为当在滚动的时候，浏览器会无时无刻地在计算判断是否滚动到底部的逻辑，而在实际场景中是不需要这么做的，在实际场景中可能是这样的：在滚动过程中，每隔一段时间再去计算这个判断逻辑。而函数节流所做的工作就是每隔一段时间去执行一次原本需要无时无刻地在执行的函数，所以在滚动事件中引入函数的节流是一个非常好的实践。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e$(\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eon\u003c/span\u003e(\n  \u003cspan class=\"hljs-string\"\u003e\u0026#x27;scroll\u0026#x27;\u003c/span\u003e,\n  \u003cspan class=\"hljs-title function_\"\u003ethrottle\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 判断是否滚动到底部的逻辑\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e pageHeight = $(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;body\u0026#x27;\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eheight\u003c/span\u003e(),\n      scrollTop = $(\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003escrollTop\u003c/span\u003e(),\n      winHeight = $(\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003eheight\u003c/span\u003e(),\n      thresold = pageHeight - scrollTop - winHeight;\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (thresold \u0026gt; -\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e \u0026amp;\u0026amp; thresold \u0026lt;= \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e) {\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;end\u0026#x27;\u003c/span\u003e);\n    }\n  }, \u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e)\n);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e加入函数节流之后，当页面再滚动的时候，每隔 300ms 才会执行一次判断逻辑。\u003c/p\u003e\n\u003cp\u003e简单来说，函数的节流就是通过闭包保存一个标记（通常是定时器标识），在函数的开头判断这个标记是否为 \u003ccode\u003etrue\u003c/code\u003e ，如果为 \u003ccode\u003etrue\u003c/code\u003e 的话就继续执行函数，否则则 \u003ccode\u003ereturn\u003c/code\u003e 掉，判断完标记后立即把这个标记设为 \u003ccode\u003efalse\u003c/code\u003e ，然后把外部传入的函数的执行包在一个 \u003ccode\u003esetTimeout\u003c/code\u003e 中，最后在 \u003ccode\u003esetTimeout\u003c/code\u003e 执行完毕后再把标记设置为 \u003ccode\u003etrue\u003c/code\u003e （这里很关键），表示可以执行下一次的循环了。当 \u003ccode\u003esetTimeout\u003c/code\u003e 还未执行的时候，\u003ccode\u003ecanRun\u003c/code\u003e 这个标记始终为 \u003ccode\u003efalse\u003c/code\u003e，在开头的判断中被 \u003ccode\u003ereturn\u003c/code\u003e 掉。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ethrottle\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efn, interval = \u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e canRun = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!canRun) \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e;\n    canRun = \u003cspan class=\"hljs-literal\"\u003efalse\u003c/span\u003e;\n    \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n      fn.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003earguments\u003c/span\u003e);\n      canRun = \u003cspan class=\"hljs-literal\"\u003etrue\u003c/span\u003e;\n    }, interval);\n  };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e参考资料\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://demo.nimius.net/debounce_throttle/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 函数节流和函数防抖的可视化区别\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.im/post/5a35ed25f265da431d3cc1b1\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 轻松理解 JavaScript 函数节流和函数防抖\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"markdown-body\",\"children\":[[\"$\",\"h1\",null,{\"children\":\"函数节流\"}],[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"front-end\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"front-end knowledge\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>