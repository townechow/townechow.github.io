<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/ec0a9d078e716e00.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/485ff6fe79292a08.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/0ff121a467c0636f.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-53834dba86d90934.js"/><script src="/_next/static/chunks/4bd1b696-20882bf820444624.js" async=""></script><script src="/_next/static/chunks/517-98ed787e5f259f2c.js" async=""></script><script src="/_next/static/chunks/main-app-f33d3e3aed85e21f.js" async=""></script><meta name="next-size-adjust" content=""/><title>front-end</title><meta name="description" content="front-end knowledge"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><main><div class="markdown-body"><article><h1>高阶函数</h1>
<p><strong>高阶函数</strong> 指操作函数的函数，一般地，有以下两种情况：</p>
<ol>
<li>函数可以作为参数被传递</li>
<li>函数可以作为返回值输出</li>
</ol>
<p>JavaScript 中的函数显然满足高阶函数的条件，在实际开发中，无论是将函数当作参数传递，还是让函数的执行结果返回另外一个函数，这两种情形都有很多应用场景。</p>
<h2>作为参数传递</h2>
<p>把函数当作参数传递，代表可以抽离出一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中，这样一来可以分离业务代码中变化与不变的部分。</p>
<h3>回调函数</h3>
<p>其中一个常见的应用场景就是回调函数。</p>
<ul>
<li>在 AJAX 异步请求的过程中，回调函数使用得非常频繁</li>
<li>在不确定请求返回的时间时，将 <code>callback</code> 回调函数当作参数传入</li>
<li>待请求完成后执行 <code>callback</code> 函数</li>
</ul>
<p>🌰 <strong>代码示例</strong></p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> getUserInfo = <span class="hljs-keyword">function</span> (<span class="hljs-params">userId, callback</span>) {
  $.<span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;http://example.com/getUserInfo?&#x27;</span> + userId, <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) {
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">&#x27;function&#x27;</span>) {
      <span class="hljs-title function_">callback</span>(data);
    }
  });
};

<span class="hljs-title function_">getUserInfo</span>(<span class="hljs-number">123</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data.<span class="hljs-property">userName</span>);
});
</code></pre>
<p>回调函数的应用不仅只在异步请求中，当一个函数不适合执行一些请求时，也可以把这些请求封装成一个函数，并把它作为参数传递给另外一个函数，<strong>委托</strong> 给另外一个函数来执行。</p>
<p>比如，想在页面中创建 100 个 <code>div</code> 节点，然后把这些 <code>div</code> 节点都设置为隐藏。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> appendDiv = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
    <span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);
    div.<span class="hljs-property">innerHTML</span> = i;
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(div);
    div.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&#x27;none&#x27;</span>;
  }
};
<span class="hljs-title function_">appendDiv</span>();
</code></pre>
<p>把 <code>div.style.display = 'none'</code> 的逻辑硬编码在 <code>appendDiv</code> 里显然是不合理的，<code>appendDiv</code> 未免有点个性化，成为了一个难以复用的函数，并不是每个人创建了节点之后就希望它们立刻被隐藏。</p>
<p>于是把 <code>div.style.display = 'none'</code> 这行代码抽出来，用回调函数的形式传入 <code>appendDiv</code> 方法</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> appendDiv = <span class="hljs-keyword">function</span> (<span class="hljs-params">callback</span>) {
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) {
    <span class="hljs-keyword">const</span> div = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;div&#x27;</span>);
    div.<span class="hljs-property">innerHTML</span> = i;
    <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(div);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">&#x27;function&#x27;</span>) {
      <span class="hljs-title function_">callback</span>(div);
    }
  }
};

<span class="hljs-title function_">appendDiv</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) {
  node.<span class="hljs-property">style</span>.<span class="hljs-property">display</span> = <span class="hljs-string">&#x27;none&#x27;</span>;
});
</code></pre>
<p>可以看到，隐藏节点的请求实际上是由客户发起的，但是客户并不知道节点什么时候会创建好，于是把隐藏节点的逻辑放在回调函数中，<strong>委托</strong> 给 <code>appendDiv</code> 方法。<code>appendDiv</code> 方法当然知道节点什么时候创建好，所以在节点创建好的时候，<code>appendDiv</code> 会执行之前客户传入的回调函数。</p>
<h3>数组排序</h3>
<p>函数作为参数传递的另一个常见场景是数组排序函数 <code>sort()</code>。<code>Array.prototype.sort</code> 接受一个函数当作参数，这个函数里面封装了数组元素的排序方法。目的是对数组进行排序，这是不变的部分；而使用什么规则去排序，则是可变的部分。把可变的部分封装在函数参数里，动态传入 <code>Array.prototype.sort</code>，使 <code>Array.prototype.sort</code> 方法成为了一个非常灵活的方法。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 从小到大排列，输出: [ 1, 3, 4 ]</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) {
  <span class="hljs-keyword">return</span> a - b;
});

<span class="hljs-comment">// 从大到小排列，输出: [ 4, 3, 1 ]</span>
[<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>].<span class="hljs-title function_">sort</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) {
  <span class="hljs-keyword">return</span> b - a;
});
</code></pre>
<h2>作为返回值输出</h2>
<p>相比把函数当作参数传递，函数当作返回值输出的应用场景也有很多。让函数继续返回一个可执行的函数，意味着运算过程是可延续的。</p>
<p>下面是使用 <code>Object.prototype.toString</code> 方法判断数据类型的一系列的 <code>isType</code> 函数</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">let</span> isString = <span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj) === <span class="hljs-string">&#x27;[object String]&#x27;</span>;
};

<span class="hljs-keyword">let</span> isArray = <span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj) === <span class="hljs-string">&#x27;[object Array]&#x27;</span>;
};

<span class="hljs-keyword">let</span> isNumber = <span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj) === <span class="hljs-string">&#x27;[object Number]&#x27;</span>;
};
</code></pre>
<p>实际上，这些函数的大部分实现都是相同的，不同的只是 <code>Object.prototype.toString.call(obj)</code> 返回的字符串。为了避免多余的代码，可以把这些字符串作为参数提前传入 <code>isType</code> 函数。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">let</span> isType = <span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj) === <span class="hljs-string">&#x27;[object &#x27;</span> + type + <span class="hljs-string">&#x27;]&#x27;</span>;
  };
};

<span class="hljs-keyword">const</span> isString = <span class="hljs-title function_">isType</span>(<span class="hljs-string">&#x27;String&#x27;</span>);
<span class="hljs-keyword">const</span> isArray = <span class="hljs-title function_">isType</span>(<span class="hljs-string">&#x27;Array&#x27;</span>);
<span class="hljs-keyword">const</span> isNumber = <span class="hljs-title function_">isType</span>(<span class="hljs-string">&#x27;Number&#x27;</span>);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isArray</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]));
<span class="hljs-comment">// true</span>
</code></pre>
<p>其实上面实现的 isType 函数，也属于<strong>偏函数</strong>的范畴，偏函数实际上是返回了一个包含<strong>预处理参数</strong>的新函数，以便后续逻辑可以调用。</p>
<p>当然，还可以用循环语句，来批量注册这些 <code>isType</code> 函数：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">let</span> <span class="hljs-title class_">Type</span> = {};
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, type; (type = [<span class="hljs-string">&#x27;String&#x27;</span>, <span class="hljs-string">&#x27;Array&#x27;</span>, <span class="hljs-string">&#x27;Number&#x27;</span>][i++]); ) {
  (<span class="hljs-keyword">function</span> (<span class="hljs-params">type</span>) {
    <span class="hljs-title class_">Type</span>[<span class="hljs-string">&#x27;is&#x27;</span> + type] = <span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) {
      <span class="hljs-keyword">return</span> <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(obj) === <span class="hljs-string">&#x27;[object &#x27;</span> + type + <span class="hljs-string">&#x27;]&#x27;</span>;
    };
  })(type);
}

<span class="hljs-title class_">Type</span>.<span class="hljs-title function_">isArray</span>([]);
<span class="hljs-comment">// true</span>
<span class="hljs-title class_">Type</span>.<span class="hljs-title function_">isString</span>(<span class="hljs-string">&#x27;str&#x27;</span>);
<span class="hljs-comment">// true</span>
</code></pre>
<h2>AOP 面向切面编程</h2>
<p>AOP 即面向切面编程，它的主要作用是 <strong>把一些跟核心业务逻辑模块无关的功能抽离出来</strong>，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后，再通过 <strong>动态织入</strong> 的方式掺入业务逻辑模块中。这样做的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。</p>
<p>通常，在 JavaScript 中实现 AOP，都是指把一个函数 <strong>动态织入</strong> 到另外一个函数之中。下面通过扩展 <code>Function.prototype</code> 来实现</p>
<pre class="hljs"><code class="language-js"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">before</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">beforefn</span>) {
  <span class="hljs-comment">// 保存原函数的引用</span>
  <span class="hljs-keyword">const</span> _this = <span class="hljs-variable language_">this</span>;

  <span class="hljs-comment">// 返回包含了原函数和新函数的 &quot;代理&quot; 函数</span>
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 先执行新函数，修正 this</span>
    beforefn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);

    <span class="hljs-comment">// 再执行原函数</span>
    <span class="hljs-keyword">return</span> _this.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);
  };
};

<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">after</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">afterfn</span>) {
  <span class="hljs-keyword">const</span> _this = <span class="hljs-variable language_">this</span>;

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 先执行原函数</span>
    <span class="hljs-keyword">const</span> result = _this.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);

    <span class="hljs-comment">// 再执行新函数</span>
    afterfn.<span class="hljs-title function_">apply</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-variable language_">arguments</span>);

    <span class="hljs-keyword">return</span> result;
  };
};

<span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);
};

fn = fn
  .<span class="hljs-title function_">before</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);
  })
  .<span class="hljs-title function_">after</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);
  });

<span class="hljs-title function_">fn</span>();
<span class="hljs-comment">// 1 2 3</span>
</code></pre>
<p>把负责输出数字 1 和输出数字 3 的两个函数通过 AOP 的方式动态植入 <code>fn</code> 函数。</p>
<p>通过执行上面的代码，控制台顺利地返回了执行结果 1、2、3。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> service = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;功能逻辑&#x27;</span>);
};

<span class="hljs-keyword">const</span> proxyMethod = (<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> startTime;

  <span class="hljs-keyword">return</span> {
    <span class="hljs-attr">before</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      startTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();

      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;计时开始&#x27;</span>);
    },
    <span class="hljs-attr">after</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-keyword">const</span> endTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() - startTime;

      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;计时结束，用时：&#x27;</span> + endTime);
    },
  };
})();

<span class="hljs-keyword">const</span> aop = <span class="hljs-keyword">function</span> (<span class="hljs-params">fn, proxy</span>) {
  proxy.<span class="hljs-property">before</span> &amp;&amp; proxy.<span class="hljs-title function_">before</span>();

  <span class="hljs-title function_">fn</span>();

  proxy.<span class="hljs-property">after</span> &amp;&amp; proxy.<span class="hljs-title function_">after</span>();
};

<span class="hljs-title function_">aop</span>(service, proxyMethod);
<span class="hljs-comment">// 计时开始</span>
<span class="hljs-comment">// 功能逻辑</span>
<span class="hljs-comment">// 计时结束：1</span>
</code></pre>
<h2>其他应用</h2>
<ul>
<li><a href="/front-end/core-modules/ecmascript-function-objects/function-types/function-currying">函数柯里化</a></li>
<li><a href="/front-end/core-modules/ecmascript-function-objects/function-types/function-currying#%E5%8F%8D%E6%9F%AF%E9%87%8C%E5%8C%96">反柯里化</a></li>
<li><a href="/front-end/core-modules/ecmascript-function-objects/function-types/throttle">函数节流</a></li>
<li><a href="/front-end/core-modules/ecmascript-function-objects/function-types/debounce">函数防抖</a></li>
</ul>
<hr>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://juejin.im/entry/5815876c8ac247004fb6d132" target="_blank" rel="noopener noreferrer nofollow">📝 高阶函数介绍</a></li>
</ul>
</article></div></main><script src="/_next/static/chunks/webpack-53834dba86d90934.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5244,[],\"\"]\n3:I[3866,[],\"\"]\n5:I[6213,[],\"OutletBoundary\"]\n7:I[6213,[],\"MetadataBoundary\"]\n9:I[6213,[],\"ViewportBoundary\"]\nb:I[4835,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/ec0a9d078e716e00.css\",\"style\"]\n:HL[\"/_next/static/css/485ff6fe79292a08.css\",\"style\"]\n:HL[\"/_next/static/css/0ff121a467c0636f.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"NW9bMA21iAaih0TqCHqj1\",\"p\":\"\",\"c\":[\"\",\"front-end\",\"core-modules\",\"ecmascript-function-objects\",\"function-types\",\"hight-order-function\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"front-end\",{\"children\":[[\"slug\",\"core-modules/ecmascript-function-objects/function-types/hight-order-function\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/ec0a9d078e716e00.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"front-end\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/485ff6fe79292a08.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0ff121a467c0636f.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"main\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[[\"slug\",\"core-modules/ecmascript-function-objects/function-types/hight-order-function\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"in68fq_P-0dDZvm7A59pC\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:T4b4b,"])</script><script>self.__next_f.push([1,"\u003ch1\u003e高阶函数\u003c/h1\u003e\n\u003cp\u003e\u003cstrong\u003e高阶函数\u003c/strong\u003e 指操作函数的函数，一般地，有以下两种情况：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e函数可以作为参数被传递\u003c/li\u003e\n\u003cli\u003e函数可以作为返回值输出\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003eJavaScript 中的函数显然满足高阶函数的条件，在实际开发中，无论是将函数当作参数传递，还是让函数的执行结果返回另外一个函数，这两种情形都有很多应用场景。\u003c/p\u003e\n\u003ch2\u003e作为参数传递\u003c/h2\u003e\n\u003cp\u003e把函数当作参数传递，代表可以抽离出一部分容易变化的业务逻辑，把这部分业务逻辑放在函数参数中，这样一来可以分离业务代码中变化与不变的部分。\u003c/p\u003e\n\u003ch3\u003e回调函数\u003c/h3\u003e\n\u003cp\u003e其中一个常见的应用场景就是回调函数。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在 AJAX 异步请求的过程中，回调函数使用得非常频繁\u003c/li\u003e\n\u003cli\u003e在不确定请求返回的时间时，将 \u003ccode\u003ecallback\u003c/code\u003e 回调函数当作参数传入\u003c/li\u003e\n\u003cli\u003e待请求完成后执行 \u003ccode\u003ecallback\u003c/code\u003e 函数\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e🌰 \u003cstrong\u003e代码示例\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e getUserInfo = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003euserId, callback\u003c/span\u003e) {\n  $.\u003cspan class=\"hljs-title function_\"\u003eajax\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;http://example.com/getUserInfo?\u0026#x27;\u003c/span\u003e + userId, \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e callback === \u003cspan class=\"hljs-string\"\u003e\u0026#x27;function\u0026#x27;\u003c/span\u003e) {\n      \u003cspan class=\"hljs-title function_\"\u003ecallback\u003c/span\u003e(data);\n    }\n  });\n};\n\n\u003cspan class=\"hljs-title function_\"\u003egetUserInfo\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e123\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(data.\u003cspan class=\"hljs-property\"\u003euserName\u003c/span\u003e);\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e回调函数的应用不仅只在异步请求中，当一个函数不适合执行一些请求时，也可以把这些请求封装成一个函数，并把它作为参数传递给另外一个函数，\u003cstrong\u003e委托\u003c/strong\u003e 给另外一个函数来执行。\u003c/p\u003e\n\u003cp\u003e比如，想在页面中创建 100 个 \u003ccode\u003ediv\u003c/code\u003e 节点，然后把这些 \u003ccode\u003ediv\u003c/code\u003e 节点都设置为隐藏。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e appendDiv = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e; i++) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e div = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateElement\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;div\u0026#x27;\u003c/span\u003e);\n    div.\u003cspan class=\"hljs-property\"\u003einnerHTML\u003c/span\u003e = i;\n    \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eappendChild\u003c/span\u003e(div);\n    div.\u003cspan class=\"hljs-property\"\u003estyle\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edisplay\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;none\u0026#x27;\u003c/span\u003e;\n  }\n};\n\u003cspan class=\"hljs-title function_\"\u003eappendDiv\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e把 \u003ccode\u003ediv.style.display = 'none'\u003c/code\u003e 的逻辑硬编码在 \u003ccode\u003eappendDiv\u003c/code\u003e 里显然是不合理的，\u003ccode\u003eappendDiv\u003c/code\u003e 未免有点个性化，成为了一个难以复用的函数，并不是每个人创建了节点之后就希望它们立刻被隐藏。\u003c/p\u003e\n\u003cp\u003e于是把 \u003ccode\u003ediv.style.display = 'none'\u003c/code\u003e 这行代码抽出来，用回调函数的形式传入 \u003ccode\u003eappendDiv\u003c/code\u003e 方法\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e appendDiv = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003ecallback\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e; i++) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e div = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateElement\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;div\u0026#x27;\u003c/span\u003e);\n    div.\u003cspan class=\"hljs-property\"\u003einnerHTML\u003c/span\u003e = i;\n    \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ebody\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eappendChild\u003c/span\u003e(div);\n    \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e callback === \u003cspan class=\"hljs-string\"\u003e\u0026#x27;function\u0026#x27;\u003c/span\u003e) {\n      \u003cspan class=\"hljs-title function_\"\u003ecallback\u003c/span\u003e(div);\n    }\n  }\n};\n\n\u003cspan class=\"hljs-title function_\"\u003eappendDiv\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003enode\u003c/span\u003e) {\n  node.\u003cspan class=\"hljs-property\"\u003estyle\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edisplay\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;none\u0026#x27;\u003c/span\u003e;\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到，隐藏节点的请求实际上是由客户发起的，但是客户并不知道节点什么时候会创建好，于是把隐藏节点的逻辑放在回调函数中，\u003cstrong\u003e委托\u003c/strong\u003e 给 \u003ccode\u003eappendDiv\u003c/code\u003e 方法。\u003ccode\u003eappendDiv\u003c/code\u003e 方法当然知道节点什么时候创建好，所以在节点创建好的时候，\u003ccode\u003eappendDiv\u003c/code\u003e 会执行之前客户传入的回调函数。\u003c/p\u003e\n\u003ch3\u003e数组排序\u003c/h3\u003e\n\u003cp\u003e函数作为参数传递的另一个常见场景是数组排序函数 \u003ccode\u003esort()\u003c/code\u003e。\u003ccode\u003eArray.prototype.sort\u003c/code\u003e 接受一个函数当作参数，这个函数里面封装了数组元素的排序方法。目的是对数组进行排序，这是不变的部分；而使用什么规则去排序，则是可变的部分。把可变的部分封装在函数参数里，动态传入 \u003ccode\u003eArray.prototype.sort\u003c/code\u003e，使 \u003ccode\u003eArray.prototype.sort\u003c/code\u003e 方法成为了一个非常灵活的方法。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 从小到大排列，输出: [ 1, 3, 4 ]\u003c/span\u003e\n[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003esort\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003ea, b\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e a - b;\n});\n\n\u003cspan class=\"hljs-comment\"\u003e// 从大到小排列，输出: [ 4, 3, 1 ]\u003c/span\u003e\n[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003esort\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003ea, b\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e b - a;\n});\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e作为返回值输出\u003c/h2\u003e\n\u003cp\u003e相比把函数当作参数传递，函数当作返回值输出的应用场景也有很多。让函数继续返回一个可执行的函数，意味着运算过程是可延续的。\u003c/p\u003e\n\u003cp\u003e下面是使用 \u003ccode\u003eObject.prototype.toString\u003c/code\u003e 方法判断数据类型的一系列的 \u003ccode\u003eisType\u003c/code\u003e 函数\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e isString = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eobj\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etoString\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(obj) === \u003cspan class=\"hljs-string\"\u003e\u0026#x27;[object String]\u0026#x27;\u003c/span\u003e;\n};\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e isArray = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eobj\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etoString\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(obj) === \u003cspan class=\"hljs-string\"\u003e\u0026#x27;[object Array]\u0026#x27;\u003c/span\u003e;\n};\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e isNumber = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eobj\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etoString\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(obj) === \u003cspan class=\"hljs-string\"\u003e\u0026#x27;[object Number]\u0026#x27;\u003c/span\u003e;\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e实际上，这些函数的大部分实现都是相同的，不同的只是 \u003ccode\u003eObject.prototype.toString.call(obj)\u003c/code\u003e 返回的字符串。为了避免多余的代码，可以把这些字符串作为参数提前传入 \u003ccode\u003eisType\u003c/code\u003e 函数。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e isType = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003etype\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eobj\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etoString\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(obj) === \u003cspan class=\"hljs-string\"\u003e\u0026#x27;[object \u0026#x27;\u003c/span\u003e + type + \u003cspan class=\"hljs-string\"\u003e\u0026#x27;]\u0026#x27;\u003c/span\u003e;\n  };\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isString = \u003cspan class=\"hljs-title function_\"\u003eisType\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;String\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isArray = \u003cspan class=\"hljs-title function_\"\u003eisType\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Array\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e isNumber = \u003cspan class=\"hljs-title function_\"\u003eisType\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Number\u0026#x27;\u003c/span\u003e);\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eisArray\u003c/span\u003e([\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e]));\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e其实上面实现的 isType 函数，也属于\u003cstrong\u003e偏函数\u003c/strong\u003e的范畴，偏函数实际上是返回了一个包含\u003cstrong\u003e预处理参数\u003c/strong\u003e的新函数，以便后续逻辑可以调用。\u003c/p\u003e\n\u003cp\u003e当然，还可以用循环语句，来批量注册这些 \u003ccode\u003eisType\u003c/code\u003e 函数：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eType\u003c/span\u003e = {};\n\u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, type; (type = [\u003cspan class=\"hljs-string\"\u003e\u0026#x27;String\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;Array\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;Number\u0026#x27;\u003c/span\u003e][i++]); ) {\n  (\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003etype\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title class_\"\u003eType\u003c/span\u003e[\u003cspan class=\"hljs-string\"\u003e\u0026#x27;is\u0026#x27;\u003c/span\u003e + type] = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eobj\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etoString\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(obj) === \u003cspan class=\"hljs-string\"\u003e\u0026#x27;[object \u0026#x27;\u003c/span\u003e + type + \u003cspan class=\"hljs-string\"\u003e\u0026#x27;]\u0026#x27;\u003c/span\u003e;\n    };\n  })(type);\n}\n\n\u003cspan class=\"hljs-title class_\"\u003eType\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eisArray\u003c/span\u003e([]);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eType\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eisString\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;str\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// true\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eAOP 面向切面编程\u003c/h2\u003e\n\u003cp\u003eAOP 即面向切面编程，它的主要作用是 \u003cstrong\u003e把一些跟核心业务逻辑模块无关的功能抽离出来\u003c/strong\u003e，这些跟业务逻辑无关的功能通常包括日志统计、安全控制、异常处理等。把这些功能抽离出来之后，再通过 \u003cstrong\u003e动态织入\u003c/strong\u003e 的方式掺入业务逻辑模块中。这样做的好处首先是可以保持业务逻辑模块的纯净和高内聚性，其次是可以很方便地复用日志统计等功能模块。\u003c/p\u003e\n\u003cp\u003e通常，在 JavaScript 中实现 AOP，都是指把一个函数 \u003cstrong\u003e动态织入\u003c/strong\u003e 到另外一个函数之中。下面通过扩展 \u003ccode\u003eFunction.prototype\u003c/code\u003e 来实现\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-title class_\"\u003eFunction\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ebefore\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003ebeforefn\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 保存原函数的引用\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e _this = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-comment\"\u003e// 返回包含了原函数和新函数的 \u0026quot;代理\u0026quot; 函数\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 先执行新函数，修正 this\u003c/span\u003e\n    beforefn.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 再执行原函数\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e _this.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e);\n  };\n};\n\n\u003cspan class=\"hljs-title class_\"\u003eFunction\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eafter\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eafterfn\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e _this = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 先执行原函数\u003c/span\u003e\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = _this.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-comment\"\u003e// 再执行新函数\u003c/span\u003e\n    afterfn.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e, \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e);\n\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result;\n  };\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fn = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n};\n\nfn = fn\n  .\u003cspan class=\"hljs-title function_\"\u003ebefore\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  })\n  .\u003cspan class=\"hljs-title function_\"\u003eafter\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n  });\n\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// 1 2 3\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e把负责输出数字 1 和输出数字 3 的两个函数通过 AOP 的方式动态植入 \u003ccode\u003efn\u003c/code\u003e 函数。\u003c/p\u003e\n\u003cp\u003e通过执行上面的代码，控制台顺利地返回了执行结果 1、2、3。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e service = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;功能逻辑\u0026#x27;\u003c/span\u003e);\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e proxyMethod = (\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e startTime;\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e {\n    \u003cspan class=\"hljs-attr\"\u003ebefore\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      startTime = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e();\n\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;计时开始\u0026#x27;\u003c/span\u003e);\n    },\n    \u003cspan class=\"hljs-attr\"\u003eafter\u003c/span\u003e: \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e endTime = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eDate\u003c/span\u003e() - startTime;\n\n      \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;计时结束，用时：\u0026#x27;\u003c/span\u003e + endTime);\n    },\n  };\n})();\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e aop = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003efn, proxy\u003c/span\u003e) {\n  proxy.\u003cspan class=\"hljs-property\"\u003ebefore\u003c/span\u003e \u0026amp;\u0026amp; proxy.\u003cspan class=\"hljs-title function_\"\u003ebefore\u003c/span\u003e();\n\n  \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e();\n\n  proxy.\u003cspan class=\"hljs-property\"\u003eafter\u003c/span\u003e \u0026amp;\u0026amp; proxy.\u003cspan class=\"hljs-title function_\"\u003eafter\u003c/span\u003e();\n};\n\n\u003cspan class=\"hljs-title function_\"\u003eaop\u003c/span\u003e(service, proxyMethod);\n\u003cspan class=\"hljs-comment\"\u003e// 计时开始\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 功能逻辑\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 计时结束：1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e其他应用\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/front-end/core-modules/ecmascript-function-objects/function-types/function-currying\"\u003e函数柯里化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/front-end/core-modules/ecmascript-function-objects/function-types/function-currying#%E5%8F%8D%E6%9F%AF%E9%87%8C%E5%8C%96\"\u003e反柯里化\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/front-end/core-modules/ecmascript-function-objects/function-types/throttle\"\u003e函数节流\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/front-end/core-modules/ecmascript-function-objects/function-types/debounce\"\u003e函数防抖\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e参考资料：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.im/entry/5815876c8ac247004fb6d132\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 高阶函数介绍\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"markdown-body\",\"children\":[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"front-end\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"front-end knowledge\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>