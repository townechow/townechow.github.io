1:"$Sreact.fragment"
2:I[5244,[],""]
3:I[3866,[],""]
5:I[6213,[],"OutletBoundary"]
7:I[6213,[],"MetadataBoundary"]
9:I[6213,[],"ViewportBoundary"]
b:I[4835,[],""]
:HL["/_next/static/media/569ce4b8f30dc480-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/ec0a9d078e716e00.css","style"]
:HL["/_next/static/css/485ff6fe79292a08.css","style"]
:HL["/_next/static/css/0ff121a467c0636f.css","style"]
0:{"P":null,"b":"NW9bMA21iAaih0TqCHqj1","p":"","c":["","front-end","core-modules","ecmascript-function-objects","function-arguments","function-parameters"],"i":false,"f":[[["",{"children":["front-end",{"children":[["slug","core-modules/ecmascript-function-objects/function-arguments/function-parameters","oc"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/ec0a9d078e716e00.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__variable_4d318d __variable_ea5f4b antialiased","children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[],[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]]}],{"children":["front-end",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/485ff6fe79292a08.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/0ff121a467c0636f.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","main",null,{"children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","front-end","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]}]]}],{"children":[["slug","core-modules/ecmascript-function-objects/function-arguments/function-parameters","oc"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","front-end","children","$0:f:0:1:2:children:2:children:0","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L4",null,["$","$L5",null,{"children":"$L6"}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","2XaWLgfzyaHhbtPsaKmhG",{"children":[["$","$L7",null,{"children":"$L8"}],["$","$L9",null,{"children":"$La"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}]]}],false]],"m":"$undefined","G":["$b","$undefined"],"s":false,"S":true}
c:T675b,<h1>函数参数</h1>
<h2>arguments</h2>
<p>JavaScript 中的函数定义并未指定函数形参的类型，函数调用也未对传入的实参值做任何类型检查。实际上，JavaScript 函数调用甚至不检查传入形参的个数。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>;
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>));
<span class="hljs-comment">// 2</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">foo</span>(<span class="hljs-string">&#x27;1&#x27;</span>));
<span class="hljs-comment">// &#x27;11&#x27;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">foo</span>());
<span class="hljs-comment">// NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));
<span class="hljs-comment">// 2</span>
</code></pre>
<h3>同名形参</h3>
<p>在非严格模式下，函数中可以出现同名形参，且只能访问最后出现的该名称的形参。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x, x, x</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);
}

<span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">// 3</span>
</code></pre>
<p>而在严格模式下，出现同名形参会抛出语法错误。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x, x, x</span>) {
  <span class="hljs-string">&#x27;use strict&#x27;</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);
}

<span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">// SyntaxError: Duplicate parameter name not allowed in this context</span>
</code></pre>
<h3>参数数量</h3>
<p>当实参比函数声明指定的形参个数要少，剩下的形参都将设置为 <code>undefined</code> 值。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x, y</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y);
  <span class="hljs-comment">// 1 undefined</span>
}

<span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>);
</code></pre>
<p><strong>默认值设置：</strong></p>
<p>常常使用逻辑或运算符给省略的参数设置一个合理的默认值。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x, y</span>) {
  y = y || <span class="hljs-number">2</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y);
  <span class="hljs-comment">// 1 2</span>
}

<span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>);
</code></pre>
<p>实际上，使用 <code>y || 2</code> 是不严谨的，显式地设置假值(<code>undefined</code>、<code>null</code>、<code>false</code>、<code>0</code>、<code>-0</code>、<code>''</code>、<code>NaN</code>)也会得到相同的结果。所以应该根据实际场景进行合理设置。</p>
<p>当实参比形参个数要多时，剩下的实参没有办法直接获得，需要使用即将提到的 <code>arguments</code> 对象。</p>
<p>JavaScript 中的参数在内部用一个数组表示。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数。在函数体内可以通过 <code>arguments</code> 对象来访问这个参数数组，从而获取传递给函数的每一个参数。</p>
<p><code>arguments</code> 对象并不是 <code>Array</code> 的实例，它是一个类数组对象，可以使用方括号语法访问它的每一个元素。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>], <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>], <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">2</span>]);
  <span class="hljs-comment">// 1 2 3</span>
  <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>;
}
<span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
</code></pre>
<p><code>arguments</code> 对象的 <code>length</code> 属性显示实参的个数，函数的 <code>length</code> 属性显示形参的个数。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x, y</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>);
  <span class="hljs-comment">// 3</span>
}

<span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fn.<span class="hljs-property">length</span>);
<span class="hljs-comment">// 2</span>
</code></pre>
<p>形参只是提供便利，但不是必需的。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);
  <span class="hljs-comment">// 1</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);
  <span class="hljs-comment">// 2</span>
}
</code></pre>
<p>当一个函数包含超过 3 个形参时，要记住调用函数中实参的正确顺序实在让人头疼。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">
  <span class="hljs-comment">/*array*/</span> <span class="hljs-keyword">from</span>,
  <span class="hljs-comment">/*index*/</span> form_start,
  <span class="hljs-comment">/*array*/</span> to,
  <span class="hljs-comment">/*index*/</span> to_start,
  <span class="hljs-comment">/*integer*/</span> length
</span>) {
  <span class="hljs-comment">// do something</span>
}
</code></pre>
<p>通过键/值对的形式来传入参数，这样参数的顺序就无关紧要了。定义函数的时候，传入的实参都写入一个单独的对象之中，在调用的时候传入一个对象，对象中的名/值对是真正需要的实参数据。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">args</span>) {
  <span class="hljs-title function_">fn</span>(args.<span class="hljs-property">from</span>, args.<span class="hljs-property">from_start</span> || <span class="hljs-number">0</span>, args.<span class="hljs-property">to</span>, args.<span class="hljs-property">to_start</span> || <span class="hljs-number">0</span>, args.<span class="hljs-property">length</span>);
}

<span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],
  b = [];

<span class="hljs-title function_">fn</span>({ <span class="hljs-attr">from</span>: a, <span class="hljs-attr">to</span>: b, <span class="hljs-attr">length</span>: <span class="hljs-number">4</span> });
</code></pre>
<p>ES6 的 <a href="/front-end/core-modules/ecmascript-function-objects/function-arguments/rest-parameters">剩余参数（Rest 参数）</a> 有效地解决了函数参数过多和参数先后顺序的问题。</p>
<h3>同步</h3>
<p>当形参与实参的个数相同时，<code>arguments</code> 对象的值和对应形参的值保持同步。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">num1, num2</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1, <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);
  <span class="hljs-comment">// 1 1</span>

  <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1, <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);
  <span class="hljs-comment">// 2 2</span>

  num1 = <span class="hljs-number">10</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1, <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);
  <span class="hljs-comment">// 10 10</span>
}

<span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>);
</code></pre>
<p>虽然命名参数和对应 <code>arguments</code> 对象的值相同，但并不是相同的命名空间。它们的命名空间是独立的，但值是同步的。</p>
<p>但在严格模式下，<code>arguments</code> 对象的值和形参的值是独立的。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">num1, num2</span>) {
  <span class="hljs-string">&#x27;use strict&#x27;</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1, <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);
  <span class="hljs-comment">// 1 1</span>

  <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1, <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);
  <span class="hljs-comment">// 1 2</span>

  num1 = <span class="hljs-number">10</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1, <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);
  <span class="hljs-comment">// 10 2</span>
}

<span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>);
</code></pre>
<p>当形参并没有对应的实参时，<code>arguments</code> 对象的值与形参的值并不对应。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">num1, num2</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1, <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">//undefined,undefined</span>

  num1 = <span class="hljs-number">10</span>;

  <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>;

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1, <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">//10,5</span>
}

<span class="hljs-title function_">fn</span>();
</code></pre>
<h2>内部属性</h2>
<h3>callee</h3>
<p><code>arguments</code> 对象有一个名为 <code>callee</code> 的属性，该属性是一个指针，指向拥有这个 <code>arguments</code> 对象的函数。</p>
<p>下面是经典的阶乘函数：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> num * <span class="hljs-title function_">fn</span>(num - <span class="hljs-number">1</span>);
  }
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 120</span>
</code></pre>
<p>但是，上面这个函数的执行与函数名紧紧耦合在了一起，可以使用 <code>arguments.callee</code> 可以消除函数解耦。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> num * <span class="hljs-variable language_">arguments</span>.<span class="hljs-title function_">callee</span>(num - <span class="hljs-number">1</span>);
  }
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-number">5</span>));
<span class="hljs-comment">// 120</span>
</code></pre>
<p>但在严格模式下，访问这个属性会抛出 TypeError 错误。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-string">&#x27;use strict&#x27;</span>;
  <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> num * <span class="hljs-variable language_">arguments</span>.<span class="hljs-title function_">callee</span>(num - <span class="hljs-number">1</span>);
  }
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-number">5</span>));
<span class="hljs-comment">// TypeError: &#x27;caller&#x27;, &#x27;callee&#x27;, and &#x27;arguments&#x27; properties may not be accessed on strict mode functions or the arguments objects for calls to them</span>
</code></pre>
<p>这时，可以使用具名的函数表达式。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> num * <span class="hljs-title function_">fn</span>(num - <span class="hljs-number">1</span>);
  }
};
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">//120</span>
</code></pre>
<h3>caller</h3>
<p>实际上有两个 <code>caller</code> 属性。</p>
<h4>函数的 caller</h4>
<p>函数的 <code>caller</code> 属性保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值是 <code>null</code>。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">bar</span>();
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar.<span class="hljs-property">caller</span>);
  <span class="hljs-comment">// foo(){ bar(); }</span>
}

<span class="hljs-title function_">foo</span>();
</code></pre>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">caller</span>);
  <span class="hljs-comment">// null</span>
}
<span class="hljs-title function_">foo</span>();
</code></pre>
<p>在严格模式下，访问这个属性会抛出 TypeError 错误。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-string">&#x27;use strict&#x27;</span>;
  <span class="hljs-comment">// TypeError: &#x27;caller&#x27; and &#x27;arguments&#x27; are restricted function properties and cannot be accessed in this context</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">caller</span>);
}
<span class="hljs-title function_">foo</span>();
</code></pre>
<h4>arguments 对象的 caller</h4>
<p>该属性始终是 <code>undefined</code>，定义这个属性是为了分清 <code>arguments.caller</code> 和函数的 <code>caller</code> 属性。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">caller</span>);
  <span class="hljs-comment">// undefined</span>
}
<span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>);
</code></pre>
<p>同样地，在严格模式下，访问这个属性会抛出 TypeError 错误。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-string">&#x27;use strict&#x27;</span>;
  <span class="hljs-comment">// TypeError: &#x27;caller&#x27; and &#x27;arguments&#x27; are restricted function properties and cannot be accessed in this context</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">caller</span>);
}
<span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>);
</code></pre>
<h2>参数传递</h2>
<p>JavaScript 中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制到函数内部的参数，就和把值从一个变量复制到另一个变量一样。</p>
<h3>基本类型值</h3>
<p>在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（命名参数或 <code>arguments</code> 对象的一个元素）</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) {
  x = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">return</span> x;
}
<span class="hljs-keyword">let</span> y = <span class="hljs-number">2</span>;
<span class="hljs-keyword">let</span> result = <span class="hljs-title function_">foo</span>(y);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y);
<span class="hljs-comment">// 2 没有变化</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);
<span class="hljs-comment">// 1</span>
</code></pre>
<h3>引用类型值</h3>
<p>在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) {
  x.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;ABC&#x27;</span>;
}

<span class="hljs-keyword">var</span> y = {};
<span class="hljs-title function_">foo</span>(y);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y.<span class="hljs-property">name</span>);
<span class="hljs-comment">// &#x27;ABC&#x27;</span>
</code></pre>
<p>当在函数内部重写引用类型的形参时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">obj</span>) {
  obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;black&#x27;</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;black&#x27;</span>

  obj = {};
  obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;white&#x27;</span>;

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;black&#x27;</span>
}

<span class="hljs-keyword">var</span> person = {};
<span class="hljs-title function_">foo</span>(person);
</code></pre>
<h2>函数重载</h2>
<p>JavaScript 函数不能像传统意义上那样实现重载。而在其他语言中，可以为一个函数编写两个定义，只要这两个定义的签名（接受的参数的类型和数量）不同即可。</p>
<p>JavaScript 函数没有签名，因为其参数是由包含零个或多个值的数组来表示的。而没有函数签名，真正的重载是不可能做到的。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 后面的声明覆盖了前面的声明</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">addSomeNumber</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">return</span> num + <span class="hljs-number">100</span>;
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">addSomeNumber</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">return</span> num + <span class="hljs-number">200</span>;
}
<span class="hljs-keyword">var</span> result = <span class="hljs-title function_">addSomeNumber</span>(<span class="hljs-number">100</span>);
<span class="hljs-comment">// 300</span>
</code></pre>
<p>只能通过检查传入函数中参数的类型和数量并作出不同的反应，来模仿方法的重载。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doAdd</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> == <span class="hljs-number">1</span>) {
    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] + <span class="hljs-number">10</span>);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> == <span class="hljs-number">2</span>) {
    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] + <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);
  }
}

<span class="hljs-title function_">doAdd</span>(<span class="hljs-number">10</span>);
<span class="hljs-comment">// 20</span>
<span class="hljs-title function_">doAdd</span>(<span class="hljs-number">30</span>, <span class="hljs-number">20</span>);
<span class="hljs-comment">// 50</span>
</code></pre>
4:["$","div",null,{"className":"markdown-body","children":["$","article",null,{"dangerouslySetInnerHTML":{"__html":"$c"}}]}]
a:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
8:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"front-end"}],["$","meta","2",{"name":"description","content":"front-end knowledge"}],["$","link","3",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
6:null
