<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/d498c84e4ab246b3.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/485ff6fe79292a08.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/b9d97b2190475167.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/851cdee6d90716dd.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-78112f590b744806.js"/><script src="/_next/static/chunks/4bd1b696-20882bf820444624.js" async=""></script><script src="/_next/static/chunks/517-98ed787e5f259f2c.js" async=""></script><script src="/_next/static/chunks/main-app-f33d3e3aed85e21f.js" async=""></script><meta name="next-size-adjust" content=""/><title>front-end</title><meta name="description" content="front-end knowledge"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><main><div class="markdown-body"><article><h1>默认参数</h1>
<p>通常来说，函数调用者不需要传递所有可能存在的参数，没有被传递的参数可由感知到的默认参数进行填充。JavaScript 有严格的默认参数格式，未被传值的参数默认为 <code>undefined</code>。ES6 引入了一种新方式，可以指定任意参数的默认值。</p>
<p>JavaScript 函数参数的默认值都是<code>undefined</code>， ES5 里，不支持直接在形参里写默认值。所以，要设置默认值，就要检测参数是否为<code>undefined</code>，按需求赋值。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x, y</span>) {
  y = y || <span class="hljs-string">&#x27;World&#x27;</span>;

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y);
}

<span class="hljs-title function_">fn</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>);
<span class="hljs-comment">// Hello World</span>
<span class="hljs-title function_">fn</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;China&#x27;</span>);
<span class="hljs-comment">// Hello China</span>
<span class="hljs-title function_">fn</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>);
<span class="hljs-comment">// Hello World</span>
</code></pre>
<p><strong>缺点</strong>：如果参数 <code>y</code> 赋值了，但是对应的布尔值为 <code>false</code>，则该赋值不起作用。</p>
<p>为了避免这个问题，我们需要先判断参数 <code>y</code> 是否被赋值，如果没有，再等于默认值。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x, y</span>) {
  y = <span class="hljs-keyword">typeof</span> y === <span class="hljs-literal">undefined</span> ? y || <span class="hljs-string">&#x27;World&#x27;</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y);
}
</code></pre>
<h2>基本用法</h2>
<p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x, y = <span class="hljs-string">&#x27;World&#x27;</span></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y);
}

<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>);
<span class="hljs-comment">// Hello World</span>

<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;China&#x27;</span>);
<span class="hljs-comment">// Hello China</span>

<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>);
<span class="hljs-comment">// Hello</span>
</code></pre>
<p><strong>优点：</strong></p>
<ul>
<li>阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档</li>
<li>有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行</li>
</ul>
<h3>默认声明</h3>
<p>参数变量是 <strong>默认声明</strong> 的，所以不能用 <code>let</code> 或 <code>const</code> 再次声明。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x = <span class="hljs-number">1</span></span>) {
  <span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span>;
  <span class="hljs-comment">// SyntaxError: Identifier &#x27;x&#x27; has already been declared</span>
  <span class="hljs-keyword">const</span> x = <span class="hljs-number">3</span>;
  <span class="hljs-comment">// SyntaxError: Identifier &#x27;x&#x27; has already been declared</span>
}
</code></pre>
<h3>参数命名冲突</h3>
<p>使用参数默认值时，函数不能有同名参数。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-comment">// 不报错</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x, x, y</span>) {
  <span class="hljs-comment">// do something</span>
}

<span class="hljs-comment">// 报错</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x, x, y = <span class="hljs-number">1</span></span>) {
  <span class="hljs-comment">// do something</span>
}
<span class="hljs-comment">// SyntaxError: Duplicate parameter name not allowed in this context</span>
</code></pre>
<h3>惰性求值</h3>
<p>参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">let</span> x = <span class="hljs-number">99</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">p = x + <span class="hljs-number">1</span></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p);
}

<span class="hljs-title function_">fn</span>();
<span class="hljs-comment">// 100</span>

x = <span class="hljs-number">100</span>;
<span class="hljs-title function_">fn</span>();
<span class="hljs-comment">// 101</span>
</code></pre>
<h3>结合解构赋值</h3>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">{ x, y = <span class="hljs-number">5</span> }</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y);
}

<span class="hljs-title function_">fn</span>({});
<span class="hljs-comment">// undefined 5</span>

<span class="hljs-title function_">fn</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> });
<span class="hljs-comment">// 1 5</span>

<span class="hljs-title function_">fn</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> });
<span class="hljs-comment">// 1 2</span>

<span class="hljs-title function_">fn</span>();
<span class="hljs-comment">// TypeError: Cannot read property &#x27;x&#x27; of undefined</span>
</code></pre>
<p>上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数 <code>fn</code> 的参数是一个对象时，变量 <code>x</code> 和 <code>y</code> 才会通过解构赋值生成。如果函数 <code>fn</code> 调用时没提供参数，变量 <code>x</code> 和 <code>y</code> 就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">{ x, y = <span class="hljs-number">5</span> } = {}</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y);
}

<span class="hljs-title function_">fn</span>();
<span class="hljs-comment">// undefined 5</span>
</code></pre>
<p>下面是另一个解构赋值默认值的例子。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params">url, { body = <span class="hljs-string">&#x27;&#x27;</span>, method = <span class="hljs-string">&#x27;GET&#x27;</span>, headers = {} }</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(method);
}

<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://example.com&#x27;</span>, {});
<span class="hljs-comment">// &quot;GET&quot;</span>

<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://example.com&#x27;</span>);
<span class="hljs-comment">// VM1292:1 Uncaught TypeError: Cannot read property &#x27;body&#x27; of undefined</span>
<span class="hljs-comment">//    at fetch (&lt;anonymous&gt;:1:23)</span>
<span class="hljs-comment">//    at &lt;anonymous&gt;:5:1</span>
</code></pre>
<p>上面代码中，如果函数 <code>fetch</code> 的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params">url, { body = <span class="hljs-string">&#x27;&#x27;</span>, method = <span class="hljs-string">&#x27;GET&#x27;</span>, headers = {} } = {}</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(method);
}

<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://example.com&#x27;</span>);
<span class="hljs-comment">// &quot;GET&quot;</span>
</code></pre>
<p>上面代码中，函数 <code>fetch</code> 没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量 <code>method</code> 才会取到默认值 <code>GET</code>。</p>
<h3>结合案例分析</h3>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-comment">// 写法一</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params">{ x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span> } = {}</span>) {
  <span class="hljs-keyword">return</span> [x, y];
}

<span class="hljs-comment">// 写法二</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params">{ x, y } = { x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span> }</span>) {
  <span class="hljs-keyword">return</span> [x, y];
}
</code></pre>
<p>上面两种写法都对函数的参数设定了默认值，区别是：</p>
<ul>
<li>写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；</li>
<li>写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值</li>
</ul>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-comment">// 函数没有参数的情况</span>
<span class="hljs-title function_">fn1</span>();
<span class="hljs-comment">// [0, 0]</span>
<span class="hljs-title function_">fn2</span>();
<span class="hljs-comment">// [0, 0]</span>

<span class="hljs-comment">// x 和 y 都有值的情况</span>
<span class="hljs-title function_">fn1</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">8</span> });
<span class="hljs-comment">// [3, 8]</span>
<span class="hljs-title function_">fn2</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">8</span> });
<span class="hljs-comment">// [3, 8]</span>

<span class="hljs-comment">// x 有值，y 无值的情况</span>
<span class="hljs-title function_">fn1</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">3</span> });
<span class="hljs-comment">// [3, 0]</span>
<span class="hljs-title function_">fn2</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">3</span> });
<span class="hljs-comment">// [3, undefined]</span>

<span class="hljs-comment">// x 和 y 都无值的情况</span>
<span class="hljs-title function_">fn1</span>({});
<span class="hljs-comment">// [0, 0];</span>
<span class="hljs-title function_">fn2</span>({});
<span class="hljs-comment">// [undefined, undefined]</span>

<span class="hljs-title function_">fn1</span>({ <span class="hljs-attr">z</span>: <span class="hljs-number">3</span> });
<span class="hljs-comment">// [0, 0]</span>
<span class="hljs-title function_">fn2</span>({ <span class="hljs-attr">z</span>: <span class="hljs-number">3</span> });
<span class="hljs-comment">// [undefined, undefined]</span>
</code></pre>
<h2>参数默认值的位置</h2>
<p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-comment">// example 1</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x = <span class="hljs-number">1</span>, y</span>){
    <span class="hljs-keyword">return</span> [x, y];
}

<span class="hljs-title function_">fn</span>();
<span class="hljs-comment">// [1, undefined]</span>

<span class="hljs-title function_">fn</span>(<span class="hljs-number">2</span>);
<span class="hljs-comment">// [2, undefined]</span>

<span class="hljs-title function_">fn</span>(, <span class="hljs-number">1</span>);
<span class="hljs-comment">// Uncaught SyntaxError: Unexpected token ,</span>

<span class="hljs-title function_">fn</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-number">1</span>);
<span class="hljs-comment">// [1, 1]</span>

<span class="hljs-comment">// example 2</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">x, y = <span class="hljs-number">5</span>, z</span>){
    <span class="hljs-keyword">return</span> [x, y, z];
}

<span class="hljs-title function_">bar</span>();
<span class="hljs-comment">// [undefined, 5, undefined]</span>

<span class="hljs-title function_">bar</span>(<span class="hljs-number">1</span>);
<span class="hljs-comment">// [1, 5, undefined]</span>

<span class="hljs-title function_">bar</span>(<span class="hljs-number">1</span>, ,<span class="hljs-number">2</span>);
<span class="hljs-comment">// Uncaught SyntaxError: Unexpected token ,</span>

<span class="hljs-title function_">bar</span>(<span class="hljs-number">1</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-number">2</span>);
<span class="hljs-comment">// [1, 5, 2]</span>
</code></pre>
<p>如果传入<code>undefined</code>，将触发该参数等于默认值，<code>null</code>则没有这个效果。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x = <span class="hljs-number">5</span>, y = <span class="hljs-number">6</span></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y);
}

<span class="hljs-title function_">fn</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">null</span>);
<span class="hljs-comment">// 5 null</span>
</code></pre>
<h2>函数的长度属性</h2>
<p>指定了默认值以后，函数的 <code>length</code> 属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。</p>
<p>示例一：一个参数，没有默认值</p>
<pre class="hljs language-js"  style=--lang:"js" ><code>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) {}.<span class="hljs-property">length</span>);
<span class="hljs-comment">// 1</span>
</code></pre>
<p>示例二：一个参数，有默认值</p>
<pre class="hljs language-js"  style=--lang:"js" ><code>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a = <span class="hljs-number">5</span></span>) {}.<span class="hljs-property">length</span>);
<span class="hljs-comment">// 0</span>
</code></pre>
<p>示例三：三个参数，其中一个参数有默认值</p>
<pre class="hljs language-js"  style=--lang:"js" ><code>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a, b, c = <span class="hljs-number">5</span></span>) {}.<span class="hljs-property">length</span>);
<span class="hljs-comment">// 2</span>
</code></pre>
<p>上面代码中，<code>length</code> 属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数 <code>c</code> 指定了默认值，因此 <code>length</code> 属性等于 <code>3</code> 减去 <code>1</code>，最后得到 <code>2</code>。</p>
<p>这是因为 <code>length</code> 属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入 <code>length</code> 属性。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code>(<span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) {}.<span class="hljs-property">length</span>); <span class="hljs-comment">// 0</span>
</code></pre>
<p>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code>(<span class="hljs-keyword">function</span>(<span class="hljs-params">a = <span class="hljs-number">0</span>, b, c</span>) {}.<span class="hljs-title function_">length</span>(
  <span class="hljs-comment">// 0</span>

  <span class="hljs-keyword">function</span>(<span class="hljs-params">a, b = <span class="hljs-number">1</span>, c</span>) {}
).<span class="hljs-property">length</span>);
<span class="hljs-comment">// 1</span>
</code></pre>
<h2>参数作用域</h2>
<p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x, y = x</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y);
}

<span class="hljs-title function_">f</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 2</span>
</code></pre>
<p>上面代码中，参数 <code>y</code> 的默认值等于变量 <code>x</code>。调用函数 <code>fn</code> 时，参数形成一个单独的作用域。在这个作用域里面，默认值变量 <code>x</code> 指向第一个参数 <code>x</code>，而不是全局变量 <code>x</code>，所以输出是 <code>2</code>。</p>
<p>再看下面的例子。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">y = x</span>) {
  <span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y);
}

<span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 1</span>
</code></pre>
<p>上面代码中，函数 <code>fn</code> 调用时，参数 <code>y = x</code> 形成一个单独的作用域。这个作用域里面，变量 <code>x</code> 本身没有定义，所以指向外层的全局变量 <code>x</code>。函数调用时，函数体内部的局部变量 <code>x</code> 影响不到默认值变量 <code>x</code>。</p>
<p>如果此时，全局变量 <code>x</code> 不存在，就会报错。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">y = x</span>) {
  <span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y);
}

<span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// ReferenceError: x is not defined</span>
</code></pre>
<p>下面这样写，也会报错。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x = x</span>) {
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// ReferenceError: x is not defined</span>
</code></pre>
<p>上面代码中，参数 <code>x = x</code> 形成一个单独作用域。实际执行的是 <code>let x = x</code>，由于暂时性死区的原因，这行代码会报错 <code>x is not defined</code>（指第二个 <code>x</code> 未定义）。</p>
<p>如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">let</span> fn = <span class="hljs-string">&#x27;outer&#x27;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">func = () =&gt; fn</span>) {
  <span class="hljs-keyword">let</span> fn = <span class="hljs-string">&#x27;inner&#x27;</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">func</span>());
}

<span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// outer</span>
</code></pre>
<p>上面代码中，函数 <code>bar</code> 的参数 <code>func</code> 的默认值是一个匿名函数，返回值为变量 <code>fn</code>。函数参数形成的单独作用域里面，并没有定义变量 <code>fn</code>，所以 <code>fn</code> 指向外层的全局变量 <code>fn</code>，因此输出 <code>outer</code>。</p>
<p>如果写成下面这样，就会报错。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">func = () =&gt; fn</span>) {
  <span class="hljs-keyword">let</span> fn = <span class="hljs-string">&#x27;inner&#x27;</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">func</span>());
}

<span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// ReferenceError: fn is not defined</span>
</code></pre>
<p>上面代码中，匿名函数里面的 <code>fn</code> 指向函数外层，但是函数外层并没有声明变量 <code>fn</code>，所以就报错了。</p>
<p>下面是一个更复杂的例子。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">
  x,
  y = <span class="hljs-keyword">function</span>() {
    x = <span class="hljs-number">2</span>;
  }
</span>) {
  <span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;
  <span class="hljs-title function_">y</span>();
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);
}

<span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 3</span>
x; <span class="hljs-comment">// 1</span>
</code></pre>
<p>上面代码中，函数 <code>fn</code> 的参数形成一个单独作用域。这个作用域里面，首先声明了变量 <code>x</code>，然后声明了变量<code>y</code>，<code>y</code> 的默认值是一个匿名函数。这个匿名函数内部的变量 <code>x</code>，指向同一个作用域的第一个参数 <code>x</code>。函数 <code>fn</code>内部又声明了一个内部变量 <code>x</code>，该变量与第一个参数 <code>x</code> 由于不是同一个作用域，所以不是同一个变量，因此执行<code>y</code>后，内部变量<code>x</code>和外部全局变量 <code>x</code> 的值都没变。</p>
<p>如果将 <code>var x = 3</code> 的 <code>var</code> 去除，函数 <code>fn</code> 的内部变量 <code>x</code> 就指向第一个参数 <code>x</code>，与匿名函数内部的 <code>x</code> 是一致的，所以最后输出的就是 <code>2</code>，而外层的全局变量 <code>x</code> 依然不受影响。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">
  x,
  y = <span class="hljs-keyword">function</span>() {
    x = <span class="hljs-number">2</span>;
  }
</span>) {
  x = <span class="hljs-number">3</span>;
  <span class="hljs-title function_">y</span>();
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);
}

<span class="hljs-title function_">fn</span>();
<span class="hljs-comment">// 2</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);
<span class="hljs-comment">// 1</span>
</code></pre>
<p><strong>总结：</strong></p>
<ul>
<li>函数声明初始化时，一旦设置了参数默认值，参数会形成一个单独的作用域，等初始化结束后，该作用域即会消失。这种语法在不设置参数默认值的时候是不会出现的。</li>
<li>参数作用域出线的变量名率先寻找参数作用域内先声明的参数，若不存在则寻找外部作用域的（不会从函数内部作用域寻找）
<ul>
<li>若先声明的参数已定义，则该值为该参数所定义的值</li>
<li>若先声明的参数未定义，并且外部作用域无同名变量已定义，则报错</li>
</ul>
</li>
<li>若参数默认值为函数，则该作为默认值的函数作用域与参数独立作用域相同
<ul>
<li>当函数内部作用域重新声明与已有参数同名变量，变量与同名参数不为同一变量</li>
<li>当函数内部作用域存在同名变量（没有重新声明），变量指向的是函数参数本身</li>
</ul>
</li>
</ul>
<h2>抛弃参数对象</h2>
<p>现在我们已经看到了 <code>arguments</code> 对象可被不定参数和默认参数完美代替，移除 <code>arguments</code> 后通常会使代码更易于阅读。除了破坏可读性外，众所周知，针对 <code>arguments</code> 对象对 JavaScript 虚拟机进行的优化会导致一些让你头疼不已的问题。</p>
<p>我们期待着不定参数和默认参数可以完全取代 <code>arguments</code>，要实现这个目标，标准中增加了相应的限制：在使用不定参数或默认参数的函数中禁止使用 <code>arguments</code> 对象。曾经实现过 <code>arguments</code> 的引擎不会立即移除对它的支持，当然，现在更推荐使用不定参数和默认参数。</p>
</article></div></main><script src="/_next/static/chunks/webpack-78112f590b744806.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5244,[],\"\"]\n3:I[3866,[],\"\"]\n5:I[6213,[],\"OutletBoundary\"]\n7:I[6213,[],\"MetadataBoundary\"]\n9:I[6213,[],\"ViewportBoundary\"]\nb:I[4835,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/d498c84e4ab246b3.css\",\"style\"]\n:HL[\"/_next/static/css/485ff6fe79292a08.css\",\"style\"]\n:HL[\"/_next/static/css/b9d97b2190475167.css\",\"style\"]\n:HL[\"/_next/static/css/851cdee6d90716dd.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"NFjmtHF2up8B2PpbDjLiS\",\"p\":\"\",\"c\":[\"\",\"front-end\",\"core-modules\",\"ecmascript-function-objects\",\"function-arguments\",\"default-parameters\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"front-end\",{\"children\":[[\"slug\",\"core-modules/ecmascript-function-objects/function-arguments/default-parameters\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d498c84e4ab246b3.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/485ff6fe79292a08.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/b9d97b2190475167.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"front-end\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/851cdee6d90716dd.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"main\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[[\"slug\",\"core-modules/ecmascript-function-objects/function-arguments/default-parameters\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"VNr0u-4TnakTZPwoW8baB\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:T6d83,"])</script><script>self.__next_f.push([1,"\u003ch1\u003e默认参数\u003c/h1\u003e\n\u003cp\u003e通常来说，函数调用者不需要传递所有可能存在的参数，没有被传递的参数可由感知到的默认参数进行填充。JavaScript 有严格的默认参数格式，未被传值的参数默认为 \u003ccode\u003eundefined\u003c/code\u003e。ES6 引入了一种新方式，可以指定任意参数的默认值。\u003c/p\u003e\n\u003cp\u003eJavaScript 函数参数的默认值都是\u003ccode\u003eundefined\u003c/code\u003e， ES5 里，不支持直接在形参里写默认值。所以，要设置默认值，就要检测参数是否为\u003ccode\u003eundefined\u003c/code\u003e，按需求赋值。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex, y\u003c/span\u003e) {\n  y = y || \u003cspan class=\"hljs-string\"\u003e\u0026#x27;World\u0026#x27;\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x, y);\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Hello\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// Hello World\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Hello\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;China\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// Hello China\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Hello\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// Hello World\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e缺点\u003c/strong\u003e：如果参数 \u003ccode\u003ey\u003c/code\u003e 赋值了，但是对应的布尔值为 \u003ccode\u003efalse\u003c/code\u003e，则该赋值不起作用。\u003c/p\u003e\n\u003cp\u003e为了避免这个问题，我们需要先判断参数 \u003ccode\u003ey\u003c/code\u003e 是否被赋值，如果没有，再等于默认值。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex, y\u003c/span\u003e) {\n  y = \u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e y === \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e ? y || \u003cspan class=\"hljs-string\"\u003e\u0026#x27;World\u0026#x27;\u003c/span\u003e;\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x, y);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e基本用法\u003c/h2\u003e\n\u003cp\u003eES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex, y = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;World\u0026#x27;\u003c/span\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x, y);\n}\n\n\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Hello\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// Hello World\u003c/span\u003e\n\n\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Hello\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;China\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// Hello China\u003c/span\u003e\n\n\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Hello\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// Hello\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e优点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档\u003c/li\u003e\n\u003cli\u003e有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e默认声明\u003c/h3\u003e\n\u003cp\u003e参数变量是 \u003cstrong\u003e默认声明\u003c/strong\u003e 的，所以不能用 \u003ccode\u003elet\u003c/code\u003e 或 \u003ccode\u003econst\u003c/code\u003e 再次声明。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e x = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// SyntaxError: Identifier \u0026#x27;x\u0026#x27; has already been declared\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e x = \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// SyntaxError: Identifier \u0026#x27;x\u0026#x27; has already been declared\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e参数命名冲突\u003c/h3\u003e\n\u003cp\u003e使用参数默认值时，函数不能有同名参数。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 不报错\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex, x, y\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// do something\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 报错\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex, x, y = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// do something\u003c/span\u003e\n}\n\u003cspan class=\"hljs-comment\"\u003e// SyntaxError: Duplicate parameter name not allowed in this context\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e惰性求值\u003c/h3\u003e\n\u003cp\u003e参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e x = \u003cspan class=\"hljs-number\"\u003e99\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ep = x + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(p);\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// 100\u003c/span\u003e\n\nx = \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e;\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// 101\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e结合解构赋值\u003c/h3\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ x, y = \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x, y);\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e({});\n\u003cspan class=\"hljs-comment\"\u003e// undefined 5\u003c/span\u003e\n\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003ex\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e });\n\u003cspan class=\"hljs-comment\"\u003e// 1 5\u003c/span\u003e\n\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003ex\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ey\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e });\n\u003cspan class=\"hljs-comment\"\u003e// 1 2\u003c/span\u003e\n\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// TypeError: Cannot read property \u0026#x27;x\u0026#x27; of undefined\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数 \u003ccode\u003efn\u003c/code\u003e 的参数是一个对象时，变量 \u003ccode\u003ex\u003c/code\u003e 和 \u003ccode\u003ey\u003c/code\u003e 才会通过解构赋值生成。如果函数 \u003ccode\u003efn\u003c/code\u003e 调用时没提供参数，变量 \u003ccode\u003ex\u003c/code\u003e 和 \u003ccode\u003ey\u003c/code\u003e 就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ x, y = \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e } = {}\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x, y);\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// undefined 5\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e下面是另一个解构赋值默认值的例子。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eurl, { body = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026#x27;\u003c/span\u003e, method = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;GET\u0026#x27;\u003c/span\u003e, headers = {} }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(method);\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;http://example.com\u0026#x27;\u003c/span\u003e, {});\n\u003cspan class=\"hljs-comment\"\u003e// \u0026quot;GET\u0026quot;\u003c/span\u003e\n\n\u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;http://example.com\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// VM1292:1 Uncaught TypeError: Cannot read property \u0026#x27;body\u0026#x27; of undefined\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//    at fetch (\u0026lt;anonymous\u0026gt;:1:23)\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e//    at \u0026lt;anonymous\u0026gt;:5:1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面代码中，如果函数 \u003ccode\u003efetch\u003c/code\u003e 的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eurl, { body = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;\u0026#x27;\u003c/span\u003e, method = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;GET\u0026#x27;\u003c/span\u003e, headers = {} } = {}\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(method);\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;http://example.com\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// \u0026quot;GET\u0026quot;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面代码中，函数 \u003ccode\u003efetch\u003c/code\u003e 没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量 \u003ccode\u003emethod\u003c/code\u003e 才会取到默认值 \u003ccode\u003eGET\u003c/code\u003e。\u003c/p\u003e\n\u003ch3\u003e结合案例分析\u003c/h3\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 写法一\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn1\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ x = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, y = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e } = {}\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [x, y];\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 写法二\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn2\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e{ x, y } = { x: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, y: \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e }\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [x, y];\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面两种写法都对函数的参数设定了默认值，区别是：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；\u003c/li\u003e\n\u003cli\u003e写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 函数没有参数的情况\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003efn1\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// [0, 0]\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003efn2\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// [0, 0]\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// x 和 y 都有值的情况\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003efn1\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003ex\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ey\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e });\n\u003cspan class=\"hljs-comment\"\u003e// [3, 8]\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003efn2\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003ex\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-attr\"\u003ey\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e8\u003c/span\u003e });\n\u003cspan class=\"hljs-comment\"\u003e// [3, 8]\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// x 有值，y 无值的情况\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003efn1\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003ex\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e });\n\u003cspan class=\"hljs-comment\"\u003e// [3, 0]\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003efn2\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003ex\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e });\n\u003cspan class=\"hljs-comment\"\u003e// [3, undefined]\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// x 和 y 都无值的情况\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003efn1\u003c/span\u003e({});\n\u003cspan class=\"hljs-comment\"\u003e// [0, 0];\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003efn2\u003c/span\u003e({});\n\u003cspan class=\"hljs-comment\"\u003e// [undefined, undefined]\u003c/span\u003e\n\n\u003cspan class=\"hljs-title function_\"\u003efn1\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003ez\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e });\n\u003cspan class=\"hljs-comment\"\u003e// [0, 0]\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003efn2\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003ez\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e });\n\u003cspan class=\"hljs-comment\"\u003e// [undefined, undefined]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e参数默认值的位置\u003c/h2\u003e\n\u003cp\u003e通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// example 1\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, y\u003c/span\u003e){\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [x, y];\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// [1, undefined]\u003c/span\u003e\n\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// [2, undefined]\u003c/span\u003e\n\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// Uncaught SyntaxError: Unexpected token ,\u003c/span\u003e\n\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// [1, 1]\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// example 2\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex, y = \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, z\u003c/span\u003e){\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e [x, y, z];\n}\n\n\u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// [undefined, 5, undefined]\u003c/span\u003e\n\n\u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// [1, 5, undefined]\u003c/span\u003e\n\n\u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, ,\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// Uncaught SyntaxError: Unexpected token ,\u003c/span\u003e\n\n\u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// [1, 5, 2]\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果传入\u003ccode\u003eundefined\u003c/code\u003e，将触发该参数等于默认值，\u003ccode\u003enull\u003c/code\u003e则没有这个效果。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex = \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e, y = \u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x, y);\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e, \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 5 null\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e函数的长度属性\u003c/h2\u003e\n\u003cp\u003e指定了默认值以后，函数的 \u003ccode\u003elength\u003c/code\u003e 属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，\u003ccode\u003elength\u003c/code\u003e属性将失真。\u003c/p\u003e\n\u003cp\u003e示例一：一个参数，没有默认值\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ea\u003c/span\u003e) {}.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e示例二：一个参数，有默认值\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ea = \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\u003c/span\u003e) {}.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 0\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e示例三：三个参数，其中一个参数有默认值\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ea, b, c = \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e\u003c/span\u003e) {}.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面代码中，\u003ccode\u003elength\u003c/code\u003e 属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数 \u003ccode\u003ec\u003c/code\u003e 指定了默认值，因此 \u003ccode\u003elength\u003c/code\u003e 属性等于 \u003ccode\u003e3\u003c/code\u003e 减去 \u003ccode\u003e1\u003c/code\u003e，最后得到 \u003ccode\u003e2\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e这是因为 \u003ccode\u003elength\u003c/code\u003e 属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入 \u003ccode\u003elength\u003c/code\u003e 属性。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e...args\u003c/span\u003e) {}.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 0\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果设置了默认值的参数不是尾参数，那么\u003ccode\u003elength\u003c/code\u003e属性也不再计入后面的参数了。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ea = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, b, c\u003c/span\u003e) {}.\u003cspan class=\"hljs-title function_\"\u003elength\u003c/span\u003e(\n  \u003cspan class=\"hljs-comment\"\u003e// 0\u003c/span\u003e\n\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ea, b = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, c\u003c/span\u003e) {}\n).\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e参数作用域\u003c/h2\u003e\n\u003cp\u003e一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e x = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex, y = x\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(y);\n}\n\n\u003cspan class=\"hljs-title function_\"\u003ef\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面代码中，参数 \u003ccode\u003ey\u003c/code\u003e 的默认值等于变量 \u003ccode\u003ex\u003c/code\u003e。调用函数 \u003ccode\u003efn\u003c/code\u003e 时，参数形成一个单独的作用域。在这个作用域里面，默认值变量 \u003ccode\u003ex\u003c/code\u003e 指向第一个参数 \u003ccode\u003ex\u003c/code\u003e，而不是全局变量 \u003ccode\u003ex\u003c/code\u003e，所以输出是 \u003ccode\u003e2\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e再看下面的例子。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e x = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ey = x\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e x = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(y);\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面代码中，函数 \u003ccode\u003efn\u003c/code\u003e 调用时，参数 \u003ccode\u003ey = x\u003c/code\u003e 形成一个单独的作用域。这个作用域里面，变量 \u003ccode\u003ex\u003c/code\u003e 本身没有定义，所以指向外层的全局变量 \u003ccode\u003ex\u003c/code\u003e。函数调用时，函数体内部的局部变量 \u003ccode\u003ex\u003c/code\u003e 影响不到默认值变量 \u003ccode\u003ex\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e如果此时，全局变量 \u003ccode\u003ex\u003c/code\u003e 不存在，就会报错。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ey = x\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e x = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(y);\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// ReferenceError: x is not defined\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e下面这样写，也会报错。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e x = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex = x\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// ReferenceError: x is not defined\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面代码中，参数 \u003ccode\u003ex = x\u003c/code\u003e 形成一个单独作用域。实际执行的是 \u003ccode\u003elet x = x\u003c/code\u003e，由于暂时性死区的原因，这行代码会报错 \u003ccode\u003ex is not defined\u003c/code\u003e（指第二个 \u003ccode\u003ex\u003c/code\u003e 未定义）。\u003c/p\u003e\n\u003cp\u003e如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e fn = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;outer\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efunc = () =\u0026gt; fn\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e fn = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;inner\u0026#x27;\u003c/span\u003e;\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003efunc\u003c/span\u003e());\n}\n\n\u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// outer\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面代码中，函数 \u003ccode\u003ebar\u003c/code\u003e 的参数 \u003ccode\u003efunc\u003c/code\u003e 的默认值是一个匿名函数，返回值为变量 \u003ccode\u003efn\u003c/code\u003e。函数参数形成的单独作用域里面，并没有定义变量 \u003ccode\u003efn\u003c/code\u003e，所以 \u003ccode\u003efn\u003c/code\u003e 指向外层的全局变量 \u003ccode\u003efn\u003c/code\u003e，因此输出 \u003ccode\u003eouter\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e如果写成下面这样，就会报错。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efunc = () =\u0026gt; fn\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e fn = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;inner\u0026#x27;\u003c/span\u003e;\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003efunc\u003c/span\u003e());\n}\n\n\u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// ReferenceError: fn is not defined\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面代码中，匿名函数里面的 \u003ccode\u003efn\u003c/code\u003e 指向函数外层，但是函数外层并没有声明变量 \u003ccode\u003efn\u003c/code\u003e，所以就报错了。\u003c/p\u003e\n\u003cp\u003e下面是一个更复杂的例子。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e x = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n  x,\n  y = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e() {\n    x = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n  }\n\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e x = \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e;\n  \u003cspan class=\"hljs-title function_\"\u003ey\u003c/span\u003e();\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x);\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 3\u003c/span\u003e\nx; \u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面代码中，函数 \u003ccode\u003efn\u003c/code\u003e 的参数形成一个单独作用域。这个作用域里面，首先声明了变量 \u003ccode\u003ex\u003c/code\u003e，然后声明了变量\u003ccode\u003ey\u003c/code\u003e，\u003ccode\u003ey\u003c/code\u003e 的默认值是一个匿名函数。这个匿名函数内部的变量 \u003ccode\u003ex\u003c/code\u003e，指向同一个作用域的第一个参数 \u003ccode\u003ex\u003c/code\u003e。函数 \u003ccode\u003efn\u003c/code\u003e内部又声明了一个内部变量 \u003ccode\u003ex\u003c/code\u003e，该变量与第一个参数 \u003ccode\u003ex\u003c/code\u003e 由于不是同一个作用域，所以不是同一个变量，因此执行\u003ccode\u003ey\u003c/code\u003e后，内部变量\u003ccode\u003ex\u003c/code\u003e和外部全局变量 \u003ccode\u003ex\u003c/code\u003e 的值都没变。\u003c/p\u003e\n\u003cp\u003e如果将 \u003ccode\u003evar x = 3\u003c/code\u003e 的 \u003ccode\u003evar\u003c/code\u003e 去除，函数 \u003ccode\u003efn\u003c/code\u003e 的内部变量 \u003ccode\u003ex\u003c/code\u003e 就指向第一个参数 \u003ccode\u003ex\u003c/code\u003e，与匿名函数内部的 \u003ccode\u003ex\u003c/code\u003e 是一致的，所以最后输出的就是 \u003ccode\u003e2\u003c/code\u003e，而外层的全局变量 \u003ccode\u003ex\u003c/code\u003e 依然不受影响。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e x = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n  x,\n  y = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e() {\n    x = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n  }\n\u003c/span\u003e) {\n  x = \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e;\n  \u003cspan class=\"hljs-title function_\"\u003ey\u003c/span\u003e();\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x);\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x);\n\u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e总结：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e函数声明初始化时，一旦设置了参数默认值，参数会形成一个单独的作用域，等初始化结束后，该作用域即会消失。这种语法在不设置参数默认值的时候是不会出现的。\u003c/li\u003e\n\u003cli\u003e参数作用域出线的变量名率先寻找参数作用域内先声明的参数，若不存在则寻找外部作用域的（不会从函数内部作用域寻找）\n\u003cul\u003e\n\u003cli\u003e若先声明的参数已定义，则该值为该参数所定义的值\u003c/li\u003e\n\u003cli\u003e若先声明的参数未定义，并且外部作用域无同名变量已定义，则报错\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e若参数默认值为函数，则该作为默认值的函数作用域与参数独立作用域相同\n\u003cul\u003e\n\u003cli\u003e当函数内部作用域重新声明与已有参数同名变量，变量与同名参数不为同一变量\u003c/li\u003e\n\u003cli\u003e当函数内部作用域存在同名变量（没有重新声明），变量指向的是函数参数本身\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e抛弃参数对象\u003c/h2\u003e\n\u003cp\u003e现在我们已经看到了 \u003ccode\u003earguments\u003c/code\u003e 对象可被不定参数和默认参数完美代替，移除 \u003ccode\u003earguments\u003c/code\u003e 后通常会使代码更易于阅读。除了破坏可读性外，众所周知，针对 \u003ccode\u003earguments\u003c/code\u003e 对象对 JavaScript 虚拟机进行的优化会导致一些让你头疼不已的问题。\u003c/p\u003e\n\u003cp\u003e我们期待着不定参数和默认参数可以完全取代 \u003ccode\u003earguments\u003c/code\u003e，要实现这个目标，标准中增加了相应的限制：在使用不定参数或默认参数的函数中禁止使用 \u003ccode\u003earguments\u003c/code\u003e 对象。曾经实现过 \u003ccode\u003earguments\u003c/code\u003e 的引擎不会立即移除对它的支持，当然，现在更推荐使用不定参数和默认参数。\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"markdown-body\",\"children\":[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"front-end\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"front-end knowledge\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>