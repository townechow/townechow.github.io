1:"$Sreact.fragment"
2:I[5244,[],""]
3:I[3866,[],""]
5:I[6213,[],"OutletBoundary"]
7:I[6213,[],"MetadataBoundary"]
9:I[6213,[],"ViewportBoundary"]
b:I[4835,[],""]
:HL["/_next/static/media/569ce4b8f30dc480-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/ec0a9d078e716e00.css","style"]
:HL["/_next/static/css/485ff6fe79292a08.css","style"]
:HL["/_next/static/css/0ff121a467c0636f.css","style"]
0:{"P":null,"b":"NW9bMA21iAaih0TqCHqj1","p":"","c":["","front-end","core-modules","ecmascript-function-objects","function-arguments","default-parameters"],"i":false,"f":[[["",{"children":["front-end",{"children":[["slug","core-modules/ecmascript-function-objects/function-arguments/default-parameters","oc"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/ec0a9d078e716e00.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__variable_4d318d __variable_ea5f4b antialiased","children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[],[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]]}],{"children":["front-end",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/485ff6fe79292a08.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/0ff121a467c0636f.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","main",null,{"children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","front-end","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]}]]}],{"children":[["slug","core-modules/ecmascript-function-objects/function-arguments/default-parameters","oc"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","front-end","children","$0:f:0:1:2:children:2:children:0","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L4",null,["$","$L5",null,{"children":"$L6"}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","PqI8SIrJRjwbCAKZGTi-C",{"children":[["$","$L7",null,{"children":"$L8"}],["$","$L9",null,{"children":"$La"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}]]}],false]],"m":"$undefined","G":["$b","$undefined"],"s":false,"S":true}
c:T6c3f,<h1>默认参数</h1>
<p>通常来说，函数调用者不需要传递所有可能存在的参数，没有被传递的参数可由感知到的默认参数进行填充。JavaScript 有严格的默认参数格式，未被传值的参数默认为 <code>undefined</code>。ES6 引入了一种新方式，可以指定任意参数的默认值。</p>
<p>JavaScript 函数参数的默认值都是<code>undefined</code>， ES5 里，不支持直接在形参里写默认值。所以，要设置默认值，就要检测参数是否为<code>undefined</code>，按需求赋值。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x, y</span>) {
  y = y || <span class="hljs-string">&#x27;World&#x27;</span>;

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y);
}

<span class="hljs-title function_">fn</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>);
<span class="hljs-comment">// Hello World</span>
<span class="hljs-title function_">fn</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;China&#x27;</span>);
<span class="hljs-comment">// Hello China</span>
<span class="hljs-title function_">fn</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>);
<span class="hljs-comment">// Hello World</span>
</code></pre>
<p><strong>缺点</strong>：如果参数 <code>y</code> 赋值了，但是对应的布尔值为 <code>false</code>，则该赋值不起作用。</p>
<p>为了避免这个问题，我们需要先判断参数 <code>y</code> 是否被赋值，如果没有，再等于默认值。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x, y</span>) {
  y = <span class="hljs-keyword">typeof</span> y === <span class="hljs-literal">undefined</span> ? y || <span class="hljs-string">&#x27;World&#x27;</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y);
}
</code></pre>
<h2>基本用法</h2>
<p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x, y = <span class="hljs-string">&#x27;World&#x27;</span></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y);
}

<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>);
<span class="hljs-comment">// Hello World</span>

<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;China&#x27;</span>);
<span class="hljs-comment">// Hello China</span>

<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Hello&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>);
<span class="hljs-comment">// Hello</span>
</code></pre>
<p><strong>优点：</strong></p>
<ul>
<li>阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档</li>
<li>有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行</li>
</ul>
<h3>默认声明</h3>
<p>参数变量是 <strong>默认声明</strong> 的，所以不能用 <code>let</code> 或 <code>const</code> 再次声明。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x = <span class="hljs-number">1</span></span>) {
  <span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span>;
  <span class="hljs-comment">// SyntaxError: Identifier &#x27;x&#x27; has already been declared</span>
  <span class="hljs-keyword">const</span> x = <span class="hljs-number">3</span>;
  <span class="hljs-comment">// SyntaxError: Identifier &#x27;x&#x27; has already been declared</span>
}
</code></pre>
<h3>参数命名冲突</h3>
<p>使用参数默认值时，函数不能有同名参数。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 不报错</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x, x, y</span>) {
  <span class="hljs-comment">// do something</span>
}

<span class="hljs-comment">// 报错</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x, x, y = <span class="hljs-number">1</span></span>) {
  <span class="hljs-comment">// do something</span>
}
<span class="hljs-comment">// SyntaxError: Duplicate parameter name not allowed in this context</span>
</code></pre>
<h3>惰性求值</h3>
<p>参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">99</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">p = x + <span class="hljs-number">1</span></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p);
}

<span class="hljs-title function_">fn</span>();
<span class="hljs-comment">// 100</span>

x = <span class="hljs-number">100</span>;
<span class="hljs-title function_">fn</span>();
<span class="hljs-comment">// 101</span>
</code></pre>
<h3>结合解构赋值</h3>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">{ x, y = <span class="hljs-number">5</span> }</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y);
}

<span class="hljs-title function_">fn</span>({});
<span class="hljs-comment">// undefined 5</span>

<span class="hljs-title function_">fn</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> });
<span class="hljs-comment">// 1 5</span>

<span class="hljs-title function_">fn</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span> });
<span class="hljs-comment">// 1 2</span>

<span class="hljs-title function_">fn</span>();
<span class="hljs-comment">// TypeError: Cannot read property &#x27;x&#x27; of undefined</span>
</code></pre>
<p>上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数 <code>fn</code> 的参数是一个对象时，变量 <code>x</code> 和 <code>y</code> 才会通过解构赋值生成。如果函数 <code>fn</code> 调用时没提供参数，变量 <code>x</code> 和 <code>y</code> 就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">{ x, y = <span class="hljs-number">5</span> } = {}</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y);
}

<span class="hljs-title function_">fn</span>();
<span class="hljs-comment">// undefined 5</span>
</code></pre>
<p>下面是另一个解构赋值默认值的例子。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params">url, { body = <span class="hljs-string">&#x27;&#x27;</span>, method = <span class="hljs-string">&#x27;GET&#x27;</span>, headers = {} }</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(method);
}

<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://example.com&#x27;</span>, {});
<span class="hljs-comment">// &quot;GET&quot;</span>

<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://example.com&#x27;</span>);
<span class="hljs-comment">// VM1292:1 Uncaught TypeError: Cannot read property &#x27;body&#x27; of undefined</span>
<span class="hljs-comment">//    at fetch (&lt;anonymous&gt;:1:23)</span>
<span class="hljs-comment">//    at &lt;anonymous&gt;:5:1</span>
</code></pre>
<p>上面代码中，如果函数 <code>fetch</code> 的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fetch</span>(<span class="hljs-params">url, { body = <span class="hljs-string">&#x27;&#x27;</span>, method = <span class="hljs-string">&#x27;GET&#x27;</span>, headers = {} } = {}</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(method);
}

<span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;http://example.com&#x27;</span>);
<span class="hljs-comment">// &quot;GET&quot;</span>
</code></pre>
<p>上面代码中，函数 <code>fetch</code> 没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量 <code>method</code> 才会取到默认值 <code>GET</code>。</p>
<h3>结合案例分析</h3>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 写法一</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn1</span>(<span class="hljs-params">{ x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span> } = {}</span>) {
  <span class="hljs-keyword">return</span> [x, y];
}

<span class="hljs-comment">// 写法二</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn2</span>(<span class="hljs-params">{ x, y } = { x: <span class="hljs-number">0</span>, y: <span class="hljs-number">0</span> }</span>) {
  <span class="hljs-keyword">return</span> [x, y];
}
</code></pre>
<p>上面两种写法都对函数的参数设定了默认值，区别是：</p>
<ul>
<li>写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；</li>
<li>写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值</li>
</ul>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 函数没有参数的情况</span>
<span class="hljs-title function_">fn1</span>();
<span class="hljs-comment">// [0, 0]</span>
<span class="hljs-title function_">fn2</span>();
<span class="hljs-comment">// [0, 0]</span>

<span class="hljs-comment">// x 和 y 都有值的情况</span>
<span class="hljs-title function_">fn1</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">8</span> });
<span class="hljs-comment">// [3, 8]</span>
<span class="hljs-title function_">fn2</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">8</span> });
<span class="hljs-comment">// [3, 8]</span>

<span class="hljs-comment">// x 有值，y 无值的情况</span>
<span class="hljs-title function_">fn1</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">3</span> });
<span class="hljs-comment">// [3, 0]</span>
<span class="hljs-title function_">fn2</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">3</span> });
<span class="hljs-comment">// [3, undefined]</span>

<span class="hljs-comment">// x 和 y 都无值的情况</span>
<span class="hljs-title function_">fn1</span>({});
<span class="hljs-comment">// [0, 0];</span>
<span class="hljs-title function_">fn2</span>({});
<span class="hljs-comment">// [undefined, undefined]</span>

<span class="hljs-title function_">fn1</span>({ <span class="hljs-attr">z</span>: <span class="hljs-number">3</span> });
<span class="hljs-comment">// [0, 0]</span>
<span class="hljs-title function_">fn2</span>({ <span class="hljs-attr">z</span>: <span class="hljs-number">3</span> });
<span class="hljs-comment">// [undefined, undefined]</span>
</code></pre>
<h2>参数默认值的位置</h2>
<p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// example 1</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x = <span class="hljs-number">1</span>, y</span>){
    <span class="hljs-keyword">return</span> [x, y];
}

<span class="hljs-title function_">fn</span>();
<span class="hljs-comment">// [1, undefined]</span>

<span class="hljs-title function_">fn</span>(<span class="hljs-number">2</span>);
<span class="hljs-comment">// [2, undefined]</span>

<span class="hljs-title function_">fn</span>(, <span class="hljs-number">1</span>);
<span class="hljs-comment">// Uncaught SyntaxError: Unexpected token ,</span>

<span class="hljs-title function_">fn</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-number">1</span>);
<span class="hljs-comment">// [1, 1]</span>

<span class="hljs-comment">// example 2</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">x, y = <span class="hljs-number">5</span>, z</span>){
    <span class="hljs-keyword">return</span> [x, y, z];
}

<span class="hljs-title function_">bar</span>();
<span class="hljs-comment">// [undefined, 5, undefined]</span>

<span class="hljs-title function_">bar</span>(<span class="hljs-number">1</span>);
<span class="hljs-comment">// [1, 5, undefined]</span>

<span class="hljs-title function_">bar</span>(<span class="hljs-number">1</span>, ,<span class="hljs-number">2</span>);
<span class="hljs-comment">// Uncaught SyntaxError: Unexpected token ,</span>

<span class="hljs-title function_">bar</span>(<span class="hljs-number">1</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-number">2</span>);
<span class="hljs-comment">// [1, 5, 2]</span>
</code></pre>
<p>如果传入<code>undefined</code>，将触发该参数等于默认值，<code>null</code>则没有这个效果。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x = <span class="hljs-number">5</span>, y = <span class="hljs-number">6</span></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y);
}

<span class="hljs-title function_">fn</span>(<span class="hljs-literal">undefined</span>, <span class="hljs-literal">null</span>);
<span class="hljs-comment">// 5 null</span>
</code></pre>
<h2>函数的长度属性</h2>
<p>指定了默认值以后，函数的 <code>length</code> 属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，<code>length</code>属性将失真。</p>
<p>示例一：一个参数，没有默认值</p>
<pre class="hljs"><code class="language-js">(<span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>) {}.<span class="hljs-property">length</span>);
<span class="hljs-comment">// 1</span>
</code></pre>
<p>示例二：一个参数，有默认值</p>
<pre class="hljs"><code class="language-js">(<span class="hljs-keyword">function</span>(<span class="hljs-params">a = <span class="hljs-number">5</span></span>) {}.<span class="hljs-property">length</span>);
<span class="hljs-comment">// 0</span>
</code></pre>
<p>示例三：三个参数，其中一个参数有默认值</p>
<pre class="hljs"><code class="language-js">(<span class="hljs-keyword">function</span>(<span class="hljs-params">a, b, c = <span class="hljs-number">5</span></span>) {}.<span class="hljs-property">length</span>);
<span class="hljs-comment">// 2</span>
</code></pre>
<p>上面代码中，<code>length</code> 属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数 <code>c</code> 指定了默认值，因此 <code>length</code> 属性等于 <code>3</code> 减去 <code>1</code>，最后得到 <code>2</code>。</p>
<p>这是因为 <code>length</code> 属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入 <code>length</code> 属性。</p>
<pre class="hljs"><code class="language-js">(<span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>) {}.<span class="hljs-property">length</span>); <span class="hljs-comment">// 0</span>
</code></pre>
<p>如果设置了默认值的参数不是尾参数，那么<code>length</code>属性也不再计入后面的参数了。</p>
<pre class="hljs"><code class="language-js">(<span class="hljs-keyword">function</span>(<span class="hljs-params">a = <span class="hljs-number">0</span>, b, c</span>) {}.<span class="hljs-title function_">length</span>(
  <span class="hljs-comment">// 0</span>

  <span class="hljs-keyword">function</span>(<span class="hljs-params">a, b = <span class="hljs-number">1</span>, c</span>) {}
).<span class="hljs-property">length</span>);
<span class="hljs-comment">// 1</span>
</code></pre>
<h2>参数作用域</h2>
<p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x, y = x</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y);
}

<span class="hljs-title function_">f</span>(<span class="hljs-number">2</span>); <span class="hljs-comment">// 2</span>
</code></pre>
<p>上面代码中，参数 <code>y</code> 的默认值等于变量 <code>x</code>。调用函数 <code>fn</code> 时，参数形成一个单独的作用域。在这个作用域里面，默认值变量 <code>x</code> 指向第一个参数 <code>x</code>，而不是全局变量 <code>x</code>，所以输出是 <code>2</code>。</p>
<p>再看下面的例子。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">let</span> x = <span class="hljs-number">1</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">y = x</span>) {
  <span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y);
}

<span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 1</span>
</code></pre>
<p>上面代码中，函数 <code>fn</code> 调用时，参数 <code>y = x</code> 形成一个单独的作用域。这个作用域里面，变量 <code>x</code> 本身没有定义，所以指向外层的全局变量 <code>x</code>。函数调用时，函数体内部的局部变量 <code>x</code> 影响不到默认值变量 <code>x</code>。</p>
<p>如果此时，全局变量 <code>x</code> 不存在，就会报错。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">y = x</span>) {
  <span class="hljs-keyword">let</span> x = <span class="hljs-number">2</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y);
}

<span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// ReferenceError: x is not defined</span>
</code></pre>
<p>下面这样写，也会报错。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x = x</span>) {
  <span class="hljs-comment">// ...</span>
}

<span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// ReferenceError: x is not defined</span>
</code></pre>
<p>上面代码中，参数 <code>x = x</code> 形成一个单独作用域。实际执行的是 <code>let x = x</code>，由于暂时性死区的原因，这行代码会报错 <code>x is not defined</code>（指第二个 <code>x</code> 未定义）。</p>
<p>如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">let</span> fn = <span class="hljs-string">&#x27;outer&#x27;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">func = () =&gt; fn</span>) {
  <span class="hljs-keyword">let</span> fn = <span class="hljs-string">&#x27;inner&#x27;</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">func</span>());
}

<span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// outer</span>
</code></pre>
<p>上面代码中，函数 <code>bar</code> 的参数 <code>func</code> 的默认值是一个匿名函数，返回值为变量 <code>fn</code>。函数参数形成的单独作用域里面，并没有定义变量 <code>fn</code>，所以 <code>fn</code> 指向外层的全局变量 <code>fn</code>，因此输出 <code>outer</code>。</p>
<p>如果写成下面这样，就会报错。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">func = () =&gt; fn</span>) {
  <span class="hljs-keyword">let</span> fn = <span class="hljs-string">&#x27;inner&#x27;</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">func</span>());
}

<span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// ReferenceError: fn is not defined</span>
</code></pre>
<p>上面代码中，匿名函数里面的 <code>fn</code> 指向函数外层，但是函数外层并没有声明变量 <code>fn</code>，所以就报错了。</p>
<p>下面是一个更复杂的例子。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">
  x,
  y = <span class="hljs-keyword">function</span>() {
    x = <span class="hljs-number">2</span>;
  }
</span>) {
  <span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;
  <span class="hljs-title function_">y</span>();
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);
}

<span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// 3</span>
x; <span class="hljs-comment">// 1</span>
</code></pre>
<p>上面代码中，函数 <code>fn</code> 的参数形成一个单独作用域。这个作用域里面，首先声明了变量 <code>x</code>，然后声明了变量<code>y</code>，<code>y</code> 的默认值是一个匿名函数。这个匿名函数内部的变量 <code>x</code>，指向同一个作用域的第一个参数 <code>x</code>。函数 <code>fn</code>内部又声明了一个内部变量 <code>x</code>，该变量与第一个参数 <code>x</code> 由于不是同一个作用域，所以不是同一个变量，因此执行<code>y</code>后，内部变量<code>x</code>和外部全局变量 <code>x</code> 的值都没变。</p>
<p>如果将 <code>var x = 3</code> 的 <code>var</code> 去除，函数 <code>fn</code> 的内部变量 <code>x</code> 就指向第一个参数 <code>x</code>，与匿名函数内部的 <code>x</code> 是一致的，所以最后输出的就是 <code>2</code>，而外层的全局变量 <code>x</code> 依然不受影响。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">var</span> x = <span class="hljs-number">1</span>;
<span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">
  x,
  y = <span class="hljs-keyword">function</span>() {
    x = <span class="hljs-number">2</span>;
  }
</span>) {
  x = <span class="hljs-number">3</span>;
  <span class="hljs-title function_">y</span>();
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);
}

<span class="hljs-title function_">fn</span>();
<span class="hljs-comment">// 2</span>

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);
<span class="hljs-comment">// 1</span>
</code></pre>
<p><strong>总结：</strong></p>
<ul>
<li>函数声明初始化时，一旦设置了参数默认值，参数会形成一个单独的作用域，等初始化结束后，该作用域即会消失。这种语法在不设置参数默认值的时候是不会出现的。</li>
<li>参数作用域出线的变量名率先寻找参数作用域内先声明的参数，若不存在则寻找外部作用域的（不会从函数内部作用域寻找）
<ul>
<li>若先声明的参数已定义，则该值为该参数所定义的值</li>
<li>若先声明的参数未定义，并且外部作用域无同名变量已定义，则报错</li>
</ul>
</li>
<li>若参数默认值为函数，则该作为默认值的函数作用域与参数独立作用域相同
<ul>
<li>当函数内部作用域重新声明与已有参数同名变量，变量与同名参数不为同一变量</li>
<li>当函数内部作用域存在同名变量（没有重新声明），变量指向的是函数参数本身</li>
</ul>
</li>
</ul>
<h2>抛弃参数对象</h2>
<p>现在我们已经看到了 <code>arguments</code> 对象可被不定参数和默认参数完美代替，移除 <code>arguments</code> 后通常会使代码更易于阅读。除了破坏可读性外，众所周知，针对 <code>arguments</code> 对象对 JavaScript 虚拟机进行的优化会导致一些让你头疼不已的问题。</p>
<p>我们期待着不定参数和默认参数可以完全取代 <code>arguments</code>，要实现这个目标，标准中增加了相应的限制：在使用不定参数或默认参数的函数中禁止使用 <code>arguments</code> 对象。曾经实现过 <code>arguments</code> 的引擎不会立即移除对它的支持，当然，现在更推荐使用不定参数和默认参数。</p>
4:["$","div",null,{"className":"markdown-body","children":["$","article",null,{"dangerouslySetInnerHTML":{"__html":"$c"}}]}]
a:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
8:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"front-end"}],["$","meta","2",{"name":"description","content":"front-end knowledge"}],["$","link","3",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
6:null
