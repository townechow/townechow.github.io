<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/ec0a9d078e716e00.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/485ff6fe79292a08.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/0ff121a467c0636f.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-53834dba86d90934.js"/><script src="/_next/static/chunks/4bd1b696-20882bf820444624.js" async=""></script><script src="/_next/static/chunks/517-98ed787e5f259f2c.js" async=""></script><script src="/_next/static/chunks/main-app-f33d3e3aed85e21f.js" async=""></script><meta name="next-size-adjust" content=""/><title>front-end</title><meta name="description" content="front-end knowledge"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><main><div class="markdown-body"><h1>函数参数</h1><article><h1>函数参数</h1>
<h2>arguments</h2>
<p>JavaScript 中的函数定义并未指定函数形参的类型，函数调用也未对传入的实参值做任何类型检查。实际上，JavaScript 函数调用甚至不检查传入形参的个数。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>;
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>));
<span class="hljs-comment">// 2</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">foo</span>(<span class="hljs-string">&#x27;1&#x27;</span>));
<span class="hljs-comment">// &#x27;11&#x27;</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">foo</span>());
<span class="hljs-comment">// NaN</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>));
<span class="hljs-comment">// 2</span>
</code></pre>
<h3>同名形参</h3>
<p>在非严格模式下，函数中可以出现同名形参，且只能访问最后出现的该名称的形参。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x, x, x</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);
}

<span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">// 3</span>
</code></pre>
<p>而在严格模式下，出现同名形参会抛出语法错误。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x, x, x</span>) {
  <span class="hljs-string">&#x27;use strict&#x27;</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x);
}

<span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">// SyntaxError: Duplicate parameter name not allowed in this context</span>
</code></pre>
<h3>参数数量</h3>
<p>当实参比函数声明指定的形参个数要少，剩下的形参都将设置为 <code>undefined</code> 值。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x, y</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y);
  <span class="hljs-comment">// 1 undefined</span>
}

<span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>);
</code></pre>
<p><strong>默认值设置：</strong></p>
<p>常常使用逻辑或运算符给省略的参数设置一个合理的默认值。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x, y</span>) {
  y = y || <span class="hljs-number">2</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x, y);
  <span class="hljs-comment">// 1 2</span>
}

<span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>);
</code></pre>
<p>实际上，使用 <code>y || 2</code> 是不严谨的，显式地设置假值(<code>undefined</code>、<code>null</code>、<code>false</code>、<code>0</code>、<code>-0</code>、<code>''</code>、<code>NaN</code>)也会得到相同的结果。所以应该根据实际场景进行合理设置。</p>
<p>当实参比形参个数要多时，剩下的实参没有办法直接获得，需要使用即将提到的 <code>arguments</code> 对象。</p>
<p>JavaScript 中的参数在内部用一个数组表示。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数。在函数体内可以通过 <code>arguments</code> 对象来访问这个参数数组，从而获取传递给函数的每一个参数。</p>
<p><code>arguments</code> 对象并不是 <code>Array</code> 的实例，它是一个类数组对象，可以使用方括号语法访问它的每一个元素。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>], <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>], <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">2</span>]);
  <span class="hljs-comment">// 1 2 3</span>
  <span class="hljs-keyword">return</span> x + <span class="hljs-number">1</span>;
}
<span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
</code></pre>
<p><code>arguments</code> 对象的 <code>length</code> 属性显示实参的个数，函数的 <code>length</code> 属性显示形参的个数。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">x, y</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span>);
  <span class="hljs-comment">// 3</span>
}

<span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(fn.<span class="hljs-property">length</span>);
<span class="hljs-comment">// 2</span>
</code></pre>
<p>形参只是提供便利，但不是必需的。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);
  <span class="hljs-comment">// 1</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);
  <span class="hljs-comment">// 2</span>
}
</code></pre>
<p>当一个函数包含超过 3 个形参时，要记住调用函数中实参的正确顺序实在让人头疼。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">
  <span class="hljs-comment">/*array*/</span> <span class="hljs-keyword">from</span>,
  <span class="hljs-comment">/*index*/</span> form_start,
  <span class="hljs-comment">/*array*/</span> to,
  <span class="hljs-comment">/*index*/</span> to_start,
  <span class="hljs-comment">/*integer*/</span> length
</span>) {
  <span class="hljs-comment">// do something</span>
}
</code></pre>
<p>通过键/值对的形式来传入参数，这样参数的顺序就无关紧要了。定义函数的时候，传入的实参都写入一个单独的对象之中，在调用的时候传入一个对象，对象中的名/值对是真正需要的实参数据。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">args</span>) {
  <span class="hljs-title function_">fn</span>(args.<span class="hljs-property">from</span>, args.<span class="hljs-property">from_start</span> || <span class="hljs-number">0</span>, args.<span class="hljs-property">to</span>, args.<span class="hljs-property">to_start</span> || <span class="hljs-number">0</span>, args.<span class="hljs-property">length</span>);
}

<span class="hljs-keyword">const</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],
  b = [];

<span class="hljs-title function_">fn</span>({ <span class="hljs-attr">from</span>: a, <span class="hljs-attr">to</span>: b, <span class="hljs-attr">length</span>: <span class="hljs-number">4</span> });
</code></pre>
<p>ES6 的 <a href="rest-parameters">剩余参数（Rest 参数）</a> 有效地解决了函数参数过多和参数先后顺序的问题。</p>
<h3>同步</h3>
<p>当形参与实参的个数相同时，<code>arguments</code> 对象的值和对应形参的值保持同步。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">num1, num2</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1, <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);
  <span class="hljs-comment">// 1 1</span>

  <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1, <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);
  <span class="hljs-comment">// 2 2</span>

  num1 = <span class="hljs-number">10</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1, <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);
  <span class="hljs-comment">// 10 10</span>
}

<span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>);
</code></pre>
<p>虽然命名参数和对应 <code>arguments</code> 对象的值相同，但并不是相同的命名空间。它们的命名空间是独立的，但值是同步的。</p>
<p>但在严格模式下，<code>arguments</code> 对象的值和形参的值是独立的。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">num1, num2</span>) {
  <span class="hljs-string">&#x27;use strict&#x27;</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1, <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);
  <span class="hljs-comment">// 1 1</span>

  <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1, <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);
  <span class="hljs-comment">// 1 2</span>

  num1 = <span class="hljs-number">10</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1, <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]);
  <span class="hljs-comment">// 10 2</span>
}

<span class="hljs-title function_">fn</span>(<span class="hljs-number">1</span>);
</code></pre>
<p>当形参并没有对应的实参时，<code>arguments</code> 对象的值与形参的值并不对应。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">num1, num2</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1, <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">//undefined,undefined</span>

  num1 = <span class="hljs-number">10</span>;

  <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">5</span>;

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(num1, <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">//10,5</span>
}

<span class="hljs-title function_">fn</span>();
</code></pre>
<h2>内部属性</h2>
<h3>callee</h3>
<p><code>arguments</code> 对象有一个名为 <code>callee</code> 的属性，该属性是一个指针，指向拥有这个 <code>arguments</code> 对象的函数。</p>
<p>下面是经典的阶乘函数：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> num * <span class="hljs-title function_">fn</span>(num - <span class="hljs-number">1</span>);
  }
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 120</span>
</code></pre>
<p>但是，上面这个函数的执行与函数名紧紧耦合在了一起，可以使用 <code>arguments.callee</code> 可以消除函数解耦。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> num * <span class="hljs-variable language_">arguments</span>.<span class="hljs-title function_">callee</span>(num - <span class="hljs-number">1</span>);
  }
}
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-number">5</span>));
<span class="hljs-comment">// 120</span>
</code></pre>
<p>但在严格模式下，访问这个属性会抛出 TypeError 错误。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-string">&#x27;use strict&#x27;</span>;
  <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> num * <span class="hljs-variable language_">arguments</span>.<span class="hljs-title function_">callee</span>(num - <span class="hljs-number">1</span>);
  }
}

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-number">5</span>));
<span class="hljs-comment">// TypeError: &#x27;caller&#x27;, &#x27;callee&#x27;, and &#x27;arguments&#x27; properties may not be accessed on strict mode functions or the arguments objects for calls to them</span>
</code></pre>
<p>这时，可以使用具名的函数表达式。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> fn = <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">if</span> (num &lt;= <span class="hljs-number">1</span>) {
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
  } <span class="hljs-keyword">else</span> {
    <span class="hljs-keyword">return</span> num * <span class="hljs-title function_">fn</span>(num - <span class="hljs-number">1</span>);
  }
};
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-number">5</span>)); <span class="hljs-comment">//120</span>
</code></pre>
<h3>caller</h3>
<p>实际上有两个 <code>caller</code> 属性。</p>
<h4>函数的 caller</h4>
<p>函数的 <code>caller</code> 属性保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值是 <code>null</code>。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-title function_">bar</span>();
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar.<span class="hljs-property">caller</span>);
  <span class="hljs-comment">// foo(){ bar(); }</span>
}

<span class="hljs-title function_">foo</span>();
</code></pre>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">caller</span>);
  <span class="hljs-comment">// null</span>
}
<span class="hljs-title function_">foo</span>();
</code></pre>
<p>在严格模式下，访问这个属性会抛出 TypeError 错误。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-string">&#x27;use strict&#x27;</span>;
  <span class="hljs-comment">// TypeError: &#x27;caller&#x27; and &#x27;arguments&#x27; are restricted function properties and cannot be accessed in this context</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(foo.<span class="hljs-property">caller</span>);
}
<span class="hljs-title function_">foo</span>();
</code></pre>
<h4>arguments 对象的 caller</h4>
<p>该属性始终是 <code>undefined</code>，定义这个属性是为了分清 <code>arguments.caller</code> 和函数的 <code>caller</code> 属性。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">caller</span>);
  <span class="hljs-comment">// undefined</span>
}
<span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>);
</code></pre>
<p>同样地，在严格模式下，访问这个属性会抛出 TypeError 错误。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) {
  <span class="hljs-string">&#x27;use strict&#x27;</span>;
  <span class="hljs-comment">// TypeError: &#x27;caller&#x27; and &#x27;arguments&#x27; are restricted function properties and cannot be accessed in this context</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">caller</span>);
}
<span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>);
</code></pre>
<h2>参数传递</h2>
<p>JavaScript 中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制到函数内部的参数，就和把值从一个变量复制到另一个变量一样。</p>
<h3>基本类型值</h3>
<p>在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（命名参数或 <code>arguments</code> 对象的一个元素）</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) {
  x = <span class="hljs-number">1</span>;
  <span class="hljs-keyword">return</span> x;
}
<span class="hljs-keyword">let</span> y = <span class="hljs-number">2</span>;
<span class="hljs-keyword">let</span> result = <span class="hljs-title function_">foo</span>(y);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y);
<span class="hljs-comment">// 2 没有变化</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result);
<span class="hljs-comment">// 1</span>
</code></pre>
<h3>引用类型值</h3>
<p>在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">x</span>) {
  x.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;ABC&#x27;</span>;
}

<span class="hljs-keyword">var</span> y = {};
<span class="hljs-title function_">foo</span>(y);

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(y.<span class="hljs-property">name</span>);
<span class="hljs-comment">// &#x27;ABC&#x27;</span>
</code></pre>
<p>当在函数内部重写引用类型的形参时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">obj</span>) {
  obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;black&#x27;</span>;
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;black&#x27;</span>

  obj = {};
  obj.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;white&#x27;</span>;

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>); <span class="hljs-comment">// &#x27;black&#x27;</span>
}

<span class="hljs-keyword">var</span> person = {};
<span class="hljs-title function_">foo</span>(person);
</code></pre>
<h2>函数重载</h2>
<p>JavaScript 函数不能像传统意义上那样实现重载。而在其他语言中，可以为一个函数编写两个定义，只要这两个定义的签名（接受的参数的类型和数量）不同即可。</p>
<p>JavaScript 函数没有签名，因为其参数是由包含零个或多个值的数组来表示的。而没有函数签名，真正的重载是不可能做到的。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 后面的声明覆盖了前面的声明</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">addSomeNumber</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">return</span> num + <span class="hljs-number">100</span>;
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">addSomeNumber</span>(<span class="hljs-params">num</span>) {
  <span class="hljs-keyword">return</span> num + <span class="hljs-number">200</span>;
}
<span class="hljs-keyword">var</span> result = <span class="hljs-title function_">addSomeNumber</span>(<span class="hljs-number">100</span>);
<span class="hljs-comment">// 300</span>
</code></pre>
<p>只能通过检查传入函数中参数的类型和数量并作出不同的反应，来模仿方法的重载。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doAdd</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> == <span class="hljs-number">1</span>) {
    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] + <span class="hljs-number">10</span>);
  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> == <span class="hljs-number">2</span>) {
    <span class="hljs-title function_">alert</span>(<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">0</span>] + <span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);
  }
}

<span class="hljs-title function_">doAdd</span>(<span class="hljs-number">10</span>);
<span class="hljs-comment">// 20</span>
<span class="hljs-title function_">doAdd</span>(<span class="hljs-number">30</span>, <span class="hljs-number">20</span>);
<span class="hljs-comment">// 50</span>
</code></pre>
</article></div></main><script src="/_next/static/chunks/webpack-53834dba86d90934.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5244,[],\"\"]\n3:I[3866,[],\"\"]\n5:I[6213,[],\"OutletBoundary\"]\n7:I[6213,[],\"MetadataBoundary\"]\n9:I[6213,[],\"ViewportBoundary\"]\nb:I[4835,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/ec0a9d078e716e00.css\",\"style\"]\n:HL[\"/_next/static/css/485ff6fe79292a08.css\",\"style\"]\n:HL[\"/_next/static/css/0ff121a467c0636f.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"P2aiewlOc1Z9OPuSRFf3D\",\"p\":\"\",\"c\":[\"\",\"front-end\",\"core-modules\",\"ecmascript-function-objects\",\"function-arguments\",\"function-parameters\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"front-end\",{\"children\":[[\"slug\",\"core-modules/ecmascript-function-objects/function-arguments/function-parameters\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/ec0a9d078e716e00.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"front-end\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/485ff6fe79292a08.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0ff121a467c0636f.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"main\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[[\"slug\",\"core-modules/ecmascript-function-objects/function-arguments/function-parameters\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"Y-wdg3evjGqjuDU9cSwgI\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:T6714,"])</script><script>self.__next_f.push([1,"\u003ch1\u003e函数参数\u003c/h1\u003e\n\u003ch2\u003earguments\u003c/h2\u003e\n\u003cp\u003eJavaScript 中的函数定义并未指定函数形参的类型，函数调用也未对传入的实参值做任何类型检查。实际上，JavaScript 函数调用甚至不检查传入形参的个数。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e x + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e));\n\u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;1\u0026#x27;\u003c/span\u003e));\n\u003cspan class=\"hljs-comment\"\u003e// \u0026#x27;11\u0026#x27;\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e());\n\u003cspan class=\"hljs-comment\"\u003e// NaN\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e));\n\u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e同名形参\u003c/h3\u003e\n\u003cp\u003e在非严格模式下，函数中可以出现同名形参，且只能访问最后出现的该名称的形参。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex, x, x\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x);\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 3\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e而在严格模式下，出现同名形参会抛出语法错误。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex, x, x\u003c/span\u003e) {\n  \u003cspan class=\"hljs-string\"\u003e\u0026#x27;use strict\u0026#x27;\u003c/span\u003e;\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x);\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// SyntaxError: Duplicate parameter name not allowed in this context\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e参数数量\u003c/h3\u003e\n\u003cp\u003e当实参比函数声明指定的形参个数要少，剩下的形参都将设置为 \u003ccode\u003eundefined\u003c/code\u003e 值。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex, y\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x, y);\n  \u003cspan class=\"hljs-comment\"\u003e// 1 undefined\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e默认值设置：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e常常使用逻辑或运算符给省略的参数设置一个合理的默认值。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex, y\u003c/span\u003e) {\n  y = y || \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(x, y);\n  \u003cspan class=\"hljs-comment\"\u003e// 1 2\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e实际上，使用 \u003ccode\u003ey || 2\u003c/code\u003e 是不严谨的，显式地设置假值(\u003ccode\u003eundefined\u003c/code\u003e、\u003ccode\u003enull\u003c/code\u003e、\u003ccode\u003efalse\u003c/code\u003e、\u003ccode\u003e0\u003c/code\u003e、\u003ccode\u003e-0\u003c/code\u003e、\u003ccode\u003e''\u003c/code\u003e、\u003ccode\u003eNaN\u003c/code\u003e)也会得到相同的结果。所以应该根据实际场景进行合理设置。\u003c/p\u003e\n\u003cp\u003e当实参比形参个数要多时，剩下的实参没有办法直接获得，需要使用即将提到的 \u003ccode\u003earguments\u003c/code\u003e 对象。\u003c/p\u003e\n\u003cp\u003eJavaScript 中的参数在内部用一个数组表示。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数。在函数体内可以通过 \u003ccode\u003earguments\u003c/code\u003e 对象来访问这个参数数组，从而获取传递给函数的每一个参数。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003earguments\u003c/code\u003e 对象并不是 \u003ccode\u003eArray\u003c/code\u003e 的实例，它是一个类数组对象，可以使用方括号语法访问它的每一个元素。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e], \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e], \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e]);\n  \u003cspan class=\"hljs-comment\"\u003e// 1 2 3\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e x + \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n}\n\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003earguments\u003c/code\u003e 对象的 \u003ccode\u003elength\u003c/code\u003e 属性显示实参的个数，函数的 \u003ccode\u003elength\u003c/code\u003e 属性显示形参的个数。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex, y\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e);\n  \u003cspan class=\"hljs-comment\"\u003e// 3\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(fn.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e形参只是提供便利，但不是必需的。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]);\n  \u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]);\n  \u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当一个函数包含超过 3 个形参时，要记住调用函数中实参的正确顺序实在让人头疼。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\n  \u003cspan class=\"hljs-comment\"\u003e/*array*/\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e,\n  \u003cspan class=\"hljs-comment\"\u003e/*index*/\u003c/span\u003e form_start,\n  \u003cspan class=\"hljs-comment\"\u003e/*array*/\u003c/span\u003e to,\n  \u003cspan class=\"hljs-comment\"\u003e/*index*/\u003c/span\u003e to_start,\n  \u003cspan class=\"hljs-comment\"\u003e/*integer*/\u003c/span\u003e length\n\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// do something\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e通过键/值对的形式来传入参数，这样参数的顺序就无关紧要了。定义函数的时候，传入的实参都写入一个单独的对象之中，在调用的时候传入一个对象，对象中的名/值对是真正需要的实参数据。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eargs\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(args.\u003cspan class=\"hljs-property\"\u003efrom\u003c/span\u003e, args.\u003cspan class=\"hljs-property\"\u003efrom_start\u003c/span\u003e || \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, args.\u003cspan class=\"hljs-property\"\u003eto\u003c/span\u003e, args.\u003cspan class=\"hljs-property\"\u003eto_start\u003c/span\u003e || \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e, args.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e a = [\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e],\n  b = [];\n\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e({ \u003cspan class=\"hljs-attr\"\u003efrom\u003c/span\u003e: a, \u003cspan class=\"hljs-attr\"\u003eto\u003c/span\u003e: b, \u003cspan class=\"hljs-attr\"\u003elength\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e });\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003eES6 的 \u003ca href=\"rest-parameters\"\u003e剩余参数（Rest 参数）\u003c/a\u003e 有效地解决了函数参数过多和参数先后顺序的问题。\u003c/p\u003e\n\u003ch3\u003e同步\u003c/h3\u003e\n\u003cp\u003e当形参与实参的个数相同时，\u003ccode\u003earguments\u003c/code\u003e 对象的值和对应形参的值保持同步。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enum1, num2\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(num1, \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]);\n  \u003cspan class=\"hljs-comment\"\u003e// 1 1\u003c/span\u003e\n\n  \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(num1, \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]);\n  \u003cspan class=\"hljs-comment\"\u003e// 2 2\u003c/span\u003e\n\n  num1 = \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e;\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(num1, \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]);\n  \u003cspan class=\"hljs-comment\"\u003e// 10 10\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e虽然命名参数和对应 \u003ccode\u003earguments\u003c/code\u003e 对象的值相同，但并不是相同的命名空间。它们的命名空间是独立的，但值是同步的。\u003c/p\u003e\n\u003cp\u003e但在严格模式下，\u003ccode\u003earguments\u003c/code\u003e 对象的值和形参的值是独立的。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enum1, num2\u003c/span\u003e) {\n  \u003cspan class=\"hljs-string\"\u003e\u0026#x27;use strict\u0026#x27;\u003c/span\u003e;\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(num1, \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]);\n  \u003cspan class=\"hljs-comment\"\u003e// 1 1\u003c/span\u003e\n\n  \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(num1, \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]);\n  \u003cspan class=\"hljs-comment\"\u003e// 1 2\u003c/span\u003e\n\n  num1 = \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e;\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(num1, \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]);\n  \u003cspan class=\"hljs-comment\"\u003e// 10 2\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当形参并没有对应的实参时，\u003ccode\u003earguments\u003c/code\u003e 对象的值与形参的值并不对应。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enum1, num2\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(num1, \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e//undefined,undefined\u003c/span\u003e\n\n  num1 = \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] = \u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(num1, \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e]); \u003cspan class=\"hljs-comment\"\u003e//10,5\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e内部属性\u003c/h2\u003e\n\u003ch3\u003ecallee\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003earguments\u003c/code\u003e 对象有一个名为 \u003ccode\u003ecallee\u003c/code\u003e 的属性，该属性是一个指针，指向拥有这个 \u003ccode\u003earguments\u003c/code\u003e 对象的函数。\u003c/p\u003e\n\u003cp\u003e下面是经典的阶乘函数：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enum\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (num \u0026lt;= \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e num * \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(num - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  }\n}\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e// 120\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但是，上面这个函数的执行与函数名紧紧耦合在了一起，可以使用 \u003ccode\u003earguments.callee\u003c/code\u003e 可以消除函数解耦。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enum\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (num \u0026lt;= \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e num * \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecallee\u003c/span\u003e(num - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  }\n}\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e));\n\u003cspan class=\"hljs-comment\"\u003e// 120\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但在严格模式下，访问这个属性会抛出 TypeError 错误。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enum\u003c/span\u003e) {\n  \u003cspan class=\"hljs-string\"\u003e\u0026#x27;use strict\u0026#x27;\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (num \u0026lt;= \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e num * \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecallee\u003c/span\u003e(num - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  }\n}\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e));\n\u003cspan class=\"hljs-comment\"\u003e// TypeError: \u0026#x27;caller\u0026#x27;, \u0026#x27;callee\u0026#x27;, and \u0026#x27;arguments\u0026#x27; properties may not be accessed on strict mode functions or the arguments objects for calls to them\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这时，可以使用具名的函数表达式。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e fn = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enum\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (num \u0026lt;= \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e num * \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(num - \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n  }\n};\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e)); \u003cspan class=\"hljs-comment\"\u003e//120\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003ecaller\u003c/h3\u003e\n\u003cp\u003e实际上有两个 \u003ccode\u003ecaller\u003c/code\u003e 属性。\u003c/p\u003e\n\u003ch4\u003e函数的 caller\u003c/h4\u003e\n\u003cp\u003e函数的 \u003ccode\u003ecaller\u003c/code\u003e 属性保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值是 \u003ccode\u003enull\u003c/code\u003e。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e();\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(bar.\u003cspan class=\"hljs-property\"\u003ecaller\u003c/span\u003e);\n  \u003cspan class=\"hljs-comment\"\u003e// foo(){ bar(); }\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(foo.\u003cspan class=\"hljs-property\"\u003ecaller\u003c/span\u003e);\n  \u003cspan class=\"hljs-comment\"\u003e// null\u003c/span\u003e\n}\n\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在严格模式下，访问这个属性会抛出 TypeError 错误。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-string\"\u003e\u0026#x27;use strict\u0026#x27;\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// TypeError: \u0026#x27;caller\u0026#x27; and \u0026#x27;arguments\u0026#x27; are restricted function properties and cannot be accessed in this context\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(foo.\u003cspan class=\"hljs-property\"\u003ecaller\u003c/span\u003e);\n}\n\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003earguments 对象的 caller\u003c/h4\u003e\n\u003cp\u003e该属性始终是 \u003ccode\u003eundefined\u003c/code\u003e，定义这个属性是为了分清 \u003ccode\u003earguments.caller\u003c/code\u003e 和函数的 \u003ccode\u003ecaller\u003c/code\u003e 属性。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecaller\u003c/span\u003e);\n  \u003cspan class=\"hljs-comment\"\u003e// undefined\u003c/span\u003e\n}\n\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e同样地，在严格模式下，访问这个属性会抛出 TypeError 错误。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e) {\n  \u003cspan class=\"hljs-string\"\u003e\u0026#x27;use strict\u0026#x27;\u003c/span\u003e;\n  \u003cspan class=\"hljs-comment\"\u003e// TypeError: \u0026#x27;caller\u0026#x27; and \u0026#x27;arguments\u0026#x27; are restricted function properties and cannot be accessed in this context\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ecaller\u003c/span\u003e);\n}\n\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e参数传递\u003c/h2\u003e\n\u003cp\u003eJavaScript 中所有函数的参数都是按值传递的。也就是说，把函数外部的值复制到函数内部的参数，就和把值从一个变量复制到另一个变量一样。\u003c/p\u003e\n\u003ch3\u003e基本类型值\u003c/h3\u003e\n\u003cp\u003e在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（命名参数或 \u003ccode\u003earguments\u003c/code\u003e 对象的一个元素）\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e) {\n  x = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e x;\n}\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e y = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e result = \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(y);\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(y);\n\u003cspan class=\"hljs-comment\"\u003e// 2 没有变化\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(result);\n\u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e引用类型值\u003c/h3\u003e\n\u003cp\u003e在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ex\u003c/span\u003e) {\n  x.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;ABC\u0026#x27;\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e y = {};\n\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(y);\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(y.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// \u0026#x27;ABC\u0026#x27;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当在函数内部重写引用类型的形参时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eobj\u003c/span\u003e) {\n  obj.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;black\u0026#x27;\u003c/span\u003e;\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(person.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// \u0026#x27;black\u0026#x27;\u003c/span\u003e\n\n  obj = {};\n  obj.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;white\u0026#x27;\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(person.\u003cspan class=\"hljs-property\"\u003ename\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// \u0026#x27;black\u0026#x27;\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e person = {};\n\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(person);\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e函数重载\u003c/h2\u003e\n\u003cp\u003eJavaScript 函数不能像传统意义上那样实现重载。而在其他语言中，可以为一个函数编写两个定义，只要这两个定义的签名（接受的参数的类型和数量）不同即可。\u003c/p\u003e\n\u003cp\u003eJavaScript 函数没有签名，因为其参数是由包含零个或多个值的数组来表示的。而没有函数签名，真正的重载是不可能做到的。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 后面的声明覆盖了前面的声明\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eaddSomeNumber\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enum\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e num + \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e;\n}\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eaddSomeNumber\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enum\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e num + \u003cspan class=\"hljs-number\"\u003e200\u003c/span\u003e;\n}\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e result = \u003cspan class=\"hljs-title function_\"\u003eaddSomeNumber\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 300\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e只能通过检查传入函数中参数的类型和数量并作出不同的反应，来模仿方法的重载。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edoAdd\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e == \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003ealert\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] + \u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e);\n  } \u003cspan class=\"hljs-keyword\"\u003eelse\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (\u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elength\u003c/span\u003e == \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e) {\n    \u003cspan class=\"hljs-title function_\"\u003ealert\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e] + \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e[\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e]);\n  }\n}\n\n\u003cspan class=\"hljs-title function_\"\u003edoAdd\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e10\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 20\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003edoAdd\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e30\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 50\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"markdown-body\",\"children\":[[\"$\",\"h1\",null,{\"children\":\"函数参数\"}],[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"front-end\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"front-end knowledge\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>