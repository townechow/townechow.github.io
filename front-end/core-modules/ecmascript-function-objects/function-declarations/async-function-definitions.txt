1:"$Sreact.fragment"
2:I[5244,[],""]
3:I[3866,[],""]
5:I[6213,[],"OutletBoundary"]
7:I[6213,[],"MetadataBoundary"]
9:I[6213,[],"ViewportBoundary"]
b:I[4835,[],""]
:HL["/_next/static/media/569ce4b8f30dc480-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/media/93f479601ee12b01-s.p.woff2","font",{"crossOrigin":"","type":"font/woff2"}]
:HL["/_next/static/css/ec0a9d078e716e00.css","style"]
:HL["/_next/static/css/485ff6fe79292a08.css","style"]
:HL["/_next/static/css/0ff121a467c0636f.css","style"]
0:{"P":null,"b":"NW9bMA21iAaih0TqCHqj1","p":"","c":["","front-end","core-modules","ecmascript-function-objects","function-declarations","async-function-definitions"],"i":false,"f":[[["",{"children":["front-end",{"children":[["slug","core-modules/ecmascript-function-objects/function-declarations/async-function-definitions","oc"],{"children":["__PAGE__",{}]}]}]},"$undefined","$undefined",true],["",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/ec0a9d078e716e00.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","html",null,{"lang":"en","children":["$","body",null,{"className":"__variable_4d318d __variable_ea5f4b antialiased","children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":[[],[["$","title",null,{"children":"404: This page could not be found."}],["$","div",null,{"style":{"fontFamily":"system-ui,\"Segoe UI\",Roboto,Helvetica,Arial,sans-serif,\"Apple Color Emoji\",\"Segoe UI Emoji\"","height":"100vh","textAlign":"center","display":"flex","flexDirection":"column","alignItems":"center","justifyContent":"center"},"children":["$","div",null,{"children":[["$","style",null,{"dangerouslySetInnerHTML":{"__html":"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}"}}],["$","h1",null,{"className":"next-error-h1","style":{"display":"inline-block","margin":"0 20px 0 0","padding":"0 23px 0 0","fontSize":24,"fontWeight":500,"verticalAlign":"top","lineHeight":"49px"},"children":404}],["$","div",null,{"style":{"display":"inline-block"},"children":["$","h2",null,{"style":{"fontSize":14,"fontWeight":400,"lineHeight":"49px","margin":0},"children":"This page could not be found."}]}]]}]}]]],"forbidden":"$undefined","unauthorized":"$undefined"}]}]}]]}],{"children":["front-end",["$","$1","c",{"children":[[["$","link","0",{"rel":"stylesheet","href":"/_next/static/css/485ff6fe79292a08.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}],["$","link","1",{"rel":"stylesheet","href":"/_next/static/css/0ff121a467c0636f.css","precedence":"next","crossOrigin":"$undefined","nonce":"$undefined"}]],["$","main",null,{"children":["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","front-end","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]}]]}],{"children":[["slug","core-modules/ecmascript-function-objects/function-declarations/async-function-definitions","oc"],["$","$1","c",{"children":[null,["$","$L2",null,{"parallelRouterKey":"children","segmentPath":["children","front-end","children","$0:f:0:1:2:children:2:children:0","children"],"error":"$undefined","errorStyles":"$undefined","errorScripts":"$undefined","template":["$","$L3",null,{}],"templateStyles":"$undefined","templateScripts":"$undefined","notFound":"$undefined","forbidden":"$undefined","unauthorized":"$undefined"}]]}],{"children":["__PAGE__",["$","$1","c",{"children":["$L4",null,["$","$L5",null,{"children":"$L6"}]]}],{},null,false]},null,false]},null,false]},null,false],["$","$1","h",{"children":[null,["$","$1","tBwTgKC7DWld2xj2PFaZ1",{"children":[["$","$L7",null,{"children":"$L8"}],["$","$L9",null,{"children":"$La"}],["$","meta",null,{"name":"next-size-adjust","content":""}]]}]]}],false]],"m":"$undefined","G":["$b","$undefined"],"s":false,"S":true}
c:T784f,<h1>异步函数</h1>
<p><code>async</code> 函数是 <a href="/front-end/standard-built-in-objects/control-abstraction-objects/generator">Generator</a> 函数的语法糖。使用关键字 <code>async</code> 来表示，在函数内部是使用 <code>await</code> 命令来表示异步。</p>
<p>相较于 Generator，<code>async</code> 函数的改进在于以下四点：</p>
<ul>
<li><strong>内置执行器</strong>：Generator 函数的执行必须靠执行器，而 <code>async</code> 函数自带执行器，调用方式与普通函数一致。</li>
<li><strong>更好的语义</strong>：<code>async</code> 和 <code>await</code> 相较于星号（<code>*</code>）和 <code>yield</code> 更加语义化。<code>async</code> 表示函数中有异步操作，<code>await</code> 表示紧跟在后面的表达式需要等待结果。</li>
<li><strong>更广的适用性</strong>：<code>co</code> 模块约定，<code>yield</code> 命令后面只能是 Thunk 函数或 Promise 对象，而 <code>async</code> 函数的 <code>await</code> 命令后面则可以是 Promise 和原始类型的值（Number、String 和 Boolean，但这时会自动转成立即 <code>fulfilled</code> 状态的 Promise 对象）。</li>
<li><strong>返回值是 Promise</strong>：<code>async</code> 函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用 <code>then</code> 方法指定下一步的操作。</li>
</ul>
<p>进一步说，<code>async</code> 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 <code>await</code> 命令就是内部 <code>then</code> 命令的语法糖。</p>
<p><strong><code>async</code>函数与 Generator 函数的对比</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">async 函数</th>
<th style="text-align:left">Generator 函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>定义方式</strong></td>
<td style="text-align:left"><code>async function(){}</code></td>
<td style="text-align:left"><code>function* (){}</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>异步语句命令</strong></td>
<td style="text-align:left"><code>await</code></td>
<td style="text-align:left"><code>yield</code></td>
</tr>
</tbody>
</table>
<h2>基本用法</h2>
<h3>异步函数的声明</h3>
<p>凡是在函数声明前添加 <code>async</code> 关键字的函数在执行后都会自动返回 Promise 对象。</p>
<p><code>async</code> 函数返回一个 Promise 对象，可以使用 <code>then</code> 方法添加回调函数。当函数执行的时候，一旦遇到 <code>await</code> 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">timeout</span>(<span class="hljs-params">ms</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, ms));
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">arg1, ms</span>) {
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">timeout</span>(ms);
  <span class="hljs-keyword">return</span> arg1;
}

<span class="hljs-title function_">foo</span>(<span class="hljs-string">&#x27;Hello world!&#x27;</span>, <span class="hljs-number">500</span>).<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>);
<span class="hljs-comment">// &#x27;Hello world!&#x27;</span>
</code></pre>
<h3>异步函数的语句</h3>
<p><code>await</code> 命令必须在 <code>async</code> 函数里使用，不能单独使用。</p>
<p>由于 <code>async</code> 函数返回的是 Promise 对象，可以作为 <code>await</code> 命令的参数。</p>
<h3>异步语句返回值</h3>
<p><code>await</code> 后需跟 Promise。</p>
<p><code>await</code> 作用之一就是获取随后 Promise 对象成功状态传递出来的参数。</p>
<p><code>await</code> 命令只能用在 <code>async</code> 函数中，否则会报错。</p>
<h2>语法</h2>
<h3>返回值类型</h3>
<p><code>async</code> 函数返回一个 Promise 对象</p>
<p><code>async</code> 函数内部 <code>return</code> 语句返回的值，会成为 <code>then</code> 方法回调函数的参数。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello world!&#x27;</span>;
}

<span class="hljs-title function_">foo</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res));
<span class="hljs-comment">// &#x27;Hello world!&#x27;</span>
</code></pre>
<p>如果 <code>async</code> 函数内部抛出异常，则会导致返回的 Promise 对象状态变为 <code>rejected</code> 状态。抛出的错误而会被 <code>catch</code> 方法回调函数接收到。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Error&#x27;</span>);
}

<span class="hljs-title function_">foo</span>()
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err));
</code></pre>
<h3>返回值状态变化</h3>
<p><code>async</code> 函数返回的 Promise 对象，必须等到内部所有 <code>await</code> 命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到 <code>return</code> 语句或者抛出错误。也就是说，只有 <code>async</code> 函数内部的异步操作执行完，才会执行 <code>then</code> 方法指定的回调函数。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">delay</span> = (<span class="hljs-params">timeout</span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, timeout));

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>);
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">delay</span>(<span class="hljs-number">2000</span>);
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">delay</span>(<span class="hljs-number">3000</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;done&#x27;</span>;
}

<span class="hljs-title function_">foo</span>().<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>);
<span class="hljs-comment">// &#x27;done&#x27;</span>
</code></pre>
<p>上面代码中，函数 <code>foo</code> 内部有三个延迟函数。只有这三个操作依次完成，才会执行 <code>then</code> 方法里面的 <code>console.log</code>。</p>
<h3>异步语句返回值</h3>
<p>正常情况下，异步语句 <code>await</code> 命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">async</span> funciont <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-number">1</span>
}

fn.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res));
<span class="hljs-comment">// 1</span>
</code></pre>
<h2>异常处理</h2>
<h3>捕捉异常</h3>
<p>任何一个 <code>await</code> 语句后面的 Promise 对象变为 <code>rejected</code> 状态，那么整个 <code>async</code> 函数都会中断执行。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;Error!&#x27;</span>);
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Hello world!&#x27;</span>);
  <span class="hljs-comment">// 不会执行</span>
}
</code></pre>
<p>当 <code>async</code> 异步函数中只要有一个 <code>await</code> 异步语句返回的 Promise 处于 <code>rejected</code> 状态，则后面的 <code>await</code> 异步语句都不会执行。</p>
<p><strong>解决方法</strong>：使用 <a href="/front-end/basic-concept/statements-and-declarations/the-try-statement">try-catch 语句</a> 或在 <code>await</code> 返回的 Promise 添加 <code>catch</code> 方法捕捉错误。</p>
<p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个 <code>await</code> 放在 <code>try...catch</code> 结构里面，这样不管这个异步操作是否成功，第二个 <code>await</code> 都会执行。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;Error!&#x27;</span>);
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-comment">// do something</span>
  }

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Hello world!&#x27;</span>);
}

<span class="hljs-title function_">foo</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res));
<span class="hljs-comment">// &#x27;Hello world!&#x27;</span>
</code></pre>
<p>另一种方法是 <code>await</code> 后面的 Promise 对象再跟一个 <code>catch</code> 方法，处理前面可能出现的错误。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;Error!&#x27;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e));

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Hello world!&#x27;</span>);
}

<span class="hljs-title function_">foo</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res));
<span class="hljs-comment">// &#x27;Error!&#x27;</span>
<span class="hljs-comment">// &#x27;Hello world!&#x27;</span>
</code></pre>
<h3>操作中断</h3>
<p>如果 <code>await</code> 后面的异步操作出错，那么等同于 <code>async</code> 函数返回的 Promise 对象被 <code>reject</code>。</p>
<p>使用 <code>try...catch</code> 语句，实现多次重复尝试。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;superagent&#x27;</span>);
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">NUM_RETRIES</span> = <span class="hljs-number">3</span>;

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> i;
  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable constant_">NUM_RETRIES</span>; i++) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> superagent.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://google.com/this-throws-an-error&#x27;</span>);
      <span class="hljs-keyword">break</span>;
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-comment">// do something</span>
    }
  }

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);
  <span class="hljs-comment">// 3</span>
}

<span class="hljs-title function_">foo</span>();
</code></pre>
<p>如果 <code>await</code> 操作成功，就会使用 <code>break</code> 语句退出循环；如果失败，会被 <code>catch</code> 语句捕捉，然后进入下一轮循环。</p>
<h2>实现原理</h2>
<p><code>async</code> 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>相当于：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">args</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">spawn</span>(<span class="hljs-keyword">function</span>* () {
    <span class="hljs-comment">// ...</span>
  });
}
</code></pre>
<p>所有的 <code>async</code> 函数都可以写成上面的第二种形式，其中的 <code>spawn</code> 函数就是自动执行器。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">spawn</span>(<span class="hljs-params">genF</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) {
    <span class="hljs-keyword">const</span> gen = <span class="hljs-title function_">genF</span>();
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">step</span>(<span class="hljs-params">nextF</span>) {
      <span class="hljs-keyword">let</span> next;
      <span class="hljs-keyword">try</span> {
        next = <span class="hljs-title function_">nextF</span>();
      } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(e);
      }
      <span class="hljs-keyword">if</span> (next.<span class="hljs-property">done</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(next.<span class="hljs-property">value</span>);
      }
      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(next.<span class="hljs-property">value</span>).<span class="hljs-title function_">then</span>(
        <span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) {
          <span class="hljs-title function_">step</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
            <span class="hljs-keyword">return</span> gen.<span class="hljs-title function_">next</span>(v);
          });
        },
        <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) {
          <span class="hljs-title function_">step</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
            <span class="hljs-keyword">return</span> gen.<span class="hljs-keyword">throw</span>(e);
          });
        }
      );
    }
    <span class="hljs-title function_">step</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> gen.<span class="hljs-title function_">next</span>(<span class="hljs-literal">undefined</span>);
    });
  });
}
</code></pre>
<h2>最佳实践</h2>
<h3>异步阻塞</h3>
<p>后面请求的发送总是需要依赖上一个请求返回的数据。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">time</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, rejecr</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">resolve</span>(time);
    }, time);
  });
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getResult</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">request</span>(<span class="hljs-number">500</span>);
  <span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">request</span>(p1 + <span class="hljs-number">1000</span>);
  <span class="hljs-keyword">let</span> p3 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">request</span>(p2 + <span class="hljs-number">1000</span>);
  <span class="hljs-keyword">return</span> p3;
}

<span class="hljs-title function_">getResult</span>()
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);
  });
</code></pre>
<h3>异步非阻塞</h3>
<p>在某些业务场景下，开发者可能需要处理多个连续步骤的操作，但是这些操作未必相互依赖。因此需要对这些操作进行优化。</p>
<p>综合上述 <a href="/front-end/core-modules/ecmascript-function-objects/function-declarations/#%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E">异步阻塞</a> 和 <a href="/front-end/core-modules/ecmascript-function-objects/function-declarations/#%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91">异步并发</a>，我们可以利用 Event Loop 的优势并发执行这些非阻塞异步函数。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 选择披萨</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">selectPizza</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 异步获取披萨数据</span>
  <span class="hljs-keyword">const</span> pizzaData = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getPizzaData</span>();
  <span class="hljs-comment">// 选择披萨</span>
  <span class="hljs-keyword">const</span> chosenPizza = <span class="hljs-title function_">choosePizza</span>();
  <span class="hljs-comment">// 异步添加选中披萨到购物车</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">addPizzaToCart</span>(chosenPizza);
}

<span class="hljs-comment">// 选择饮料</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">selectDrink</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 异步获取饮料数据</span>
  <span class="hljs-keyword">const</span> drinkData = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getDrinkData</span>();
  <span class="hljs-comment">// 选择饮料</span>
  <span class="hljs-keyword">const</span> chosenDrink = <span class="hljs-title function_">chooseDrink</span>();
  <span class="hljs-comment">// 异步添加选中饮料到购物车</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">addDrinkToCart</span>(chosenDrink);
}

(<span class="hljs-title function_">async</span> () =&gt; {
  <span class="hljs-comment">// 并发执行这些非阻塞异步函数</span>
  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-title function_">selectPizza</span>(), <span class="hljs-title function_">selectDrink</span>()]).<span class="hljs-title function_">then</span>(orderItems);
})();
</code></pre>
<p>补充一种与之相关的比较优雅的写法。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<span class="hljs-title function_">selectPizza</span>().<span class="hljs-title function_">then</span>(choosePizza), <span class="hljs-title function_">selectDrink</span>().<span class="hljs-title function_">then</span>(chooseDrink));
</code></pre>
<h3>异步并发</h3>
<p>多个网络请求是非继发关系，最好使用 <code>Promise.all</code> 方法实现同时触发。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> [userList, orderList] = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-title function_">getUserList</span>(), <span class="hljs-title function_">getOrderList</span>()]);

<span class="hljs-keyword">let</span> userPromise = <span class="hljs-title function_">getUserList</span>();
<span class="hljs-keyword">let</span> orderPromise = <span class="hljs-title function_">getOrderList</span>();

<span class="hljs-keyword">let</span> user = <span class="hljs-keyword">await</span> userPromise;
<span class="hljs-keyword">let</span> order = <span class="hljs-keyword">await</span> orderPromise;
</code></pre>
<p>上面两种写法，<code>getUserList</code> 和 <code>getOrderList</code> 都是同时触发，这样就会缩短程序的执行时间。</p>
<h3>未知数量的异步并发</h3>
<p>承接上个实践方案，当我们需要解决未知数量的 Promise 的时候，我们只需要创建数组并存储它们，然后同样使用 <code>Promise.all</code> 方法就能够并发地等待所有 Promise 返回结果。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 批量配置项</span>
  <span class="hljs-keyword">const</span> items = <span class="hljs-keyword">await</span> <span class="hljs-title function_">batchDisposal</span>();
  <span class="hljs-comment">// 每个配置项对应一个异步请求</span>
  <span class="hljs-keyword">const</span> promises = items.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> <span class="hljs-title function_">sendRequest</span>(item));
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promises);
}
</code></pre>
<h3>不等待结果的异步循环</h3>
<p><code>await</code> 每次循环任务，注意遍历执行的匿名函数也要设置为 <code>async</code> 异步函数。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">delay</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">300</span>));
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">delayedLog</span>(<span class="hljs-params">item</span>) {
  <span class="hljs-comment">// notice that we can await a function that returns promise</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">delay</span>();
  <span class="hljs-comment">// log item only after a delay</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">tasks</span>) {
  tasks.<span class="hljs-title function_">forEach</span>(<span class="hljs-title function_">async</span> (item) =&gt; {
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">delayLog</span>(item);
  });

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;DONE!&#x27;</span>);
}
</code></pre>
<h3>异步串行遍历</h3>
<p>要等待所有的结果返回，我们还是要回到老式的 <code>for</code> 循环写法：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">tasks</span>) {
  <span class="hljs-keyword">let</span> result = [];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> task <span class="hljs-keyword">of</span> tasks) {
    <span class="hljs-keyword">try</span> {
      result.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">task</span>());
    } <span class="hljs-keyword">catch</span> (err) {
      result.<span class="hljs-title function_">push</span>(<span class="hljs-literal">null</span>);
    }
  }

  <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p>上面这段的遍历是 <strong>串行</strong> 执行的，我们也可以把它转换成 <strong>并行</strong> 的。</p>
<h3>异步并行遍历</h3>
<p>我们可以通过更改上面的代码来实现并行的异步操作：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">tasks</span>) {
  <span class="hljs-comment">// map tasks to promises</span>
  <span class="hljs-keyword">const</span> promises = tasks.<span class="hljs-title function_">map</span>(delayLog);
  <span class="hljs-comment">// wait until all promises are resolved</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promises);

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;DONE!&#x27;</span>);
}
</code></pre>
<h2>参考资料</h2>
<ul>
<li><a href="http://es6.ruanyifeng.com/#docs/async" target="_blank" rel="noopener noreferrer nofollow">📚 《ECMAScript 6 入门》</a></li>
<li><a href="https://juejin.im/post/5beea5f5f265da61590b40cd" target="_blank" rel="noopener noreferrer nofollow">📝 译文：更快的 async 函数和 Promise</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/30500894" target="_blank" rel="noopener noreferrer nofollow">📝 译文：图与例解读 Async/Await</a></li>
</ul>
4:["$","div",null,{"className":"markdown-body","children":["$","article",null,{"dangerouslySetInnerHTML":{"__html":"$c"}}]}]
a:[["$","meta","0",{"name":"viewport","content":"width=device-width, initial-scale=1"}]]
8:[["$","meta","0",{"charSet":"utf-8"}],["$","title","1",{"children":"front-end"}],["$","meta","2",{"name":"description","content":"front-end knowledge"}],["$","link","3",{"rel":"icon","href":"/favicon.ico","type":"image/x-icon","sizes":"16x16"}]]
6:null
