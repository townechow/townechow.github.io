<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/d498c84e4ab246b3.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/485ff6fe79292a08.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/b9d97b2190475167.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/851cdee6d90716dd.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-78112f590b744806.js"/><script src="/_next/static/chunks/4bd1b696-20882bf820444624.js" async=""></script><script src="/_next/static/chunks/517-98ed787e5f259f2c.js" async=""></script><script src="/_next/static/chunks/main-app-f33d3e3aed85e21f.js" async=""></script><meta name="next-size-adjust" content=""/><title>front-end</title><meta name="description" content="front-end knowledge"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><main><div class="markdown-body"><article><h1>异步函数</h1>
<p><code>async</code> 函数是 <a href="/front-end/standard-built-in-objects/control-abstraction-objects/generator">Generator</a> 函数的语法糖。使用关键字 <code>async</code> 来表示，在函数内部是使用 <code>await</code> 命令来表示异步。</p>
<p>相较于 Generator，<code>async</code> 函数的改进在于以下四点：</p>
<ul>
<li><strong>内置执行器</strong>：Generator 函数的执行必须靠执行器，而 <code>async</code> 函数自带执行器，调用方式与普通函数一致。</li>
<li><strong>更好的语义</strong>：<code>async</code> 和 <code>await</code> 相较于星号（<code>*</code>）和 <code>yield</code> 更加语义化。<code>async</code> 表示函数中有异步操作，<code>await</code> 表示紧跟在后面的表达式需要等待结果。</li>
<li><strong>更广的适用性</strong>：<code>co</code> 模块约定，<code>yield</code> 命令后面只能是 Thunk 函数或 Promise 对象，而 <code>async</code> 函数的 <code>await</code> 命令后面则可以是 Promise 和原始类型的值（Number、String 和 Boolean，但这时会自动转成立即 <code>fulfilled</code> 状态的 Promise 对象）。</li>
<li><strong>返回值是 Promise</strong>：<code>async</code> 函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用 <code>then</code> 方法指定下一步的操作。</li>
</ul>
<p>进一步说，<code>async</code> 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 <code>await</code> 命令就是内部 <code>then</code> 命令的语法糖。</p>
<p><strong><code>async</code>函数与 Generator 函数的对比</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">async 函数</th>
<th style="text-align:left">Generator 函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>定义方式</strong></td>
<td style="text-align:left"><code>async function(){}</code></td>
<td style="text-align:left"><code>function* (){}</code></td>
</tr>
<tr>
<td style="text-align:left"><strong>异步语句命令</strong></td>
<td style="text-align:left"><code>await</code></td>
<td style="text-align:left"><code>yield</code></td>
</tr>
</tbody>
</table>
<h2>基本用法</h2>
<h3>异步函数的声明</h3>
<p>凡是在函数声明前添加 <code>async</code> 关键字的函数在执行后都会自动返回 Promise 对象。</p>
<p><code>async</code> 函数返回一个 Promise 对象，可以使用 <code>then</code> 方法添加回调函数。当函数执行的时候，一旦遇到 <code>await</code> 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">timeout</span>(<span class="hljs-params">ms</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, ms));
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">arg1, ms</span>) {
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">timeout</span>(ms);
  <span class="hljs-keyword">return</span> arg1;
}

<span class="hljs-title function_">foo</span>(<span class="hljs-string">&#x27;Hello world!&#x27;</span>, <span class="hljs-number">500</span>).<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>);
<span class="hljs-comment">// &#x27;Hello world!&#x27;</span>
</code></pre>
<h3>异步函数的语句</h3>
<p><code>await</code> 命令必须在 <code>async</code> 函数里使用，不能单独使用。</p>
<p>由于 <code>async</code> 函数返回的是 Promise 对象，可以作为 <code>await</code> 命令的参数。</p>
<h3>异步语句返回值</h3>
<p><code>await</code> 后需跟 Promise。</p>
<p><code>await</code> 作用之一就是获取随后 Promise 对象成功状态传递出来的参数。</p>
<p><code>await</code> 命令只能用在 <code>async</code> 函数中，否则会报错。</p>
<h2>语法</h2>
<h3>返回值类型</h3>
<p><code>async</code> 函数返回一个 Promise 对象</p>
<p><code>async</code> 函数内部 <code>return</code> 语句返回的值，会成为 <code>then</code> 方法回调函数的参数。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;Hello world!&#x27;</span>;
}

<span class="hljs-title function_">foo</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res));
<span class="hljs-comment">// &#x27;Hello world!&#x27;</span>
</code></pre>
<p>如果 <code>async</code> 函数内部抛出异常，则会导致返回的 Promise 对象状态变为 <code>rejected</code> 状态。抛出的错误而会被 <code>catch</code> 方法回调函数接收到。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Error&#x27;</span>);
}

<span class="hljs-title function_">foo</span>()
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res))
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err));
</code></pre>
<h3>返回值状态变化</h3>
<p><code>async</code> 函数返回的 Promise 对象，必须等到内部所有 <code>await</code> 命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到 <code>return</code> 语句或者抛出错误。也就是说，只有 <code>async</code> 函数内部的异步操作执行完，才会执行 <code>then</code> 方法指定的回调函数。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">const</span> <span class="hljs-title function_">delay</span> = (<span class="hljs-params">timeout</span>) =&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, timeout));

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">delay</span>(<span class="hljs-number">1000</span>);
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">delay</span>(<span class="hljs-number">2000</span>);
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">delay</span>(<span class="hljs-number">3000</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;done&#x27;</span>;
}

<span class="hljs-title function_">foo</span>().<span class="hljs-title function_">then</span>(<span class="hljs-variable language_">console</span>.<span class="hljs-property">log</span>);
<span class="hljs-comment">// &#x27;done&#x27;</span>
</code></pre>
<p>上面代码中，函数 <code>foo</code> 内部有三个延迟函数。只有这三个操作依次完成，才会执行 <code>then</code> 方法里面的 <code>console.log</code>。</p>
<h3>异步语句返回值</h3>
<p>正常情况下，异步语句 <code>await</code> 命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">async</span> funciont <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>){
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-number">1</span>
}

fn.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res));
<span class="hljs-comment">// 1</span>
</code></pre>
<h2>异常处理</h2>
<h3>捕捉异常</h3>
<p>任何一个 <code>await</code> 语句后面的 Promise 对象变为 <code>rejected</code> 状态，那么整个 <code>async</code> 函数都会中断执行。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;Error!&#x27;</span>);
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Hello world!&#x27;</span>);
  <span class="hljs-comment">// 不会执行</span>
}
</code></pre>
<p>当 <code>async</code> 异步函数中只要有一个 <code>await</code> 异步语句返回的 Promise 处于 <code>rejected</code> 状态，则后面的 <code>await</code> 异步语句都不会执行。</p>
<p><strong>解决方法</strong>：使用 <a href="/front-end/basic-concept/statements-and-declarations/the-try-statement">try-catch 语句</a> 或在 <code>await</code> 返回的 Promise 添加 <code>catch</code> 方法捕捉错误。</p>
<p>有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个 <code>await</code> 放在 <code>try...catch</code> 结构里面，这样不管这个异步操作是否成功，第二个 <code>await</code> 都会执行。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;Error!&#x27;</span>);
  } <span class="hljs-keyword">catch</span> (err) {
    <span class="hljs-comment">// do something</span>
  }

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Hello world!&#x27;</span>);
}

<span class="hljs-title function_">foo</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res));
<span class="hljs-comment">// &#x27;Hello world!&#x27;</span>
</code></pre>
<p>另一种方法是 <code>await</code> 后面的 Promise 对象再跟一个 <code>catch</code> 方法，处理前面可能出现的错误。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;Error!&#x27;</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e));

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&#x27;Hello world!&#x27;</span>);
}

<span class="hljs-title function_">foo</span>().<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res));
<span class="hljs-comment">// &#x27;Error!&#x27;</span>
<span class="hljs-comment">// &#x27;Hello world!&#x27;</span>
</code></pre>
<h3>操作中断</h3>
<p>如果 <code>await</code> 后面的异步操作出错，那么等同于 <code>async</code> 函数返回的 Promise 对象被 <code>reject</code>。</p>
<p>使用 <code>try...catch</code> 语句，实现多次重复尝试。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">const</span> superagent = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;superagent&#x27;</span>);
<span class="hljs-keyword">const</span> <span class="hljs-variable constant_">NUM_RETRIES</span> = <span class="hljs-number">3</span>;

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> i;
  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-variable constant_">NUM_RETRIES</span>; i++) {
    <span class="hljs-keyword">try</span> {
      <span class="hljs-keyword">await</span> superagent.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;https://google.com/this-throws-an-error&#x27;</span>);
      <span class="hljs-keyword">break</span>;
    } <span class="hljs-keyword">catch</span> (err) {
      <span class="hljs-comment">// do something</span>
    }
  }

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);
  <span class="hljs-comment">// 3</span>
}

<span class="hljs-title function_">foo</span>();
</code></pre>
<p>如果 <code>await</code> 操作成功，就会使用 <code>break</code> 语句退出循环；如果失败，会被 <code>catch</code> 语句捕捉，然后进入下一轮循环。</p>
<h2>实现原理</h2>
<p><code>async</code> 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// ...</span>
}
</code></pre>
<p>相当于：</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">args</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title function_">spawn</span>(<span class="hljs-keyword">function</span>* () {
    <span class="hljs-comment">// ...</span>
  });
}
</code></pre>
<p>所有的 <code>async</code> 函数都可以写成上面的第二种形式，其中的 <code>spawn</code> 函数就是自动执行器。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">spawn</span>(<span class="hljs-params">genF</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) {
    <span class="hljs-keyword">const</span> gen = <span class="hljs-title function_">genF</span>();
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">step</span>(<span class="hljs-params">nextF</span>) {
      <span class="hljs-keyword">let</span> next;
      <span class="hljs-keyword">try</span> {
        next = <span class="hljs-title function_">nextF</span>();
      } <span class="hljs-keyword">catch</span> (e) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">reject</span>(e);
      }
      <span class="hljs-keyword">if</span> (next.<span class="hljs-property">done</span>) {
        <span class="hljs-keyword">return</span> <span class="hljs-title function_">resolve</span>(next.<span class="hljs-property">value</span>);
      }
      <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(next.<span class="hljs-property">value</span>).<span class="hljs-title function_">then</span>(
        <span class="hljs-keyword">function</span> (<span class="hljs-params">v</span>) {
          <span class="hljs-title function_">step</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
            <span class="hljs-keyword">return</span> gen.<span class="hljs-title function_">next</span>(v);
          });
        },
        <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) {
          <span class="hljs-title function_">step</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
            <span class="hljs-keyword">return</span> gen.<span class="hljs-keyword">throw</span>(e);
          });
        }
      );
    }
    <span class="hljs-title function_">step</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      <span class="hljs-keyword">return</span> gen.<span class="hljs-title function_">next</span>(<span class="hljs-literal">undefined</span>);
    });
  });
}
</code></pre>
<h2>最佳实践</h2>
<h3>异步阻塞</h3>
<p>后面请求的发送总是需要依赖上一个请求返回的数据。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">request</span>(<span class="hljs-params">time</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, rejecr</span>) =&gt;</span> {
    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
      <span class="hljs-title function_">resolve</span>(time);
    }, time);
  });
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getResult</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">request</span>(<span class="hljs-number">500</span>);
  <span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">request</span>(p1 + <span class="hljs-number">1000</span>);
  <span class="hljs-keyword">let</span> p3 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">request</span>(p2 + <span class="hljs-number">1000</span>);
  <span class="hljs-keyword">return</span> p3;
}

<span class="hljs-title function_">getResult</span>()
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);
  })
  .<span class="hljs-title function_">catch</span>(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(err);
  });
</code></pre>
<h3>异步非阻塞</h3>
<p>在某些业务场景下，开发者可能需要处理多个连续步骤的操作，但是这些操作未必相互依赖。因此需要对这些操作进行优化。</p>
<p>综合上述 <a href="/front-end/core-modules/ecmascript-function-objects/function-declarations/#%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E">异步阻塞</a> 和 <a href="/front-end/core-modules/ecmascript-function-objects/function-declarations/#%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91">异步并发</a>，我们可以利用 Event Loop 的优势并发执行这些非阻塞异步函数。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-comment">// 选择披萨</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">selectPizza</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 异步获取披萨数据</span>
  <span class="hljs-keyword">const</span> pizzaData = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getPizzaData</span>();
  <span class="hljs-comment">// 选择披萨</span>
  <span class="hljs-keyword">const</span> chosenPizza = <span class="hljs-title function_">choosePizza</span>();
  <span class="hljs-comment">// 异步添加选中披萨到购物车</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">addPizzaToCart</span>(chosenPizza);
}

<span class="hljs-comment">// 选择饮料</span>
<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">selectDrink</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 异步获取饮料数据</span>
  <span class="hljs-keyword">const</span> drinkData = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getDrinkData</span>();
  <span class="hljs-comment">// 选择饮料</span>
  <span class="hljs-keyword">const</span> chosenDrink = <span class="hljs-title function_">chooseDrink</span>();
  <span class="hljs-comment">// 异步添加选中饮料到购物车</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">addDrinkToCart</span>(chosenDrink);
}

(<span class="hljs-title function_">async</span> () =&gt; {
  <span class="hljs-comment">// 并发执行这些非阻塞异步函数</span>
  <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-title function_">selectPizza</span>(), <span class="hljs-title function_">selectDrink</span>()]).<span class="hljs-title function_">then</span>(orderItems);
})();
</code></pre>
<p>补充一种与之相关的比较优雅的写法。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(<span class="hljs-title function_">selectPizza</span>().<span class="hljs-title function_">then</span>(choosePizza), <span class="hljs-title function_">selectDrink</span>().<span class="hljs-title function_">then</span>(chooseDrink));
</code></pre>
<h3>异步并发</h3>
<p>多个网络请求是非继发关系，最好使用 <code>Promise.all</code> 方法实现同时触发。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">const</span> [userList, orderList] = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<span class="hljs-title function_">getUserList</span>(), <span class="hljs-title function_">getOrderList</span>()]);

<span class="hljs-keyword">let</span> userPromise = <span class="hljs-title function_">getUserList</span>();
<span class="hljs-keyword">let</span> orderPromise = <span class="hljs-title function_">getOrderList</span>();

<span class="hljs-keyword">let</span> user = <span class="hljs-keyword">await</span> userPromise;
<span class="hljs-keyword">let</span> order = <span class="hljs-keyword">await</span> orderPromise;
</code></pre>
<p>上面两种写法，<code>getUserList</code> 和 <code>getOrderList</code> 都是同时触发，这样就会缩短程序的执行时间。</p>
<h3>未知数量的异步并发</h3>
<p>承接上个实践方案，当我们需要解决未知数量的 Promise 的时候，我们只需要创建数组并存储它们，然后同样使用 <code>Promise.all</code> 方法就能够并发地等待所有 Promise 返回结果。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 批量配置项</span>
  <span class="hljs-keyword">const</span> items = <span class="hljs-keyword">await</span> <span class="hljs-title function_">batchDisposal</span>();
  <span class="hljs-comment">// 每个配置项对应一个异步请求</span>
  <span class="hljs-keyword">const</span> promises = items.<span class="hljs-title function_">map</span>(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> <span class="hljs-title function_">sendRequest</span>(item));
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promises);
}
</code></pre>
<h3>不等待结果的异步循环</h3>
<p><code>await</code> 每次循环任务，注意遍历执行的匿名函数也要设置为 <code>async</code> 异步函数。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">delay</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> <span class="hljs-built_in">setTimeout</span>(resolve, <span class="hljs-number">300</span>));
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">delayedLog</span>(<span class="hljs-params">item</span>) {
  <span class="hljs-comment">// notice that we can await a function that returns promise</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title function_">delay</span>();
  <span class="hljs-comment">// log item only after a delay</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(item);
}

<span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">tasks</span>) {
  tasks.<span class="hljs-title function_">forEach</span>(<span class="hljs-title function_">async</span> (item) =&gt; {
    <span class="hljs-keyword">await</span> <span class="hljs-title function_">delayLog</span>(item);
  });

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;DONE!&#x27;</span>);
}
</code></pre>
<h3>异步串行遍历</h3>
<p>要等待所有的结果返回，我们还是要回到老式的 <code>for</code> 循环写法：</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">tasks</span>) {
  <span class="hljs-keyword">let</span> result = [];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> task <span class="hljs-keyword">of</span> tasks) {
    <span class="hljs-keyword">try</span> {
      result.<span class="hljs-title function_">push</span>(<span class="hljs-keyword">await</span> <span class="hljs-title function_">task</span>());
    } <span class="hljs-keyword">catch</span> (err) {
      result.<span class="hljs-title function_">push</span>(<span class="hljs-literal">null</span>);
    }
  }

  <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p>上面这段的遍历是 <strong>串行</strong> 执行的，我们也可以把它转换成 <strong>并行</strong> 的。</p>
<h3>异步并行遍历</h3>
<p>我们可以通过更改上面的代码来实现并行的异步操作：</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">tasks</span>) {
  <span class="hljs-comment">// map tasks to promises</span>
  <span class="hljs-keyword">const</span> promises = tasks.<span class="hljs-title function_">map</span>(delayLog);
  <span class="hljs-comment">// wait until all promises are resolved</span>
  <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>(promises);

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;DONE!&#x27;</span>);
}
</code></pre>
<h2>参考资料</h2>
<ul>
<li><a href="http://es6.ruanyifeng.com/#docs/async" target="_blank" rel="noopener noreferrer nofollow">📚 《ECMAScript 6 入门》</a></li>
<li><a href="https://juejin.im/post/5beea5f5f265da61590b40cd" target="_blank" rel="noopener noreferrer nofollow">📝 译文：更快的 async 函数和 Promise</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/30500894" target="_blank" rel="noopener noreferrer nofollow">📝 译文：图与例解读 Async/Await</a></li>
</ul>
</article></div></main><script src="/_next/static/chunks/webpack-78112f590b744806.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5244,[],\"\"]\n3:I[3866,[],\"\"]\n5:I[6213,[],\"OutletBoundary\"]\n7:I[6213,[],\"MetadataBoundary\"]\n9:I[6213,[],\"ViewportBoundary\"]\nb:I[4835,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/d498c84e4ab246b3.css\",\"style\"]\n:HL[\"/_next/static/css/485ff6fe79292a08.css\",\"style\"]\n:HL[\"/_next/static/css/b9d97b2190475167.css\",\"style\"]\n:HL[\"/_next/static/css/851cdee6d90716dd.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"NFjmtHF2up8B2PpbDjLiS\",\"p\":\"\",\"c\":[\"\",\"front-end\",\"core-modules\",\"ecmascript-function-objects\",\"function-declarations\",\"async-function-definitions\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"front-end\",{\"children\":[[\"slug\",\"core-modules/ecmascript-function-objects/function-declarations/async-function-definitions\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d498c84e4ab246b3.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/485ff6fe79292a08.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/b9d97b2190475167.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"front-end\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/851cdee6d90716dd.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"main\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[[\"slug\",\"core-modules/ecmascript-function-objects/function-declarations/async-function-definitions\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"gTI0TZ4tSo9WRudytmnkV\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:T793f,"])</script><script>self.__next_f.push([1,"\u003ch1\u003e异步函数\u003c/h1\u003e\n\u003cp\u003e\u003ccode\u003easync\u003c/code\u003e 函数是 \u003ca href=\"/front-end/standard-built-in-objects/control-abstraction-objects/generator\"\u003eGenerator\u003c/a\u003e 函数的语法糖。使用关键字 \u003ccode\u003easync\u003c/code\u003e 来表示，在函数内部是使用 \u003ccode\u003eawait\u003c/code\u003e 命令来表示异步。\u003c/p\u003e\n\u003cp\u003e相较于 Generator，\u003ccode\u003easync\u003c/code\u003e 函数的改进在于以下四点：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e内置执行器\u003c/strong\u003e：Generator 函数的执行必须靠执行器，而 \u003ccode\u003easync\u003c/code\u003e 函数自带执行器，调用方式与普通函数一致。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e更好的语义\u003c/strong\u003e：\u003ccode\u003easync\u003c/code\u003e 和 \u003ccode\u003eawait\u003c/code\u003e 相较于星号（\u003ccode\u003e*\u003c/code\u003e）和 \u003ccode\u003eyield\u003c/code\u003e 更加语义化。\u003ccode\u003easync\u003c/code\u003e 表示函数中有异步操作，\u003ccode\u003eawait\u003c/code\u003e 表示紧跟在后面的表达式需要等待结果。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e更广的适用性\u003c/strong\u003e：\u003ccode\u003eco\u003c/code\u003e 模块约定，\u003ccode\u003eyield\u003c/code\u003e 命令后面只能是 Thunk 函数或 Promise 对象，而 \u003ccode\u003easync\u003c/code\u003e 函数的 \u003ccode\u003eawait\u003c/code\u003e 命令后面则可以是 Promise 和原始类型的值（Number、String 和 Boolean，但这时会自动转成立即 \u003ccode\u003efulfilled\u003c/code\u003e 状态的 Promise 对象）。\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e返回值是 Promise\u003c/strong\u003e：\u003ccode\u003easync\u003c/code\u003e 函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用 \u003ccode\u003ethen\u003c/code\u003e 方法指定下一步的操作。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e进一步说，\u003ccode\u003easync\u003c/code\u003e 函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而 \u003ccode\u003eawait\u003c/code\u003e 命令就是内部 \u003ccode\u003ethen\u003c/code\u003e 命令的语法糖。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e\u003ccode\u003easync\u003c/code\u003e函数与 Generator 函数的对比\u003c/strong\u003e\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth style=\"text-align:left\"\u003e\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003easync 函数\u003c/th\u003e\n\u003cth style=\"text-align:left\"\u003eGenerator 函数\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003cstrong\u003e定义方式\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003easync function(){}\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003efunction* (){}\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003cstrong\u003e异步语句命令\u003c/strong\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eawait\u003c/code\u003e\u003c/td\u003e\n\u003ctd style=\"text-align:left\"\u003e\u003ccode\u003eyield\u003c/code\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003ch2\u003e基本用法\u003c/h2\u003e\n\u003ch3\u003e异步函数的声明\u003c/h3\u003e\n\u003cp\u003e凡是在函数声明前添加 \u003ccode\u003easync\u003c/code\u003e 关键字的函数在执行后都会自动返回 Promise 对象。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003easync\u003c/code\u003e 函数返回一个 Promise 对象，可以使用 \u003ccode\u003ethen\u003c/code\u003e 方法添加回调函数。当函数执行的时候，一旦遇到 \u003ccode\u003eawait\u003c/code\u003e 就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。\u003c/p\u003e\n\u003cp\u003e🌰 \u003cstrong\u003e代码示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etimeout\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ems\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(resolve, ms));\n}\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003earg1, ms\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etimeout\u003c/span\u003e(ms);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e arg1;\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Hello world!\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elog\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// \u0026#x27;Hello world!\u0026#x27;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e异步函数的语句\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eawait\u003c/code\u003e 命令必须在 \u003ccode\u003easync\u003c/code\u003e 函数里使用，不能单独使用。\u003c/p\u003e\n\u003cp\u003e由于 \u003ccode\u003easync\u003c/code\u003e 函数返回的是 Promise 对象，可以作为 \u003ccode\u003eawait\u003c/code\u003e 命令的参数。\u003c/p\u003e\n\u003ch3\u003e异步语句返回值\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eawait\u003c/code\u003e 后需跟 Promise。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eawait\u003c/code\u003e 作用之一就是获取随后 Promise 对象成功状态传递出来的参数。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eawait\u003c/code\u003e 命令只能用在 \u003ccode\u003easync\u003c/code\u003e 函数中，否则会报错。\u003c/p\u003e\n\u003ch2\u003e语法\u003c/h2\u003e\n\u003ch3\u003e返回值类型\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003easync\u003c/code\u003e 函数返回一个 Promise 对象\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003easync\u003c/code\u003e 函数内部 \u003ccode\u003ereturn\u003c/code\u003e 语句返回的值，会成为 \u003ccode\u003ethen\u003c/code\u003e 方法回调函数的参数。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;Hello world!\u0026#x27;\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(res));\n\u003cspan class=\"hljs-comment\"\u003e// \u0026#x27;Hello world!\u0026#x27;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果 \u003ccode\u003easync\u003c/code\u003e 函数内部抛出异常，则会导致返回的 Promise 对象状态变为 \u003ccode\u003erejected\u003c/code\u003e 状态。抛出的错误而会被 \u003ccode\u003ecatch\u003c/code\u003e 方法回调函数接收到。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eError\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Error\u0026#x27;\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e()\n  .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(res))\n  .\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(err));\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e返回值状态变化\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003easync\u003c/code\u003e 函数返回的 Promise 对象，必须等到内部所有 \u003ccode\u003eawait\u003c/code\u003e 命令后面的 Promise 对象执行完，才会发生状态改变，除非遇到 \u003ccode\u003ereturn\u003c/code\u003e 语句或者抛出错误。也就是说，只有 \u003ccode\u003easync\u003c/code\u003e 函数内部的异步操作执行完，才会执行 \u003ccode\u003ethen\u003c/code\u003e 方法指定的回调函数。\u003c/p\u003e\n\u003cp\u003e🌰 \u003cstrong\u003e代码示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edelay\u003c/span\u003e = (\u003cspan class=\"hljs-params\"\u003etimeout\u003c/span\u003e) =\u0026gt; \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(resolve, timeout));\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edelay\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edelay\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2000\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edelay\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;done\u0026#x27;\u003c/span\u003e;\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elog\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// \u0026#x27;done\u0026#x27;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面代码中，函数 \u003ccode\u003efoo\u003c/code\u003e 内部有三个延迟函数。只有这三个操作依次完成，才会执行 \u003ccode\u003ethen\u003c/code\u003e 方法里面的 \u003ccode\u003econsole.log\u003c/code\u003e。\u003c/p\u003e\n\u003ch3\u003e异步语句返回值\u003c/h3\u003e\n\u003cp\u003e正常情况下，异步语句 \u003ccode\u003eawait\u003c/code\u003e 命令后面是一个 Promise 对象，返回该对象的结果。如果不是 Promise 对象，就直接返回对应的值。\u003c/p\u003e\n\u003cp\u003e🌰 \u003cstrong\u003e代码示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e funciont \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e){\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e\n}\n\nfn.\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(res));\n\u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e异常处理\u003c/h2\u003e\n\u003ch3\u003e捕捉异常\u003c/h3\u003e\n\u003cp\u003e任何一个 \u003ccode\u003eawait\u003c/code\u003e 语句后面的 Promise 对象变为 \u003ccode\u003erejected\u003c/code\u003e 状态，那么整个 \u003ccode\u003easync\u003c/code\u003e 函数都会中断执行。\u003c/p\u003e\n\u003cp\u003e🌰 \u003cstrong\u003e代码示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ereject\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Error!\u0026#x27;\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Hello world!\u0026#x27;\u003c/span\u003e);\n  \u003cspan class=\"hljs-comment\"\u003e// 不会执行\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当 \u003ccode\u003easync\u003c/code\u003e 异步函数中只要有一个 \u003ccode\u003eawait\u003c/code\u003e 异步语句返回的 Promise 处于 \u003ccode\u003erejected\u003c/code\u003e 状态，则后面的 \u003ccode\u003eawait\u003c/code\u003e 异步语句都不会执行。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e解决方法\u003c/strong\u003e：使用 \u003ca href=\"/front-end/basic-concept/statements-and-declarations/the-try-statement\"\u003etry-catch 语句\u003c/a\u003e 或在 \u003ccode\u003eawait\u003c/code\u003e 返回的 Promise 添加 \u003ccode\u003ecatch\u003c/code\u003e 方法捕捉错误。\u003c/p\u003e\n\u003cp\u003e有时，我们希望即使前一个异步操作失败，也不要中断后面的异步操作。这时可以将第一个 \u003ccode\u003eawait\u003c/code\u003e 放在 \u003ccode\u003etry...catch\u003c/code\u003e 结构里面，这样不管这个异步操作是否成功，第二个 \u003ccode\u003eawait\u003c/code\u003e 都会执行。\u003c/p\u003e\n\u003cp\u003e🌰 \u003cstrong\u003e代码示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ereject\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Error!\u0026#x27;\u003c/span\u003e);\n  } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (err) {\n    \u003cspan class=\"hljs-comment\"\u003e// do something\u003c/span\u003e\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Hello world!\u0026#x27;\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(res));\n\u003cspan class=\"hljs-comment\"\u003e// \u0026#x27;Hello world!\u0026#x27;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e另一种方法是 \u003ccode\u003eawait\u003c/code\u003e 后面的 Promise 对象再跟一个 \u003ccode\u003ecatch\u003c/code\u003e 方法，处理前面可能出现的错误。\u003c/p\u003e\n\u003cp\u003e🌰 \u003cstrong\u003e代码示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ereject\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Error!\u0026#x27;\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(e));\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Hello world!\u0026#x27;\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(res));\n\u003cspan class=\"hljs-comment\"\u003e// \u0026#x27;Error!\u0026#x27;\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// \u0026#x27;Hello world!\u0026#x27;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e操作中断\u003c/h3\u003e\n\u003cp\u003e如果 \u003ccode\u003eawait\u003c/code\u003e 后面的异步操作出错，那么等同于 \u003ccode\u003easync\u003c/code\u003e 函数返回的 Promise 对象被 \u003ccode\u003ereject\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e使用 \u003ccode\u003etry...catch\u003c/code\u003e 语句，实现多次重复尝试。\u003c/p\u003e\n\u003cp\u003e🌰 \u003cstrong\u003e代码示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e superagent = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;superagent\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eNUM_RETRIES\u003c/span\u003e = \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e i;\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (i = \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e; i \u0026lt; \u003cspan class=\"hljs-variable constant_\"\u003eNUM_RETRIES\u003c/span\u003e; i++) {\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n      \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e superagent.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;https://google.com/this-throws-an-error\u0026#x27;\u003c/span\u003e);\n      \u003cspan class=\"hljs-keyword\"\u003ebreak\u003c/span\u003e;\n    } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (err) {\n      \u003cspan class=\"hljs-comment\"\u003e// do something\u003c/span\u003e\n    }\n  }\n\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(i);\n  \u003cspan class=\"hljs-comment\"\u003e// 3\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果 \u003ccode\u003eawait\u003c/code\u003e 操作成功，就会使用 \u003ccode\u003ebreak\u003c/code\u003e 语句退出循环；如果失败，会被 \u003ccode\u003ecatch\u003c/code\u003e 语句捕捉，然后进入下一轮循环。\u003c/p\u003e\n\u003ch2\u003e实现原理\u003c/h2\u003e\n\u003cp\u003e\u003ccode\u003easync\u003c/code\u003e 函数的实现原理，就是将 Generator 函数和自动执行器，包装在一个函数里。\u003c/p\u003e\n\u003cp\u003e🌰 \u003cstrong\u003e代码示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e相当于：\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eargs\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003espawn\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e* () {\n    \u003cspan class=\"hljs-comment\"\u003e// ...\u003c/span\u003e\n  });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e所有的 \u003ccode\u003easync\u003c/code\u003e 函数都可以写成上面的第二种形式，其中的 \u003ccode\u003espawn\u003c/code\u003e 函数就是自动执行器。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003espawn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003egenF\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003eresolve, reject\u003c/span\u003e) {\n    \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e gen = \u003cspan class=\"hljs-title function_\"\u003egenF\u003c/span\u003e();\n    \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003estep\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003enextF\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e next;\n      \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n        next = \u003cspan class=\"hljs-title function_\"\u003enextF\u003c/span\u003e();\n      } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (e) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ereject\u003c/span\u003e(e);\n      }\n      \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (next.\u003cspan class=\"hljs-property\"\u003edone\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e(next.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e);\n      }\n      \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e(next.\u003cspan class=\"hljs-property\"\u003evalue\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\n        \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003ev\u003c/span\u003e) {\n          \u003cspan class=\"hljs-title function_\"\u003estep\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e gen.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e(v);\n          });\n        },\n        \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003ee\u003c/span\u003e) {\n          \u003cspan class=\"hljs-title function_\"\u003estep\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n            \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e gen.\u003cspan class=\"hljs-keyword\"\u003ethrow\u003c/span\u003e(e);\n          });\n        }\n      );\n    }\n    \u003cspan class=\"hljs-title function_\"\u003estep\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e gen.\u003cspan class=\"hljs-title function_\"\u003enext\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003eundefined\u003c/span\u003e);\n    });\n  });\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e最佳实践\u003c/h2\u003e\n\u003ch3\u003e异步阻塞\u003c/h3\u003e\n\u003cp\u003e后面请求的发送总是需要依赖上一个请求返回的数据。\u003c/p\u003e\n\u003cp\u003e🌰 \u003cstrong\u003e代码示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erequest\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etime\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve, rejecr\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n      \u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e(time);\n    }, time);\n  });\n}\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetResult\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e p1 = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erequest\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e500\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e p2 = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erequest\u003c/span\u003e(p1 + \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e p3 = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003erequest\u003c/span\u003e(p2 + \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e p3;\n}\n\n\u003cspan class=\"hljs-title function_\"\u003egetResult\u003c/span\u003e()\n  .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(res);\n  })\n  .\u003cspan class=\"hljs-title function_\"\u003ecatch\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eerr\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(err);\n  });\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e异步非阻塞\u003c/h3\u003e\n\u003cp\u003e在某些业务场景下，开发者可能需要处理多个连续步骤的操作，但是这些操作未必相互依赖。因此需要对这些操作进行优化。\u003c/p\u003e\n\u003cp\u003e综合上述 \u003ca href=\"/front-end/core-modules/ecmascript-function-objects/function-declarations/#%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E\"\u003e异步阻塞\u003c/a\u003e 和 \u003ca href=\"/front-end/core-modules/ecmascript-function-objects/function-declarations/#%E5%BC%82%E6%AD%A5%E5%B9%B6%E5%8F%91\"\u003e异步并发\u003c/a\u003e，我们可以利用 Event Loop 的优势并发执行这些非阻塞异步函数。\u003c/p\u003e\n\u003cp\u003e🌰 \u003cstrong\u003e代码示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-comment\"\u003e// 选择披萨\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eselectPizza\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 异步获取披萨数据\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e pizzaData = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetPizzaData\u003c/span\u003e();\n  \u003cspan class=\"hljs-comment\"\u003e// 选择披萨\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e chosenPizza = \u003cspan class=\"hljs-title function_\"\u003echoosePizza\u003c/span\u003e();\n  \u003cspan class=\"hljs-comment\"\u003e// 异步添加选中披萨到购物车\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eaddPizzaToCart\u003c/span\u003e(chosenPizza);\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 选择饮料\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eselectDrink\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 异步获取饮料数据\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e drinkData = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egetDrinkData\u003c/span\u003e();\n  \u003cspan class=\"hljs-comment\"\u003e// 选择饮料\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e chosenDrink = \u003cspan class=\"hljs-title function_\"\u003echooseDrink\u003c/span\u003e();\n  \u003cspan class=\"hljs-comment\"\u003e// 异步添加选中饮料到购物车\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eaddDrinkToCart\u003c/span\u003e(chosenDrink);\n}\n\n(\u003cspan class=\"hljs-title function_\"\u003easync\u003c/span\u003e () =\u0026gt; {\n  \u003cspan class=\"hljs-comment\"\u003e// 并发执行这些非阻塞异步函数\u003c/span\u003e\n  \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e([\u003cspan class=\"hljs-title function_\"\u003eselectPizza\u003c/span\u003e(), \u003cspan class=\"hljs-title function_\"\u003eselectDrink\u003c/span\u003e()]).\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(orderItems);\n})();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e补充一种与之相关的比较优雅的写法。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eselectPizza\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(choosePizza), \u003cspan class=\"hljs-title function_\"\u003eselectDrink\u003c/span\u003e().\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(chooseDrink));\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e异步并发\u003c/h3\u003e\n\u003cp\u003e多个网络请求是非继发关系，最好使用 \u003ccode\u003ePromise.all\u003c/code\u003e 方法实现同时触发。\u003c/p\u003e\n\u003cp\u003e🌰 \u003cstrong\u003e代码示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e [userList, orderList] = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e([\u003cspan class=\"hljs-title function_\"\u003egetUserList\u003c/span\u003e(), \u003cspan class=\"hljs-title function_\"\u003egetOrderList\u003c/span\u003e()]);\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e userPromise = \u003cspan class=\"hljs-title function_\"\u003egetUserList\u003c/span\u003e();\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e orderPromise = \u003cspan class=\"hljs-title function_\"\u003egetOrderList\u003c/span\u003e();\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e user = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e userPromise;\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e order = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e orderPromise;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面两种写法，\u003ccode\u003egetUserList\u003c/code\u003e 和 \u003ccode\u003egetOrderList\u003c/code\u003e 都是同时触发，这样就会缩短程序的执行时间。\u003c/p\u003e\n\u003ch3\u003e未知数量的异步并发\u003c/h3\u003e\n\u003cp\u003e承接上个实践方案，当我们需要解决未知数量的 Promise 的时候，我们只需要创建数组并存储它们，然后同样使用 \u003ccode\u003ePromise.all\u003c/code\u003e 方法就能够并发地等待所有 Promise 返回结果。\u003c/p\u003e\n\u003cp\u003e🌰 \u003cstrong\u003e代码示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 批量配置项\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e items = \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebatchDisposal\u003c/span\u003e();\n  \u003cspan class=\"hljs-comment\"\u003e// 每个配置项对应一个异步请求\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e promises = items.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eitem\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003esendRequest\u003c/span\u003e(item));\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e(promises);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e不等待结果的异步循环\u003c/h3\u003e\n\u003cp\u003e\u003ccode\u003eawait\u003c/code\u003e 每次循环任务，注意遍历执行的匿名函数也要设置为 \u003ccode\u003easync\u003c/code\u003e 异步函数。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edelay\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eresolve\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(resolve, \u003cspan class=\"hljs-number\"\u003e300\u003c/span\u003e));\n}\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edelayedLog\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eitem\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// notice that we can await a function that returns promise\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edelay\u003c/span\u003e();\n  \u003cspan class=\"hljs-comment\"\u003e// log item only after a delay\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(item);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eexecute\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etasks\u003c/span\u003e) {\n  tasks.\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003easync\u003c/span\u003e (item) =\u0026gt; {\n    \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edelayLog\u003c/span\u003e(item);\n  });\n\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;DONE!\u0026#x27;\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e异步串行遍历\u003c/h3\u003e\n\u003cp\u003e要等待所有的结果返回，我们还是要回到老式的 \u003ccode\u003efor\u003c/code\u003e 循环写法：\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eexecute\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etasks\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e result = [];\n\n  \u003cspan class=\"hljs-keyword\"\u003efor\u003c/span\u003e (\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e task \u003cspan class=\"hljs-keyword\"\u003eof\u003c/span\u003e tasks) {\n    \u003cspan class=\"hljs-keyword\"\u003etry\u003c/span\u003e {\n      result.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003etask\u003c/span\u003e());\n    } \u003cspan class=\"hljs-keyword\"\u003ecatch\u003c/span\u003e (err) {\n      result.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n    }\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面这段的遍历是 \u003cstrong\u003e串行\u003c/strong\u003e 执行的，我们也可以把它转换成 \u003cstrong\u003e并行\u003c/strong\u003e 的。\u003c/p\u003e\n\u003ch3\u003e异步并行遍历\u003c/h3\u003e\n\u003cp\u003e我们可以通过更改上面的代码来实现并行的异步操作：\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003easync\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eexecute\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003etasks\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// map tasks to promises\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e promises = tasks.\u003cspan class=\"hljs-title function_\"\u003emap\u003c/span\u003e(delayLog);\n  \u003cspan class=\"hljs-comment\"\u003e// wait until all promises are resolved\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eawait\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eall\u003c/span\u003e(promises);\n\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;DONE!\u0026#x27;\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e参考资料\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"http://es6.ruanyifeng.com/#docs/async\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📚 《ECMAScript 6 入门》\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.im/post/5beea5f5f265da61590b40cd\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 译文：更快的 async 函数和 Promise\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/30500894\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 译文：图与例解读 Async/Await\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"markdown-body\",\"children\":[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"front-end\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"front-end knowledge\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>