<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/ec0a9d078e716e00.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/485ff6fe79292a08.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/0ff121a467c0636f.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-038c2e688b596d0e.js"/><script src="/_next/static/chunks/4bd1b696-20882bf820444624.js" async=""></script><script src="/_next/static/chunks/517-98ed787e5f259f2c.js" async=""></script><script src="/_next/static/chunks/main-app-f33d3e3aed85e21f.js" async=""></script><meta name="next-size-adjust" content=""/><title>front-end</title><meta name="description" content="front-end knowledge"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><main><div class="markdown-body"><h1>模块化</h1><article><h1>模块化</h1>
<p>🌽 <strong>模块化</strong>：把复杂的系统分解到多个模块以方便编码</p>
<p>在<strong>模块化编程</strong>中，开发者将程序分解成离散功能块（discrete chunks of functionality），并称之为<strong>模块</strong>。</p>
<ul>
<li>将一个复杂的程序依据一定的规则（规范）封装成几个块（文件），并进行组合在一起</li>
<li>块的内部数据相对而言是私有的，只是向外部暴露一些接口与外部其他模块通信</li>
</ul>
<p>每个模块具有比完整程序更小的接触面，使得校验、调试、测试轻而易举。 精心编写的<em>模块</em>提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。</p>
<h2>模块化趋势</h2>
<h3>痛点</h3>
<p>过去代码组织方式，会出现的问题：</p>
<ul>
<li>命名空间冲突</li>
<li>无法合理地管理项目依赖和版本</li>
<li>无法方便控制依赖的加载顺序</li>
<li>项目体积变大后难以维护</li>
</ul>
<h3>优势</h3>
<p>实现模块化能实现的优势：</p>
<ul>
<li>方便代码维护</li>
<li>提高代码复用性</li>
<li>降低代码耦合度（解耦）</li>
<li>分治思想</li>
</ul>
<h2>模块化进化史</h2>
<h3>全局模式</h3>
<p><strong>module1.js</strong></p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 数据</span>
<span class="hljs-keyword">let</span> data1 = <span class="hljs-string">&#x27;module one data&#x27;</span>;

<span class="hljs-comment">// 操作数据的函数</span>
<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`foo() <span class="hljs-subst">${data1}</span>`</span>);
}
<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`bar() <span class="hljs-subst">${data1}</span>`</span>);
}
</code></pre>
<p><strong>module2.js</strong></p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">let</span> data2 = <span class="hljs-string">&#x27;module two data&#x27;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">//与模块1中的函数冲突了</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`foo() <span class="hljs-subst">${data2}</span>`</span>);
}
</code></pre>
<p><strong>test.html</strong></p>
<pre class="hljs"><code class="language-html"><span class="hljs-comment">&lt;!-- 同步引入，若函数冲突，则后面覆盖前面 --&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;module1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;module2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript">
  <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// foo() module two data</span>
  <span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// bar() module one data</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p><strong>说明：</strong></p>
<ul>
<li>全局模式：将不同的功能封装成不同的全局函数</li>
<li>问题：全局变量被污染了，很容易引起命名冲突</li>
</ul>
<h3>单例模式</h3>
<p><strong>module1.js</strong></p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">let</span> moduleOne = {
  <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;module one data&#x27;</span>,
  <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`foo() <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.data}</span>`</span>);
  },
  <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`bar() <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.data}</span>`</span>);
  },
};
</code></pre>
<p><strong>module2.js</strong></p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">let</span> moduleTwo = {
  <span class="hljs-attr">data</span>: <span class="hljs-string">&#x27;module two data&#x27;</span>,
  <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`foo() <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.data}</span>`</span>);
  },
  <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`bar() <span class="hljs-subst">${<span class="hljs-variable language_">this</span>.data}</span>`</span>);
  },
};
</code></pre>
<p><strong>test.html</strong></p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;module1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;module2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript">
  moduleOne.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">//foo() module one data</span>
  moduleOne.<span class="hljs-title function_">bar</span>(); <span class="hljs-comment">//bar() module one data</span>

  moduleTwo.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">//foo() module two data</span>
  moduleTwo.<span class="hljs-title function_">bar</span>(); <span class="hljs-comment">//bar() module two data</span>

  moduleOne.<span class="hljs-property">data</span> = <span class="hljs-string">&#x27;update data&#x27;</span>; <span class="hljs-comment">//能直接修改模块内部的数据</span>
  moduleOne.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">//foo() update data</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>说明：</p>
<ul>
<li>单例模式模式：简单对象封装</li>
<li>作用：减少了全局变量（如两个模块的 <code>data</code> 都不是全局变量了，而是对象的某一个属性）</li>
<li>问题：不安全，可以直接修改模块内部的数据</li>
</ul>
<h3>IIFE 模式</h3>
<p><strong>module1.js</strong></p>
<pre class="hljs"><code class="language-js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span></span>) {
  <span class="hljs-comment">// 数据</span>
  <span class="hljs-keyword">let</span> data = <span class="hljs-string">&#x27;IIFE module data&#x27;</span>;

  <span class="hljs-comment">//操作数据的函数</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 用于暴露的函数</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`foo() <span class="hljs-subst">${data}</span>`</span>);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 用于暴露的函数</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`bar() <span class="hljs-subst">${data}</span>`</span>);
    <span class="hljs-title function_">otherFun</span>(); <span class="hljs-comment">//内部调用</span>
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">otherFun</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">// 内部私有的函数</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;privateFunction go otherFun()&#x27;</span>);
  }

  <span class="hljs-comment">// 暴露 foo 函数和 bar 函数</span>
  <span class="hljs-variable language_">window</span>.<span class="hljs-property">module</span> = { foo, bar };
})(<span class="hljs-variable language_">window</span>);
</code></pre>
<p><strong>test.html</strong></p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;module1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript">
  <span class="hljs-variable language_">module</span>.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// foo() IIFE module data</span>
  <span class="hljs-variable language_">module</span>.<span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// bar() IIFE module data    privateFunction go otherFun()</span>

  <span class="hljs-comment">// module.otherFun()  //报错，module.otherFun is not a function</span>

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-property">data</span>); <span class="hljs-comment">// undefined 因为我暴露的 module 对象中无 data</span>
  <span class="hljs-variable language_">module</span>.<span class="hljs-property">data</span> = <span class="hljs-string">&#x27;xxxx&#x27;</span>; <span class="hljs-comment">// 不是修改的模块内部的 data，而是在 module 新增 data 属性</span>
  <span class="hljs-variable language_">module</span>.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 验证内部的 data 没有改变  还是会输出 foo() IIFE module data</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>说明：</p>
<ul>
<li>IIFE 模式：匿名函数自调用（闭包）</li>
<li>IIFE：Immediately-Invoked Function Expression（立即调用函数表达式）</li>
<li>作用：数据是私有的，外部只能通过暴露的方法操作</li>
<li>问题：如果当前这个模块依赖另一个模块怎么办？见下面 IIFE 增强版的（模块依赖于 jQuery）</li>
</ul>
<h3>IIFE 模式增强</h3>
<p>引入 jQuery 到项目中</p>
<p><strong>module1.js</strong></p>
<pre class="hljs"><code class="language-js">(<span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">window</span>, $</span>) {
  <span class="hljs-comment">//数据</span>
  <span class="hljs-keyword">let</span> data = <span class="hljs-string">&#x27;IIFE Strong module data&#x27;</span>;

  <span class="hljs-comment">//操作数据的函数</span>
  <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">//用于暴露的函数</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`foo() <span class="hljs-subst">${data}</span>`</span>);
    $(<span class="hljs-string">&#x27;body&#x27;</span>).<span class="hljs-title function_">css</span>(<span class="hljs-string">&#x27;background&#x27;</span>, <span class="hljs-string">&#x27;red&#x27;</span>);
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">//用于暴露的函数</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`bar() <span class="hljs-subst">${data}</span>`</span>);
    <span class="hljs-title function_">otherFun</span>(); <span class="hljs-comment">//内部调用</span>
  }

  <span class="hljs-keyword">function</span> <span class="hljs-title function_">otherFun</span>(<span class="hljs-params"></span>) {
    <span class="hljs-comment">//内部私有的函数</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;privateFunction go otherFun()&#x27;</span>);
  }

  <span class="hljs-comment">//暴露foo函数和bar函数</span>
  <span class="hljs-variable language_">window</span>.<span class="hljs-property">moduleOne</span> = { foo, bar };
})(<span class="hljs-variable language_">window</span>, jQuery);
</code></pre>
<p><strong>test.html</strong></p>
<pre class="hljs"><code class="language-html"><span class="hljs-comment">&lt;!--引入的js必须有一定顺序--&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;jquery-1.10.1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;module1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript">
  moduleOne.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">//foo() IIFE Strong module data  而且页面背景会变色</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>说明：</p>
<ul>
<li>IIFE 模式增强：引入依赖</li>
<li>这就是现代模块实现的基石。其实很像了，有引入和暴露两个方面。</li>
<li>存在的问题：一个页面需要引入多个 JS 文件的问题</li>
</ul>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;module1.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;module2.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;module3.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;module4.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<ul>
<li>请求过多：一个 <code>&lt;script&gt;</code> 标签就是一次请求</li>
<li>依赖模糊：看不出来谁依赖着谁？哪些模块是有依赖关系的，很难看出来</li>
<li>难以维护：内部依赖关系混乱也就难以维护啦</li>
</ul>
<h2>模块化方案</h2>
<h3>CommonJS</h3>
<p>CommonJS 是服务器端模块的规范，Node.js 就是采用了这个规范。但目前也可用于浏览器端，需要使用 Browserify 进行提前编译打包。</p>
<p>CommonJS 模块化的引入方式使用 <code>require</code>，暴露的方式使用 <code>module.exports</code> 或 <code>exports</code>。</p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/modularization/commonjs.jpeg&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;CommonJS&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{800}</span> /&gt;</span></span>;
</code></pre>
<p><strong>特点</strong></p>
<ul>
<li>同步加载依赖的模块</li>
<li>可复用于 Node 环境</li>
<li>成熟的第三方模块社区</li>
</ul>
<blockquote>
<p><strong>彻底说明白 <code>module.exports</code> 和 <code>exports</code> 的区别：</strong></p>
</blockquote>
<p>在 Node.js 中，<code>module</code> 是一个全局变量，类似于在浏览器端的 Window 也是一个全局变量一样的道理。</p>
<p><code>module.exports</code> <strong>初始</strong>的时候置为空对象，<code>exports</code> 也指向这个空对象。</p>
<p>内部代码实现：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">var</span> <span class="hljs-variable language_">module</span> = {
  <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;xxxx&#x27;</span>,
  <span class="hljs-attr">exports</span>: {},
};

<span class="hljs-keyword">var</span> <span class="hljs-built_in">exports</span> = <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>;
<span class="hljs-comment">// exports 是对 module.exports 的引用</span>
<span class="hljs-comment">// 也就是 exports 现在指向的内存地址和 module.exports 指向的内存地址是一样的</span>
</code></pre>
<p>上面的代码可以看出我们平常使用的 <code>exports</code> 是对 <code>module.exports</code> 的一个引用，两者都是指向同一个对象。</p>
<p>用一句话来说明就是，模块的 <code>require</code>（引入）能看到的只有 <code>module.exports</code> 这个对象，它是看不到 <code>exports</code> 对象的，而我们在编写模块时用到的 <code>exports</code> 对象实际上只是对 <code>module.exports</code> 的引用。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-built_in">exports</span> = <span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>;
</code></pre>
<p>我们可以使用 <code>exports.a = ‘xxx’</code> 或 <code>exports.b = function(){}</code> 添加方法或属性，本质上它也添加在 <code>module.exports</code> 所指向的对象身上。</p>
<p>但是你不能直接 <code>exports = { a: 'xxx'}</code>，这就将 <code>exports</code> 重新指向新的对象，它和 <code>module.exports</code> 就不是指向同一个对象，也就让两者失去了关系，而 Node.js 中 <code>require</code> 能看到的是 <code>module.exports</code> 指向的对象。</p>
<p>因此，我们一般都会直接使用：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span>;
</code></pre>
<p>再举例说明两者区别：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);
}
</code></pre>
<p>想要将这两个函数暴露出去，可以直接使用<code>exports</code></p>
<pre class="hljs"><code class="language-js"><span class="hljs-built_in">exports</span>.<span class="hljs-property">foo</span> = foo;
<span class="hljs-built_in">exports</span>.<span class="hljs-property">bar</span> = bar;
</code></pre>
<p>也可以对 <code>module.exports</code> 赋值</p>
<pre class="hljs"><code class="language-js"><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = {
  <span class="hljs-attr">foo</span>: foo,
  <span class="hljs-attr">bar</span>: bar,
};
</code></pre>
<p>但是不能直接对 <code>exports</code> 赋值</p>
<pre class="hljs"><code class="language-js"><span class="hljs-comment">// 错误</span>
<span class="hljs-built_in">exports</span> = {
  <span class="hljs-attr">foo</span>: foo,
  <span class="hljs-attr">bar</span>: bar,
};
</code></pre>
<p>因为这样做仅仅改变了<code>exports</code> 的引用，而不改变 <code>module.exports</code>。</p>
<p><strong>总结</strong></p>
<p><strong>特点</strong>：同步加载，有缓存</p>
<p><strong>用法</strong>：关键在于引入和暴露</p>
<ul>
<li>引入模块
<ul>
<li><code>require(url)</code>（<code>url</code> 为路径参数）</li>
<li>路径：自定义模块路径必须以 <code>./</code> 或者 <code>../</code> 开头</li>
<li>第三方模块/内置模块/核心模块：路径直接使用模块名称</li>
</ul>
</li>
<li>暴露模块
<ul>
<li><code>exports</code></li>
<li><code>module.exports</code></li>
</ul>
</li>
</ul>
<p>主要是在服务器端使用的，但是也能在浏览器端运行，需要借助 <a href="https://github.com/browserify/browserify" target="_blank" rel="noopener noreferrer nofollow">Browserify</a> 进行编译。</p>
<h3>AMD</h3>
<blockquote>
<p>CommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。由于 NodeJS 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，所以同步加载没有问题。但是如果是浏览器端，同步加载很容易阻塞，这时候 AMD 规范就出来了。AMD 规范则是非同步加载模块，允许指定回调函数。故浏览器端一般会使用 AMD 规范。</p>
</blockquote>
<p><a href="https://github.com/amdjs/amdjs-api/wiki" target="_blank" rel="noopener noreferrer nofollow">AMD</a> 是 <a href="https://github.com/requirejs/requirejs" target="_blank" rel="noopener noreferrer nofollow">require.js</a> 在推广过程中对模块定义的规范化产出 。</p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/modularization/amd.jpeg&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;AMD&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{800}</span> /&gt;</span></span>;
</code></pre>
<p><strong>特点：</strong></p>
<ul>
<li>异步加载依赖的模块</li>
<li>可在不转换代码的情况下直接在浏览器运行</li>
<li>并行加载多个模块</li>
<li>可运行在浏览器和 Node 环境</li>
</ul>
<p><strong>用法：</strong></p>
<ul>
<li>暴露模块
<ul>
<li>在模块内部使用 <code>return</code></li>
</ul>
</li>
<li>定义模块
<ul>
<li><code>define(['模块名'], function (模块暴露内容) {})</code></li>
<li><code>require(['模块名'], function (模块暴露内容) {})</code></li>
<li>在模块内部可以使用 <code>require</code> 定义异步模块</li>
</ul>
</li>
<li>主模块：
<ul>
<li><code>requirejs.config({})</code> 配置使用的模块路径</li>
<li><code>requirejs(['模块名'], function (模块暴露内容) {})</code></li>
</ul>
</li>
<li>HTML 文件引入 <code>&lt;script&gt;</code> 标签
<ul>
<li><code>&lt;script data-main='app.js' src='require.js'&gt;&lt;/script&gt;</code></li>
</ul>
</li>
</ul>
<p>AMD（通用模块定义）主要是在浏览器使用的。</p>
<h3>CMD</h3>
<p>CMD 是根据 CommonJS 和 AMD 基础上提出的。</p>
<p>CMD（通用模块定义）和 AMD（异步模块定）是比较相似的。</p>
<p><code>require.js</code> 遵循的是 AMD（异步模块定义）规范，<a href="https://github.com/seajs/seajs" target="_blank" rel="noopener noreferrer nofollow">sea.js</a> 遵循的是 CMD （通用模块定义）规范。</p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/modularization/cmd.jpeg&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;CMD&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{800}</span> /&gt;</span></span>;
</code></pre>
<p><strong>特点：</strong></p>
<ul>
<li>异步加载，有缓存</li>
</ul>
<p><strong>用法：</strong></p>
<ul>
<li>定义模块
<ul>
<li><code>define(function (require, exports, module) {})</code></li>
</ul>
</li>
<li>引入模块
<ul>
<li>同步加载 <code>require()</code></li>
<li>异步加载 <code>require.async(['模块名'], function(模块暴露内容) {})</code></li>
</ul>
</li>
<li>暴露模块
<ul>
<li><code>exports</code></li>
<li><code>module.exports</code></li>
</ul>
</li>
<li>HTML 文件引入 <code>&lt;script&gt;</code>标签
<ul>
<li><code>&lt;script src='sea.js'&gt;&lt;/script&gt;</code></li>
<li><code>&lt;script&gt;seajs.use('app.js')&lt;/script&gt;</code></li>
</ul>
</li>
</ul>
<p><code>sea.js</code> 和 <code>require.js</code> 一样主要在浏览器中使用。其实这两个一般都很少使用。用的比较多的是 <code>commonjs</code> 和马上要介绍的 ES6 模块化。</p>
<h3>ES6 Module</h3>
<p><strong>特点：</strong></p>
<ul>
<li>
<p>动态引入（按需加载），没有缓存</p>
<p><strong>用法：</strong></p>
</li>
<li>
<p>引入模块使用 <code>import</code></p>
<ul>
<li>统一暴露：<code>import {模块暴露的内容} from '模块路径'</code></li>
<li>分别暴露：<code>import * as m1 from './module1'</code>
<ul>
<li>这两者暴露的本质是对象，接收的时候只能以对象的解构赋值的方式来接收值</li>
</ul>
</li>
<li>默认暴露：直接使用 <code>import 模块暴露的内容 from '模块路径'</code>。默认暴露，暴露任意数据类型，暴露什么数据类型，接收什么数据类型。</li>
</ul>
</li>
<li>
<p>暴露模块使用 <code>export</code></p>
<ul>
<li>分别暴露 （基本不用）</li>
<li>统一暴露 （暴露多个内容）</li>
<li>默认暴露 （暴露单个内容）</li>
</ul>
</li>
</ul>
<p>主要是用在浏览器，服务器端也使用。但是现在浏览器和服务器均不支持 ES6 的模块化语法，所以要借助工具来编译运行</p>
<ul>
<li><a href="https://github.com/babel/babel" target="_blank" rel="noopener noreferrer nofollow">Babel</a> 将 ES6+ 转换为 ES5- （ES6 的模块化语法 编译成 <code>commonjs</code>）</li>
<li>Browserify 将 CommonJS 语法编译成能让浏览器识别的语法</li>
</ul>
<h2>严格模式</h2>
<p>ES6 的模块自动采用严格模式，不管你是否有在模块头部加上 <code>'use strict'</code>。</p>
<p>严格模式主要有以下限制：</p>
<ul>
<li>变量必须声明后再使用</li>
<li>函数的参数不能有同名属性，否则报错</li>
<li>不能使用 <code>with</code> 语句</li>
<li>不能对只读属性赋值，否则报错</li>
<li>不能使用前缀 0 表示八进制数，否则报错</li>
<li>不能删除不可删除的属性，否则报错</li>
<li>不能删除变量 <code>delete prop</code>，会报错，只能删除属性 <code>delete global[prop]</code></li>
<li><code>eval</code> 不会在它的外层作用域引入变量</li>
<li><code>eval</code> 和 <code>arguments</code> 不能被重新赋值</li>
<li><code>arguments</code> 不会自动反映函数参数的变化</li>
<li>不能使用 <code>arguments.callee</code></li>
<li>不能使用 <code>arguments.caller</code></li>
<li>禁止 <code>this</code> 指向全局对象</li>
<li>不能使用 <code>fn.caller</code> 和 <code>fn.arguments</code> 获取函数调用的堆栈</li>
<li>增加了保留字（比如 <code>protected</code>、<code>static</code> 和 <code>interface</code>）</li>
</ul>
<p>其中，尤其需要注意 <code>this</code> 的限制。ES6 模块之中，顶层的 <code>this</code> 指向 <code>undefined</code>，即不应该在顶层代码使用 <code>this</code>。</p>
<h2>模块化与组合化</h2>
<p>既然说到模块化，其实我更想说说模块化与组件化。这两个概念在前端领域已经十分普遍。</p>
<p>先有模块化后有组件化。组件化是建立在模块化思想上的一次演进，一个变种。所以，我们会在软件工程体系中看过一句话：<strong>模块化是组件化的基石</strong>。</p>
<p>组件化和模块化的思想都是 <strong>分而治之</strong> 的思想。但还是有细小的区分，他们的侧重点有所不同。</p>
<p>组件化更加倾向于 UI 层面上，是一个可以独立展示内容的「积木」，比如一个页面的头部组件，包含结构 HTML、样式 CSS、逻辑 JS、以及静态资源图片组合一个集合体。一个页面是由众多组件组成的，就像由众多「积木」搭成的「城堡」一样； 模块化更加倾向于功能或者数据的封装，一般由几个组件或单个组件构成的带有一定功能的集合体；</p>
<p>引用一下 <a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Ffouber%2Fblog%2Fissues%2F10" target="_blank" rel="noopener noreferrer nofollow">@张云龙</a> 对组件化的理解：</p>
<pre class="hljs"><code class="language-jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;
<span class="hljs-keyword">import</span> img <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;../../assets/modularization/components-1.jpeg&#x27;</span>;

<span class="hljs-keyword">export</span> <span class="hljs-title function_">default</span> () =&gt; <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;组件化示意图1&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">{img}</span> <span class="hljs-attr">width</span>=<span class="hljs-string">{720}</span> /&gt;</span></span>;
</code></pre>
<p>&lt;br /&gt;</p>
<p>就如上图的这个 <code>title</code> 组件，包含了结构 HTML、样式 CSS、逻辑 JavaScript、以及静态资源图片，往往组件的组成就是以上四个方面。这个 <code>header</code> 文件夹我们可以拿到其他项目中使用，它具有可以独立展示内容的特点。</p>
<p>结合前面提到的模块化开发，整个前端项目可以划分为这么几种开发概念：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>JS 模块</td>
<td>独立算法和数据单元</td>
<td>浏览器环境检测（detect）、网络请求（ajax）、应用配置（config）、DOM 操作（dom）、工具函数（utils）以及组件里的 JS 单元</td>
</tr>
<tr>
<td>CSS 模块</td>
<td>独立的功能性样式单元</td>
<td>栅格系统（grid）、字体图标（icon-fonts）、动画样式（animate）以及组件里的 CSS 单元</td>
</tr>
<tr>
<td>页面</td>
<td>前端这种 GUI 软件的的界面状态，是 UI 组件的容器</td>
<td>首页（index）、列表页（list）、用户管理（user）</td>
</tr>
<tr>
<td>应用</td>
<td>整个项目或整个站点被称之为应用，由多个页面组成</td>
<td></td>
</tr>
</tbody>
</table>
<p>那么它们之间的关系如下图所示，一个应用由多个下图的页面组成。一个页面由多个组件组合。组件中可依赖 JS 模块。</p>
<p>所以，前端开发现在不仅仅只是别人说的「画画页面实现点效果」的职位，它是实现软件的图形用户界面（Graphical User Interface，简称 GUI），是一名软件工程师。现在前端开发都是基于模块化和组件化的开发，可以说算是工程化的项目了。从单页面（SPA）的应用就可以看出 JavaScript 大大改善了 Web 应用的用户体验。从谷歌提出 PWA（Progressive Web Apps）就可以看出前端在领域的成长。</p>
<p>不仅仅如此，多终端也已经成为时下以及未来的一个必然趋势，移动端、PC 端、触摸屏、智能设备、物联网等等，相信前端在跨端的领域下肯定会有更好的解决方案。</p>
<p>但是，如果从整个软件工程来看，我们就会意识到一个惨痛的事实：前端工程师在整个系统工程中的地位太低了。前端是处于系统软件的上游（用户入口），因此没有其他系统会来调取前端系统的服务。而后端它在软件开发中处于下游，后端一方面要为前端提供接口服务，一方面要向中后台以及数据层索取服务，对接层次会更多，地位也就更高了。由此导致，感觉每次需求评估前端往往是最后一道坎，因为上游依托下游，就只能是下游先行了，整体上就会感觉前端对业务的参与度太低了。</p>
<hr>
<p><strong>参考资料：</strong></p>
<ul>
<li><a href="https://juejin.im/post/5c82323ce51d453a5f22b281" target="_blank" rel="noopener noreferrer nofollow">📝 从前端模块化编程切入想聊聊前端的未来</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fseajs%2Fseajs%2Fissues%2F588" target="_blank" rel="noopener noreferrer nofollow">📝 前端模块化开发那点历史</a></li>
<li><a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2012%2F10%2Fjavascript_module.html" target="_blank" rel="noopener noreferrer nofollow">📝 JavaScript 模块化编程@阮一峰</a></li>
<li><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F20351507%2Fanswer%2F14859415" target="_blank" rel="noopener noreferrer nofollow">📝 知乎专栏 | AMD 和 CMD 的区别</a></li>
</ul>
</article></div></main><script src="/_next/static/chunks/webpack-038c2e688b596d0e.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5244,[],\"\"]\n3:I[3866,[],\"\"]\n5:I[6213,[],\"OutletBoundary\"]\n7:I[6213,[],\"MetadataBoundary\"]\n9:I[6213,[],\"ViewportBoundary\"]\nb:I[4835,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/ec0a9d078e716e00.css\",\"style\"]\n:HL[\"/_next/static/css/485ff6fe79292a08.css\",\"style\"]\n:HL[\"/_next/static/css/0ff121a467c0636f.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"ToCgoFiTXvECVEVLCeZww\",\"p\":\"\",\"c\":[\"\",\"front-end\",\"core-modules\",\"modularization\",\"modularization\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"front-end\",{\"children\":[[\"slug\",\"core-modules/modularization/modularization\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/ec0a9d078e716e00.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"front-end\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/485ff6fe79292a08.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0ff121a467c0636f.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"main\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[[\"slug\",\"core-modules/modularization/modularization\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"dJVb6iXFg47ZnKqv2-7nZ\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:T9433,"])</script><script>self.__next_f.push([1,"\u003ch1\u003e模块化\u003c/h1\u003e\n\u003cp\u003e🌽 \u003cstrong\u003e模块化\u003c/strong\u003e：把复杂的系统分解到多个模块以方便编码\u003c/p\u003e\n\u003cp\u003e在\u003cstrong\u003e模块化编程\u003c/strong\u003e中，开发者将程序分解成离散功能块（discrete chunks of functionality），并称之为\u003cstrong\u003e模块\u003c/strong\u003e。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e将一个复杂的程序依据一定的规则（规范）封装成几个块（文件），并进行组合在一起\u003c/li\u003e\n\u003cli\u003e块的内部数据相对而言是私有的，只是向外部暴露一些接口与外部其他模块通信\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e每个模块具有比完整程序更小的接触面，使得校验、调试、测试轻而易举。 精心编写的\u003cem\u003e模块\u003c/em\u003e提供了可靠的抽象和封装界限，使得应用程序中每个模块都具有条理清楚的设计和明确的目的。\u003c/p\u003e\n\u003ch2\u003e模块化趋势\u003c/h2\u003e\n\u003ch3\u003e痛点\u003c/h3\u003e\n\u003cp\u003e过去代码组织方式，会出现的问题：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e命名空间冲突\u003c/li\u003e\n\u003cli\u003e无法合理地管理项目依赖和版本\u003c/li\u003e\n\u003cli\u003e无法方便控制依赖的加载顺序\u003c/li\u003e\n\u003cli\u003e项目体积变大后难以维护\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e优势\u003c/h3\u003e\n\u003cp\u003e实现模块化能实现的优势：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e方便代码维护\u003c/li\u003e\n\u003cli\u003e提高代码复用性\u003c/li\u003e\n\u003cli\u003e降低代码耦合度（解耦）\u003c/li\u003e\n\u003cli\u003e分治思想\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e模块化进化史\u003c/h2\u003e\n\u003ch3\u003e全局模式\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003emodule1.js\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 数据\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e data1 = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;module one data\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 操作数据的函数\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`foo() \u003cspan class=\"hljs-subst\"\u003e${data1}\u003c/span\u003e`\u003c/span\u003e);\n}\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`bar() \u003cspan class=\"hljs-subst\"\u003e${data1}\u003c/span\u003e`\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003emodule2.js\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e data2 = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;module two data\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e//与模块1中的函数冲突了\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`foo() \u003cspan class=\"hljs-subst\"\u003e${data2}\u003c/span\u003e`\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003etest.html\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!-- 同步引入，若函数冲突，则后面覆盖前面 --\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;module1.js\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;module2.js\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"language-javascript\"\u003e\n  \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// foo() module two data\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// bar() module one data\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e说明：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e全局模式：将不同的功能封装成不同的全局函数\u003c/li\u003e\n\u003cli\u003e问题：全局变量被污染了，很容易引起命名冲突\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e单例模式\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003emodule1.js\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e moduleOne = {\n  \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;module one data\u0026#x27;\u003c/span\u003e,\n  \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`foo() \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.data}\u003c/span\u003e`\u003c/span\u003e);\n  },\n  \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`bar() \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.data}\u003c/span\u003e`\u003c/span\u003e);\n  },\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003emodule2.js\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e moduleTwo = {\n  \u003cspan class=\"hljs-attr\"\u003edata\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;module two data\u0026#x27;\u003c/span\u003e,\n  \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`foo() \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.data}\u003c/span\u003e`\u003c/span\u003e);\n  },\n  \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`bar() \u003cspan class=\"hljs-subst\"\u003e${\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.data}\u003c/span\u003e`\u003c/span\u003e);\n  },\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003etest.html\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;module1.js\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;module2.js\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"language-javascript\"\u003e\n  moduleOne.\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e//foo() module one data\u003c/span\u003e\n  moduleOne.\u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e//bar() module one data\u003c/span\u003e\n\n  moduleTwo.\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e//foo() module two data\u003c/span\u003e\n  moduleTwo.\u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e//bar() module two data\u003c/span\u003e\n\n  moduleOne.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;update data\u0026#x27;\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e//能直接修改模块内部的数据\u003c/span\u003e\n  moduleOne.\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e//foo() update data\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e说明：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e单例模式模式：简单对象封装\u003c/li\u003e\n\u003cli\u003e作用：减少了全局变量（如两个模块的 \u003ccode\u003edata\u003c/code\u003e 都不是全局变量了，而是对象的某一个属性）\u003c/li\u003e\n\u003cli\u003e问题：不安全，可以直接修改模块内部的数据\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eIIFE 模式\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003emodule1.js\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 数据\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e data = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;IIFE module data\u0026#x27;\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-comment\"\u003e//操作数据的函数\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 用于暴露的函数\u003c/span\u003e\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`foo() \u003cspan class=\"hljs-subst\"\u003e${data}\u003c/span\u003e`\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 用于暴露的函数\u003c/span\u003e\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`bar() \u003cspan class=\"hljs-subst\"\u003e${data}\u003c/span\u003e`\u003c/span\u003e);\n    \u003cspan class=\"hljs-title function_\"\u003eotherFun\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e//内部调用\u003c/span\u003e\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eotherFun\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e// 内部私有的函数\u003c/span\u003e\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;privateFunction go otherFun()\u0026#x27;\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e// 暴露 foo 函数和 bar 函数\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emodule\u003c/span\u003e = { foo, bar };\n})(\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003etest.html\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;module1.js\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"language-javascript\"\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// foo() IIFE module data\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// bar() IIFE module data    privateFunction go otherFun()\u003c/span\u003e\n\n  \u003cspan class=\"hljs-comment\"\u003e// module.otherFun()  //报错，module.otherFun is not a function\u003c/span\u003e\n\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e); \u003cspan class=\"hljs-comment\"\u003e// undefined 因为我暴露的 module 对象中无 data\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003edata\u003c/span\u003e = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;xxxx\u0026#x27;\u003c/span\u003e; \u003cspan class=\"hljs-comment\"\u003e// 不是修改的模块内部的 data，而是在 module 新增 data 属性\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 验证内部的 data 没有改变  还是会输出 foo() IIFE module data\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e说明：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIIFE 模式：匿名函数自调用（闭包）\u003c/li\u003e\n\u003cli\u003eIIFE：Immediately-Invoked Function Expression（立即调用函数表达式）\u003c/li\u003e\n\u003cli\u003e作用：数据是私有的，外部只能通过暴露的方法操作\u003c/li\u003e\n\u003cli\u003e问题：如果当前这个模块依赖另一个模块怎么办？见下面 IIFE 增强版的（模块依赖于 jQuery）\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003eIIFE 模式增强\u003c/h3\u003e\n\u003cp\u003e引入 jQuery 到项目中\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003emodule1.js\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e, $\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e//数据\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e data = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;IIFE Strong module data\u0026#x27;\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-comment\"\u003e//操作数据的函数\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e//用于暴露的函数\u003c/span\u003e\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`foo() \u003cspan class=\"hljs-subst\"\u003e${data}\u003c/span\u003e`\u003c/span\u003e);\n    $(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;body\u0026#x27;\u003c/span\u003e).\u003cspan class=\"hljs-title function_\"\u003ecss\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;background\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-string\"\u003e\u0026#x27;red\u0026#x27;\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e//用于暴露的函数\u003c/span\u003e\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e`bar() \u003cspan class=\"hljs-subst\"\u003e${data}\u003c/span\u003e`\u003c/span\u003e);\n    \u003cspan class=\"hljs-title function_\"\u003eotherFun\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e//内部调用\u003c/span\u003e\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eotherFun\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-comment\"\u003e//内部私有的函数\u003c/span\u003e\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;privateFunction go otherFun()\u0026#x27;\u003c/span\u003e);\n  }\n\n  \u003cspan class=\"hljs-comment\"\u003e//暴露foo函数和bar函数\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003emoduleOne\u003c/span\u003e = { foo, bar };\n})(\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e, jQuery);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003etest.html\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-comment\"\u003e\u0026lt;!--引入的js必须有一定顺序--\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;jquery-1.10.1.js\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;module1.js\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"language-javascript\"\u003e\n  moduleOne.\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e//foo() IIFE Strong module data  而且页面背景会变色\u003c/span\u003e\n\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e说明：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIIFE 模式增强：引入依赖\u003c/li\u003e\n\u003cli\u003e这就是现代模块实现的基石。其实很像了，有引入和暴露两个方面。\u003c/li\u003e\n\u003cli\u003e存在的问题：一个页面需要引入多个 JS 文件的问题\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;module1.js\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;module2.js\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;module3.js\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;module4.js\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e请求过多：一个 \u003ccode\u003e\u0026lt;script\u0026gt;\u003c/code\u003e 标签就是一次请求\u003c/li\u003e\n\u003cli\u003e依赖模糊：看不出来谁依赖着谁？哪些模块是有依赖关系的，很难看出来\u003c/li\u003e\n\u003cli\u003e难以维护：内部依赖关系混乱也就难以维护啦\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e模块化方案\u003c/h2\u003e\n\u003ch3\u003eCommonJS\u003c/h3\u003e\n\u003cp\u003eCommonJS 是服务器端模块的规范，Node.js 就是采用了这个规范。但目前也可用于浏览器端，需要使用 Browserify 进行提前编译打包。\u003c/p\u003e\n\u003cp\u003eCommonJS 模块化的引入方式使用 \u003ccode\u003erequire\u003c/code\u003e，暴露的方式使用 \u003ccode\u003emodule.exports\u003c/code\u003e 或 \u003ccode\u003eexports\u003c/code\u003e。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e img \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;../../assets/modularization/commonjs.jpeg\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e () =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;CommonJS\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{img}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{800}\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e特点\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e同步加载依赖的模块\u003c/li\u003e\n\u003cli\u003e可复用于 Node 环境\u003c/li\u003e\n\u003cli\u003e成熟的第三方模块社区\u003c/li\u003e\n\u003c/ul\u003e\n\u003cblockquote\u003e\n\u003cp\u003e\u003cstrong\u003e彻底说明白 \u003ccode\u003emodule.exports\u003c/code\u003e 和 \u003ccode\u003eexports\u003c/code\u003e 的区别：\u003c/strong\u003e\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e在 Node.js 中，\u003ccode\u003emodule\u003c/code\u003e 是一个全局变量，类似于在浏览器端的 Window 也是一个全局变量一样的道理。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003emodule.exports\u003c/code\u003e \u003cstrong\u003e初始\u003c/strong\u003e的时候置为空对象，\u003ccode\u003eexports\u003c/code\u003e 也指向这个空对象。\u003c/p\u003e\n\u003cp\u003e内部代码实现：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;xxxx\u0026#x27;\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eexports\u003c/span\u003e: {},\n};\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e \u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e = \u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// exports 是对 module.exports 的引用\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 也就是 exports 现在指向的内存地址和 module.exports 指向的内存地址是一样的\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e上面的代码可以看出我们平常使用的 \u003ccode\u003eexports\u003c/code\u003e 是对 \u003ccode\u003emodule.exports\u003c/code\u003e 的一个引用，两者都是指向同一个对象。\u003c/p\u003e\n\u003cp\u003e用一句话来说明就是，模块的 \u003ccode\u003erequire\u003c/code\u003e（引入）能看到的只有 \u003ccode\u003emodule.exports\u003c/code\u003e 这个对象，它是看不到 \u003ccode\u003eexports\u003c/code\u003e 对象的，而我们在编写模块时用到的 \u003ccode\u003eexports\u003c/code\u003e 对象实际上只是对 \u003ccode\u003emodule.exports\u003c/code\u003e 的引用。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e = \u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e我们可以使用 \u003ccode\u003eexports.a = ‘xxx’\u003c/code\u003e 或 \u003ccode\u003eexports.b = function(){}\u003c/code\u003e 添加方法或属性，本质上它也添加在 \u003ccode\u003emodule.exports\u003c/code\u003e 所指向的对象身上。\u003c/p\u003e\n\u003cp\u003e但是你不能直接 \u003ccode\u003eexports = { a: 'xxx'}\u003c/code\u003e，这就将 \u003ccode\u003eexports\u003c/code\u003e 重新指向新的对象，它和 \u003ccode\u003emodule.exports\u003c/code\u003e 就不是指向同一个对象，也就让两者失去了关系，而 Node.js 中 \u003ccode\u003erequire\u003c/code\u003e 能看到的是 \u003ccode\u003emodule.exports\u003c/code\u003e 指向的对象。\u003c/p\u003e\n\u003cp\u003e因此，我们一般都会直接使用：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e再举例说明两者区别：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;foo\u0026#x27;\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;bar\u0026#x27;\u003c/span\u003e);\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e想要将这两个函数暴露出去，可以直接使用\u003ccode\u003eexports\u003c/code\u003e\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003efoo\u003c/span\u003e = foo;\n\u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ebar\u003c/span\u003e = bar;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e也可以对 \u003ccode\u003emodule.exports\u003c/code\u003e 赋值\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-variable language_\"\u003emodule\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003efoo\u003c/span\u003e: foo,\n  \u003cspan class=\"hljs-attr\"\u003ebar\u003c/span\u003e: bar,\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e但是不能直接对 \u003ccode\u003eexports\u003c/code\u003e 赋值\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-comment\"\u003e// 错误\u003c/span\u003e\n\u003cspan class=\"hljs-built_in\"\u003eexports\u003c/span\u003e = {\n  \u003cspan class=\"hljs-attr\"\u003efoo\u003c/span\u003e: foo,\n  \u003cspan class=\"hljs-attr\"\u003ebar\u003c/span\u003e: bar,\n};\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e因为这样做仅仅改变了\u003ccode\u003eexports\u003c/code\u003e 的引用，而不改变 \u003ccode\u003emodule.exports\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e总结\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e特点\u003c/strong\u003e：同步加载，有缓存\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e用法\u003c/strong\u003e：关键在于引入和暴露\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e引入模块\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003erequire(url)\u003c/code\u003e（\u003ccode\u003eurl\u003c/code\u003e 为路径参数）\u003c/li\u003e\n\u003cli\u003e路径：自定义模块路径必须以 \u003ccode\u003e./\u003c/code\u003e 或者 \u003ccode\u003e../\u003c/code\u003e 开头\u003c/li\u003e\n\u003cli\u003e第三方模块/内置模块/核心模块：路径直接使用模块名称\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e暴露模块\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eexports\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emodule.exports\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e主要是在服务器端使用的，但是也能在浏览器端运行，需要借助 \u003ca href=\"https://github.com/browserify/browserify\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003eBrowserify\u003c/a\u003e 进行编译。\u003c/p\u003e\n\u003ch3\u003eAMD\u003c/h3\u003e\n\u003cblockquote\u003e\n\u003cp\u003eCommonJS 规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。由于 NodeJS 主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，所以同步加载没有问题。但是如果是浏览器端，同步加载很容易阻塞，这时候 AMD 规范就出来了。AMD 规范则是非同步加载模块，允许指定回调函数。故浏览器端一般会使用 AMD 规范。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/amdjs/amdjs-api/wiki\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003eAMD\u003c/a\u003e 是 \u003ca href=\"https://github.com/requirejs/requirejs\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003erequire.js\u003c/a\u003e 在推广过程中对模块定义的规范化产出 。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e img \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;../../assets/modularization/amd.jpeg\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e () =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;AMD\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{img}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{800}\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e特点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e异步加载依赖的模块\u003c/li\u003e\n\u003cli\u003e可在不转换代码的情况下直接在浏览器运行\u003c/li\u003e\n\u003cli\u003e并行加载多个模块\u003c/li\u003e\n\u003cli\u003e可运行在浏览器和 Node 环境\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e用法：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e暴露模块\n\u003cul\u003e\n\u003cli\u003e在模块内部使用 \u003ccode\u003ereturn\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e定义模块\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003edefine(['模块名'], function (模块暴露内容) {})\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erequire(['模块名'], function (模块暴露内容) {})\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e在模块内部可以使用 \u003ccode\u003erequire\u003c/code\u003e 定义异步模块\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e主模块：\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003erequirejs.config({})\u003c/code\u003e 配置使用的模块路径\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003erequirejs(['模块名'], function (模块暴露内容) {})\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eHTML 文件引入 \u003ccode\u003e\u0026lt;script\u0026gt;\u003c/code\u003e 标签\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;script data-main='app.js' src='require.js'\u0026gt;\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eAMD（通用模块定义）主要是在浏览器使用的。\u003c/p\u003e\n\u003ch3\u003eCMD\u003c/h3\u003e\n\u003cp\u003eCMD 是根据 CommonJS 和 AMD 基础上提出的。\u003c/p\u003e\n\u003cp\u003eCMD（通用模块定义）和 AMD（异步模块定）是比较相似的。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003erequire.js\u003c/code\u003e 遵循的是 AMD（异步模块定义）规范，\u003ca href=\"https://github.com/seajs/seajs\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003esea.js\u003c/a\u003e 遵循的是 CMD （通用模块定义）规范。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e img \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;../../assets/modularization/cmd.jpeg\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e () =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;CMD\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{img}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{800}\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003cstrong\u003e特点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e异步加载，有缓存\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e用法：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e定义模块\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003edefine(function (require, exports, module) {})\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e引入模块\n\u003cul\u003e\n\u003cli\u003e同步加载 \u003ccode\u003erequire()\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e异步加载 \u003ccode\u003erequire.async(['模块名'], function(模块暴露内容) {})\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e暴露模块\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003eexports\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003emodule.exports\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003eHTML 文件引入 \u003ccode\u003e\u0026lt;script\u0026gt;\u003c/code\u003e标签\n\u003cul\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;script src='sea.js'\u0026gt;\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003e\u0026lt;script\u0026gt;seajs.use('app.js')\u0026lt;/script\u0026gt;\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003ccode\u003esea.js\u003c/code\u003e 和 \u003ccode\u003erequire.js\u003c/code\u003e 一样主要在浏览器中使用。其实这两个一般都很少使用。用的比较多的是 \u003ccode\u003ecommonjs\u003c/code\u003e 和马上要介绍的 ES6 模块化。\u003c/p\u003e\n\u003ch3\u003eES6 Module\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e特点：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e动态引入（按需加载），没有缓存\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e用法：\u003c/strong\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e引入模块使用 \u003ccode\u003eimport\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e统一暴露：\u003ccode\u003eimport {模块暴露的内容} from '模块路径'\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e分别暴露：\u003ccode\u003eimport * as m1 from './module1'\u003c/code\u003e\n\u003cul\u003e\n\u003cli\u003e这两者暴露的本质是对象，接收的时候只能以对象的解构赋值的方式来接收值\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e默认暴露：直接使用 \u003ccode\u003eimport 模块暴露的内容 from '模块路径'\u003c/code\u003e。默认暴露，暴露任意数据类型，暴露什么数据类型，接收什么数据类型。\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e暴露模块使用 \u003ccode\u003eexport\u003c/code\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e分别暴露 （基本不用）\u003c/li\u003e\n\u003cli\u003e统一暴露 （暴露多个内容）\u003c/li\u003e\n\u003cli\u003e默认暴露 （暴露单个内容）\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e主要是用在浏览器，服务器端也使用。但是现在浏览器和服务器均不支持 ES6 的模块化语法，所以要借助工具来编译运行\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/babel/babel\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003eBabel\u003c/a\u003e 将 ES6+ 转换为 ES5- （ES6 的模块化语法 编译成 \u003ccode\u003ecommonjs\u003c/code\u003e）\u003c/li\u003e\n\u003cli\u003eBrowserify 将 CommonJS 语法编译成能让浏览器识别的语法\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e严格模式\u003c/h2\u003e\n\u003cp\u003eES6 的模块自动采用严格模式，不管你是否有在模块头部加上 \u003ccode\u003e'use strict'\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e严格模式主要有以下限制：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e变量必须声明后再使用\u003c/li\u003e\n\u003cli\u003e函数的参数不能有同名属性，否则报错\u003c/li\u003e\n\u003cli\u003e不能使用 \u003ccode\u003ewith\u003c/code\u003e 语句\u003c/li\u003e\n\u003cli\u003e不能对只读属性赋值，否则报错\u003c/li\u003e\n\u003cli\u003e不能使用前缀 0 表示八进制数，否则报错\u003c/li\u003e\n\u003cli\u003e不能删除不可删除的属性，否则报错\u003c/li\u003e\n\u003cli\u003e不能删除变量 \u003ccode\u003edelete prop\u003c/code\u003e，会报错，只能删除属性 \u003ccode\u003edelete global[prop]\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eeval\u003c/code\u003e 不会在它的外层作用域引入变量\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eeval\u003c/code\u003e 和 \u003ccode\u003earguments\u003c/code\u003e 不能被重新赋值\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003earguments\u003c/code\u003e 不会自动反映函数参数的变化\u003c/li\u003e\n\u003cli\u003e不能使用 \u003ccode\u003earguments.callee\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e不能使用 \u003ccode\u003earguments.caller\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e禁止 \u003ccode\u003ethis\u003c/code\u003e 指向全局对象\u003c/li\u003e\n\u003cli\u003e不能使用 \u003ccode\u003efn.caller\u003c/code\u003e 和 \u003ccode\u003efn.arguments\u003c/code\u003e 获取函数调用的堆栈\u003c/li\u003e\n\u003cli\u003e增加了保留字（比如 \u003ccode\u003eprotected\u003c/code\u003e、\u003ccode\u003estatic\u003c/code\u003e 和 \u003ccode\u003einterface\u003c/code\u003e）\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e其中，尤其需要注意 \u003ccode\u003ethis\u003c/code\u003e 的限制。ES6 模块之中，顶层的 \u003ccode\u003ethis\u003c/code\u003e 指向 \u003ccode\u003eundefined\u003c/code\u003e，即不应该在顶层代码使用 \u003ccode\u003ethis\u003c/code\u003e。\u003c/p\u003e\n\u003ch2\u003e模块化与组合化\u003c/h2\u003e\n\u003cp\u003e既然说到模块化，其实我更想说说模块化与组件化。这两个概念在前端领域已经十分普遍。\u003c/p\u003e\n\u003cp\u003e先有模块化后有组件化。组件化是建立在模块化思想上的一次演进，一个变种。所以，我们会在软件工程体系中看过一句话：\u003cstrong\u003e模块化是组件化的基石\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e组件化和模块化的思想都是 \u003cstrong\u003e分而治之\u003c/strong\u003e 的思想。但还是有细小的区分，他们的侧重点有所不同。\u003c/p\u003e\n\u003cp\u003e组件化更加倾向于 UI 层面上，是一个可以独立展示内容的「积木」，比如一个页面的头部组件，包含结构 HTML、样式 CSS、逻辑 JS、以及静态资源图片组合一个集合体。一个页面是由众多组件组成的，就像由众多「积木」搭成的「城堡」一样； 模块化更加倾向于功能或者数据的封装，一般由几个组件或单个组件构成的带有一定功能的集合体；\u003c/p\u003e\n\u003cp\u003e引用一下 \u003ca href=\"https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Ffouber%2Fblog%2Fissues%2F10\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e@张云龙\u003c/a\u003e 对组件化的理解：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-jsx\"\u003e\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eReact\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;react\u0026#x27;\u003c/span\u003e;\n\u003cspan class=\"hljs-keyword\"\u003eimport\u003c/span\u003e img \u003cspan class=\"hljs-keyword\"\u003efrom\u003c/span\u003e \u003cspan class=\"hljs-string\"\u003e\u0026#x27;../../assets/modularization/components-1.jpeg\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-keyword\"\u003eexport\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003edefault\u003c/span\u003e () =\u0026gt; \u003cspan class=\"language-xml\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eimg\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ealt\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;组件化示意图1\u0026quot;\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003esrc\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{img}\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003ewidth\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e{720}\u003c/span\u003e /\u0026gt;\u003c/span\u003e\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u0026lt;br /\u0026gt;\u003c/p\u003e\n\u003cp\u003e就如上图的这个 \u003ccode\u003etitle\u003c/code\u003e 组件，包含了结构 HTML、样式 CSS、逻辑 JavaScript、以及静态资源图片，往往组件的组成就是以上四个方面。这个 \u003ccode\u003eheader\u003c/code\u003e 文件夹我们可以拿到其他项目中使用，它具有可以独立展示内容的特点。\u003c/p\u003e\n\u003cp\u003e结合前面提到的模块化开发，整个前端项目可以划分为这么几种开发概念：\u003c/p\u003e\n\u003ctable\u003e\n\u003cthead\u003e\n\u003ctr\u003e\n\u003cth\u003e名称\u003c/th\u003e\n\u003cth\u003e说明\u003c/th\u003e\n\u003cth\u003e举例\u003c/th\u003e\n\u003c/tr\u003e\n\u003c/thead\u003e\n\u003ctbody\u003e\n\u003ctr\u003e\n\u003ctd\u003eJS 模块\u003c/td\u003e\n\u003ctd\u003e独立算法和数据单元\u003c/td\u003e\n\u003ctd\u003e浏览器环境检测（detect）、网络请求（ajax）、应用配置（config）、DOM 操作（dom）、工具函数（utils）以及组件里的 JS 单元\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003eCSS 模块\u003c/td\u003e\n\u003ctd\u003e独立的功能性样式单元\u003c/td\u003e\n\u003ctd\u003e栅格系统（grid）、字体图标（icon-fonts）、动画样式（animate）以及组件里的 CSS 单元\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e页面\u003c/td\u003e\n\u003ctd\u003e前端这种 GUI 软件的的界面状态，是 UI 组件的容器\u003c/td\u003e\n\u003ctd\u003e首页（index）、列表页（list）、用户管理（user）\u003c/td\u003e\n\u003c/tr\u003e\n\u003ctr\u003e\n\u003ctd\u003e应用\u003c/td\u003e\n\u003ctd\u003e整个项目或整个站点被称之为应用，由多个页面组成\u003c/td\u003e\n\u003ctd\u003e\u003c/td\u003e\n\u003c/tr\u003e\n\u003c/tbody\u003e\n\u003c/table\u003e\n\u003cp\u003e那么它们之间的关系如下图所示，一个应用由多个下图的页面组成。一个页面由多个组件组合。组件中可依赖 JS 模块。\u003c/p\u003e\n\u003cp\u003e所以，前端开发现在不仅仅只是别人说的「画画页面实现点效果」的职位，它是实现软件的图形用户界面（Graphical User Interface，简称 GUI），是一名软件工程师。现在前端开发都是基于模块化和组件化的开发，可以说算是工程化的项目了。从单页面（SPA）的应用就可以看出 JavaScript 大大改善了 Web 应用的用户体验。从谷歌提出 PWA（Progressive Web Apps）就可以看出前端在领域的成长。\u003c/p\u003e\n\u003cp\u003e不仅仅如此，多终端也已经成为时下以及未来的一个必然趋势，移动端、PC 端、触摸屏、智能设备、物联网等等，相信前端在跨端的领域下肯定会有更好的解决方案。\u003c/p\u003e\n\u003cp\u003e但是，如果从整个软件工程来看，我们就会意识到一个惨痛的事实：前端工程师在整个系统工程中的地位太低了。前端是处于系统软件的上游（用户入口），因此没有其他系统会来调取前端系统的服务。而后端它在软件开发中处于下游，后端一方面要为前端提供接口服务，一方面要向中后台以及数据层索取服务，对接层次会更多，地位也就更高了。由此导致，感觉每次需求评估前端往往是最后一道坎，因为上游依托下游，就只能是下游先行了，整体上就会感觉前端对业务的参与度太低了。\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003e参考资料：\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.im/post/5c82323ce51d453a5f22b281\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 从前端模块化编程切入想聊聊前端的未来\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://link.juejin.im/?target=https%3A%2F%2Fgithub.com%2Fseajs%2Fseajs%2Fissues%2F588\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 前端模块化开发那点历史\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://link.juejin.im/?target=http%3A%2F%2Fwww.ruanyifeng.com%2Fblog%2F2012%2F10%2Fjavascript_module.html\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 JavaScript 模块化编程@阮一峰\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://link.juejin.im/?target=https%3A%2F%2Fwww.zhihu.com%2Fquestion%2F20351507%2Fanswer%2F14859415\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 知乎专栏 | AMD 和 CMD 的区别\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"markdown-body\",\"children\":[[\"$\",\"h1\",null,{\"children\":\"模块化\"}],[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"front-end\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"front-end knowledge\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>