<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/d4dd73d504c89c58.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/485ff6fe79292a08.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/0ff121a467c0636f.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-53834dba86d90934.js"/><script src="/_next/static/chunks/4bd1b696-20882bf820444624.js" async=""></script><script src="/_next/static/chunks/517-98ed787e5f259f2c.js" async=""></script><script src="/_next/static/chunks/main-app-f33d3e3aed85e21f.js" async=""></script><meta name="next-size-adjust" content=""/><title>front-end</title><meta name="description" content="front-end knowledge"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><main><div class="markdown-body"><article><h1>垃圾回收</h1>
<blockquote>
<p>由于字符串、对象和数组没有固定大小，所以当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript 序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。——《JavaScript 权威指南》</p>
</blockquote>
<p>在 C 和 C++ 之类的语言中，需要手动来管理内存的，这也是造成许多不必要问题的根源。幸运的是，在编写 JavaScript 的过程中，内存的分配以及内存的回收完全实现了自动管理。</p>
<p>JavaScript 通过 &lt;strong style=&quot;color:red&quot;&gt;自动垃圾收集机制&lt;/strong&gt; 实现内存的管理。垃圾回收机制通过垃圾收集器每隔固定的时间段（周期性）找出那些不再需要继续使用的变量，执行一次释放占用内存的操作。</p>
<blockquote>
<p>什么是不再需要继续使用的值？</p>
</blockquote>
<p>不再需要继续使用的变量也就是生命周期结束的变量。</p>
<ul>
<li><strong>局部变量</strong>：在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了（除了闭包），因此垃圾收集器很容易做出判断并回收</li>
<li><strong>全局变量</strong>：但是全局变量的生命周期直到浏览器卸载页面才会结束，也就是<strong>全局变量不会被当成垃圾变量回收</strong>。所以声明一个全局变量的时候，我们一定要慎重的考虑，在使用完这个变量的对象之后，我们是否还在需要这个对象，如果不需要的话，我们应该手动的将这个变量置为空（<code>null</code>），这样在下一次垃圾回收的时候，就能去释放这个变量上一次指向的值</li>
</ul>
<h2>原理</h2>
<p>JavaScript 有两种策略实现垃圾回收机制：</p>
<ul>
<li><a href="/front-end/core-modules/executable-code-and-execution-contexts/memory-management/#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95">引用计数法</a></li>
<li><a href="/front-end/core-modules/executable-code-and-execution-contexts/memory-management/#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E6%B3%95">标记清除法</a></li>
</ul>
<h3>引用计数法</h3>
<p><strong>引用计数法：</strong> 跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 <code>1</code>，如果这个值再被赋值给另一个变量，则引用次数加 <code>1</code>。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 <code>1</code>。当这个引用次数变成 <code>0</code> 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为 <code>0</code> 的值所占的内存。</p>
<p>这种垃圾收集方式存在一个比较大的问题就是循环引用，就是说对象 <code>a</code> 包含一个指向 <code>b</code> 的指针，对象 <code>b</code> 也包含一个指向 <code>a</code> 的引用。 这就可能造成大量内存得不到回收，也就是内存泄漏，这是因为它们的引用次数永远不可能是 <code>0</code>。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">problem</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();
  <span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();
  a.<span class="hljs-property">ref</span> = b;
  b.<span class="hljs-property">ref</span> = a;
}
</code></pre>
<blockquote>
<p>浅大小（shallow size）：对象自身所存储的原生值及其他必要数据的大小。
留存大小（retained size）：对象自身的浅大小和它支配的所有对象的浅大小的总和。</p>
</blockquote>
<p>引用计数法无法解决循环引用问题：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">var</span> x = {};
  <span class="hljs-keyword">var</span> y = {};
  x.<span class="hljs-property">a</span> = y;
  y.<span class="hljs-property">a</span> = x;
}
</code></pre>
<h3>标记清除法</h3>
<p><strong>标记清除法</strong>：当程序执行流入到一个函数中时，会创建该函数的执行上下文，执行上下文中的变量都会被标记为 <strong>进入环境</strong>，从逻辑上讲，永远不能释放 <strong>进入执行环境</strong> 变量所占用的内存。因为只要执行流进入相应的执行上下文，就可能会用到这些变量。</p>
<p>标记清除的工作流程：</p>
<ul>
<li>垃圾收集器在运行的时候会给存储在内存的中的 <strong>所有变量都加上标记</strong></li>
<li>去掉 <strong>执行上下文中的变量</strong> 以及 <strong>被环境中的变量引用的变量</strong> 的标记</li>
<li>那些 <strong>还存在标记的变量将被视为准备删除的变量</strong></li>
<li>最后垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间</li>
</ul>
<p>手动释放内存：</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;

a = <span class="hljs-literal">null</span>;
</code></pre>
<p><code>a = null</code> 其实仅仅只是做了一个释放引用的操作，让变量 <code>a</code> 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。而在适当的时候解除引用，是为页面获得更好性能的一个重要方式。</p>
<p>JavaScript 引擎的垃圾回收机制是标记清除法，判断内存是否可回收的依据是可达性，它是对引用计数法的改良，对象间的循环引用问题不会引起回收问题，因为判断是否可回收的依据是变量是否可达。这种算法下存在一个根节点，它始终不会被回收，称为 GC Root，比如 JavaScript Runtime 的全局对象，在浏览器中叫 <code>window</code> 以及 DOM 树根节点都是 GC Root。程序间对象的引用关系形成了节点的图，凡事能够从 GC Root 出发，沿着引用关系可以访达的对象被标记为活跃对象，而那些和 GC Root 孤立的对象就会被回收，可以发现代码中引用数为 0 的对象一定无法从 GC Root 访达，也就是说某个对象引用计数法认为它应该被回收的话，那么标记清除法也会将其回收，但是和 GC Root 孤立的对象，它在代码中的引用数不一定是 0，比如说对象属性的循环引用，它们都不可达，且都和 GC Root 孤立，但它们的引用数不一定是 0。所以说标记清除算法可以取代引用计数算法。</p>
<h2>堆栈溢出</h2>
<p><strong>堆栈溢出</strong>：指内存空间已经被申请完，没有足够的内存提供了。</p>
<h2>内存泄漏</h2>
<p><strong>内存泄漏</strong>：指申请的内存执行完后没有及时的清理或者销毁，占用空闲内存，内存泄漏过多的话，就会导致后面的进程申请不到内存。因此内存泄漏会导致内部内存溢出。</p>
<pre class="hljs"><code>内存泄漏 --可能导致--&gt; 堆栈溢出
</code></pre>
<p>在传统的编程软件中，比如 C 语言中，需要使用 <code>malloc</code> 来申请内存空间，再使用 <code>free</code> 来释放掉，需要手动清除。而 JavaScript 中有自己的垃圾回收机制，一般常用的垃圾收集方法就是标记清除法。</p>
<ul>
<li>即使 1Byte 的内存，也叫内存泄漏，并不一定是导致浏览器奔溃、卡顿才能叫内存泄漏</li>
<li>一般是堆区内存泄漏，栈区不会泄漏。基本数据类型的值保存在栈中，引用数据类型保存在堆中。所以对象、数组等才会发生内存泄漏。</li>
</ul>
<p><strong>常见的内存泄漏的原因</strong>：</p>
<ul>
<li>全局变量引起的内存泄漏</li>
<li>没有被清除的定时器</li>
<li>闭包</li>
</ul>
<p><strong>解决方法</strong>：</p>
<ul>
<li>减少不必要的全局变量</li>
<li>减少闭包的使用（因为闭包会导致内存泄漏）</li>
<li>避免死循环的发生</li>
</ul>
<h3>全局变量</h3>
<p>全局变量不会被当成垃圾回收，我们在编码中应该尽量避免声明全局变量。</p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;grow()&quot;</span>&gt;</span>Global Var<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript">
    <span class="hljs-keyword">function</span> <span class="hljs-title function_">LargeObj</span>(<span class="hljs-params"></span>) {
      <span class="hljs-variable language_">this</span>.<span class="hljs-property">largeArr</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000_0000</span>);
    }

    <span class="hljs-keyword">var</span> x = [];

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">grow</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">var</span> o = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LargeObj</span>();

      x.<span class="hljs-title function_">push</span>(<span class="hljs-number">0</span>);
    }
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
</code></pre>
<p>当我们使用 <a href="/front-end/core-modules/executable-code-and-execution-contexts/execution/this#%E9%BB%98%E8%AE%A4%E7%BB%91%E5%AE%9A">默认绑定</a>，<code>this</code> 会指向全局对象。</p>
<p>🔧 <strong>解决方法</strong>： 在函数内使用严格模式或手动释放全局变量的内存。</p>
<p><strong>调试方式</strong>：<code>More Tools -&gt; Developer Tools -&gt; Performance/Memory</code>，一般现在 <code>Performance</code> 面板录制页面内存占用情况随时间变化的图像，对内存泄漏有个直观的判断，然后在 <code>Memory</code> 面板定位问题发生的位置</p>
<h3>分离的 DOM 引用</h3>
<p>DOM 节点的内存被回收要满足两点：DOM 节点在 DOM 树上被移除，并且代码中没有对他的引用。内存泄漏发生在节点从 DOM 上被删除了，但代码中留存着对它的 JS 引用，我们称这种为分离的 DOM 节点。</p>
<p>实现分离的 DOM 引用的内存泄漏示例：</p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>移除列表<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>项目1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript">
    <span class="hljs-keyword">var</span> button = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;button&#x27;</span>);
    <span class="hljs-keyword">var</span> list = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;list&#x27;</span>);

    button.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
      list.<span class="hljs-title function_">remove</span>();
    });
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
</code></pre>
<p>可以通过堆快照（Heap Snapshot），调试路径 <code>Memory -&gt; Heap Snapshot -&gt; Take Snapshot</code>，堆快照可以直接告诉我们是否存在分离的 DOM 节点，只要在顶部过滤框 filter 输入 <code>detached</code>，如果过滤出东西，说明存在分离的 DOM 节点。</p>
<p>对于上例，可以把 <code>list</code> 节点放到点击节点的回调中，这样当回调函数返回后，局部变量会被销毁。</p>
<h3>闭包</h3>
<p>闭包也会造成内存泄漏，是因为函数实例上的隐式指针会留存实例创建环境下的作用域对象。</p>
<pre class="hljs"><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;closure()&quot;</span>&gt;</span>Closure<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="language-javascript">
    <span class="hljs-keyword">var</span> func = [];

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">outer</span>(<span class="hljs-params"></span>) {
      <span class="hljs-keyword">var</span> someText = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Array</span>(<span class="hljs-number">1000_0000</span>);

      <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">inner</span>(<span class="hljs-params"></span>) {
        <span class="hljs-keyword">return</span> someText;
      };
    }

    <span class="hljs-keyword">function</span> <span class="hljs-title function_">closure</span>(<span class="hljs-params"></span>) {
      funcs.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">outer</span>());
    }
  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
</code></pre>
<p>注意：并非该代码一定有什么问题，只是说明闭包会带来内存占用，不合理的内存占用才会被定性为内存泄漏。</p>
<p>调试方式：<code>More Tools -&gt; Developer Tools -&gt; Memory -&gt; Allocation instrumentation on timeline</code>。</p>
<h3>定时器</h3>
<p>当不需要 <code>setInterval</code> 或者 <code>setTimeout</code> 时，定时器没有被清除，定时器的回调函数以及内部依赖的变量都不能被回收，造成内存泄漏。</p>
<pre class="hljs"><code class="language-js"><span class="hljs-keyword">const</span> someResource = <span class="hljs-title function_">getData</span>();

<span class="hljs-comment">// node、someResource 存储了大量数据 无法回收</span>
<span class="hljs-keyword">const</span> timerId = <span class="hljs-built_in">setInterval</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  <span class="hljs-keyword">const</span> node = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;Node&#x27;</span>);

  <span class="hljs-keyword">if</span> (node) {
    <span class="hljs-comment">// 定时器也没有清除</span>
    node.<span class="hljs-property">innerHTML</span> = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(someResource);
  }
}, <span class="hljs-number">1000</span>);

<span class="hljs-built_in">clearInterval</span>(timerId);
</code></pre>
<p>🔧 <strong>解决方法</strong>：在定时器完成工作的时候，手动清除定时器。</p>
<h3>控制台打印</h3>
<p>使用 <code>console.log</code> 语句打印调试信息，因为控制台要始终保持他们的引用，以便随时查看，所以他们的内存也无法被回收，所以建议生产环境下去除控制台打印。</p>
<h2>参考资料</h2>
<ul>
<li><a href="https://segmentfault.com/a/1190000006104910" target="_blank" rel="noopener noreferrer nofollow">📝 内存基本知识</a></li>
<li><a href="https://juejin.im/post/5b10ba336fb9a01e66164346" target="_blank" rel="noopener noreferrer nofollow">📝 JavaScript 内存机制</a></li>
<li><a href="https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156" target="_blank" rel="noopener noreferrer nofollow">📝 An interesting kind of JavaScript memory leak</a></li>
<li><a href="https://juejin.cn/post/6909239354418266119" target="_blank" rel="noopener noreferrer nofollow">📝 V8 引擎垃圾回收与内存分配</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1444558" target="_blank" rel="noopener noreferrer nofollow">📝 JS 内存泄漏排查方法</a></li>
<li><a href="https://sunra.top/2021/08/04/javascript-gc/" target="_blank" rel="noopener noreferrer nofollow">📝 JavaScript 执行机制：垃圾回收机制</a></li>
</ul>
</article></div></main><script src="/_next/static/chunks/webpack-53834dba86d90934.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5244,[],\"\"]\n3:I[3866,[],\"\"]\n5:I[6213,[],\"OutletBoundary\"]\n7:I[6213,[],\"MetadataBoundary\"]\n9:I[6213,[],\"ViewportBoundary\"]\nb:I[4835,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/d4dd73d504c89c58.css\",\"style\"]\n:HL[\"/_next/static/css/485ff6fe79292a08.css\",\"style\"]\n:HL[\"/_next/static/css/0ff121a467c0636f.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"1zJy3VHENUSg9vzcRvJ6P\",\"p\":\"\",\"c\":[\"\",\"front-end\",\"core-modules\",\"executable-code-and-execution-contexts\",\"memory-management\",\"garbage-collection\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"front-end\",{\"children\":[[\"slug\",\"core-modules/executable-code-and-execution-contexts/memory-management/garbage-collection\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d4dd73d504c89c58.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"front-end\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/485ff6fe79292a08.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0ff121a467c0636f.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"main\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[[\"slug\",\"core-modules/executable-code-and-execution-contexts/memory-management/garbage-collection\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"hvsUCJGH_U4ndg-QvPe9X\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:T4802,"])</script><script>self.__next_f.push([1,"\u003ch1\u003e垃圾回收\u003c/h1\u003e\n\u003cblockquote\u003e\n\u003cp\u003e由于字符串、对象和数组没有固定大小，所以当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript 序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript 的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。——《JavaScript 权威指南》\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e在 C 和 C++ 之类的语言中，需要手动来管理内存的，这也是造成许多不必要问题的根源。幸运的是，在编写 JavaScript 的过程中，内存的分配以及内存的回收完全实现了自动管理。\u003c/p\u003e\n\u003cp\u003eJavaScript 通过 \u0026lt;strong style=\u0026quot;color:red\u0026quot;\u0026gt;自动垃圾收集机制\u0026lt;/strong\u0026gt; 实现内存的管理。垃圾回收机制通过垃圾收集器每隔固定的时间段（周期性）找出那些不再需要继续使用的变量，执行一次释放占用内存的操作。\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e什么是不再需要继续使用的值？\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e不再需要继续使用的变量也就是生命周期结束的变量。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e局部变量\u003c/strong\u003e：在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了（除了闭包），因此垃圾收集器很容易做出判断并回收\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e全局变量\u003c/strong\u003e：但是全局变量的生命周期直到浏览器卸载页面才会结束，也就是\u003cstrong\u003e全局变量不会被当成垃圾变量回收\u003c/strong\u003e。所以声明一个全局变量的时候，我们一定要慎重的考虑，在使用完这个变量的对象之后，我们是否还在需要这个对象，如果不需要的话，我们应该手动的将这个变量置为空（\u003ccode\u003enull\u003c/code\u003e），这样在下一次垃圾回收的时候，就能去释放这个变量上一次指向的值\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e原理\u003c/h2\u003e\n\u003cp\u003eJavaScript 有两种策略实现垃圾回收机制：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"/front-end/core-modules/executable-code-and-execution-contexts/memory-management/#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95\"\u003e引用计数法\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"/front-end/core-modules/executable-code-and-execution-contexts/memory-management/#%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E6%B3%95\"\u003e标记清除法\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e引用计数法\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e引用计数法：\u003c/strong\u003e 跟踪记录每个值被引用的次数，当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是 \u003ccode\u003e1\u003c/code\u003e，如果这个值再被赋值给另一个变量，则引用次数加 \u003ccode\u003e1\u003c/code\u003e。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减 \u003ccode\u003e1\u003c/code\u003e。当这个引用次数变成 \u003ccode\u003e0\u003c/code\u003e 时，则说明没有办法再访问这个值了，因而就可以将其所占的内存空间给收回来。这样，垃圾收集器下次再运行时，它就会释放那些引用次数为 \u003ccode\u003e0\u003c/code\u003e 的值所占的内存。\u003c/p\u003e\n\u003cp\u003e这种垃圾收集方式存在一个比较大的问题就是循环引用，就是说对象 \u003ccode\u003ea\u003c/code\u003e 包含一个指向 \u003ccode\u003eb\u003c/code\u003e 的指针，对象 \u003ccode\u003eb\u003c/code\u003e 也包含一个指向 \u003ccode\u003ea\u003c/code\u003e 的引用。 这就可能造成大量内存得不到回收，也就是内存泄漏，这是因为它们的引用次数永远不可能是 \u003ccode\u003e0\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e🌰 \u003cstrong\u003e代码示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eproblem\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e a = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e();\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e b = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e();\n  a.\u003cspan class=\"hljs-property\"\u003eref\u003c/span\u003e = b;\n  b.\u003cspan class=\"hljs-property\"\u003eref\u003c/span\u003e = a;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cblockquote\u003e\n\u003cp\u003e浅大小（shallow size）：对象自身所存储的原生值及其他必要数据的大小。\n留存大小（retained size）：对象自身的浅大小和它支配的所有对象的浅大小的总和。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e引用计数法无法解决循环引用问题：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e x = {};\n  \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e y = {};\n  x.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e = y;\n  y.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e = x;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e标记清除法\u003c/h3\u003e\n\u003cp\u003e\u003cstrong\u003e标记清除法\u003c/strong\u003e：当程序执行流入到一个函数中时，会创建该函数的执行上下文，执行上下文中的变量都会被标记为 \u003cstrong\u003e进入环境\u003c/strong\u003e，从逻辑上讲，永远不能释放 \u003cstrong\u003e进入执行环境\u003c/strong\u003e 变量所占用的内存。因为只要执行流进入相应的执行上下文，就可能会用到这些变量。\u003c/p\u003e\n\u003cp\u003e标记清除的工作流程：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e垃圾收集器在运行的时候会给存储在内存的中的 \u003cstrong\u003e所有变量都加上标记\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e去掉 \u003cstrong\u003e执行上下文中的变量\u003c/strong\u003e 以及 \u003cstrong\u003e被环境中的变量引用的变量\u003c/strong\u003e 的标记\u003c/li\u003e\n\u003cli\u003e那些 \u003cstrong\u003e还存在标记的变量将被视为准备删除的变量\u003c/strong\u003e\u003c/li\u003e\n\u003cli\u003e最后垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e手动释放内存：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e a = \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e;\n\na = \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003ea = null\u003c/code\u003e 其实仅仅只是做了一个释放引用的操作，让变量 \u003ccode\u003ea\u003c/code\u003e 原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。而在适当的时候解除引用，是为页面获得更好性能的一个重要方式。\u003c/p\u003e\n\u003cp\u003eJavaScript 引擎的垃圾回收机制是标记清除法，判断内存是否可回收的依据是可达性，它是对引用计数法的改良，对象间的循环引用问题不会引起回收问题，因为判断是否可回收的依据是变量是否可达。这种算法下存在一个根节点，它始终不会被回收，称为 GC Root，比如 JavaScript Runtime 的全局对象，在浏览器中叫 \u003ccode\u003ewindow\u003c/code\u003e 以及 DOM 树根节点都是 GC Root。程序间对象的引用关系形成了节点的图，凡事能够从 GC Root 出发，沿着引用关系可以访达的对象被标记为活跃对象，而那些和 GC Root 孤立的对象就会被回收，可以发现代码中引用数为 0 的对象一定无法从 GC Root 访达，也就是说某个对象引用计数法认为它应该被回收的话，那么标记清除法也会将其回收，但是和 GC Root 孤立的对象，它在代码中的引用数不一定是 0，比如说对象属性的循环引用，它们都不可达，且都和 GC Root 孤立，但它们的引用数不一定是 0。所以说标记清除算法可以取代引用计数算法。\u003c/p\u003e\n\u003ch2\u003e堆栈溢出\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e堆栈溢出\u003c/strong\u003e：指内存空间已经被申请完，没有足够的内存提供了。\u003c/p\u003e\n\u003ch2\u003e内存泄漏\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e内存泄漏\u003c/strong\u003e：指申请的内存执行完后没有及时的清理或者销毁，占用空闲内存，内存泄漏过多的话，就会导致后面的进程申请不到内存。因此内存泄漏会导致内部内存溢出。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e内存泄漏 --可能导致--\u0026gt; 堆栈溢出\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在传统的编程软件中，比如 C 语言中，需要使用 \u003ccode\u003emalloc\u003c/code\u003e 来申请内存空间，再使用 \u003ccode\u003efree\u003c/code\u003e 来释放掉，需要手动清除。而 JavaScript 中有自己的垃圾回收机制，一般常用的垃圾收集方法就是标记清除法。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e即使 1Byte 的内存，也叫内存泄漏，并不一定是导致浏览器奔溃、卡顿才能叫内存泄漏\u003c/li\u003e\n\u003cli\u003e一般是堆区内存泄漏，栈区不会泄漏。基本数据类型的值保存在栈中，引用数据类型保存在堆中。所以对象、数组等才会发生内存泄漏。\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e常见的内存泄漏的原因\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e全局变量引起的内存泄漏\u003c/li\u003e\n\u003cli\u003e没有被清除的定时器\u003c/li\u003e\n\u003cli\u003e闭包\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e解决方法\u003c/strong\u003e：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e减少不必要的全局变量\u003c/li\u003e\n\u003cli\u003e减少闭包的使用（因为闭包会导致内存泄漏）\u003c/li\u003e\n\u003cli\u003e避免死循环的发生\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e全局变量\u003c/h3\u003e\n\u003cp\u003e全局变量不会被当成垃圾回收，我们在编码中应该尽量避免声明全局变量。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonclick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;grow()\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003eGlobal Var\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"language-javascript\"\u003e\n    \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eLargeObj\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003elargeArr\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000_0000\u003c/span\u003e);\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e x = [];\n\n    \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003egrow\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e o = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eLargeObj\u003c/span\u003e();\n\n      x.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n    }\n  \u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e当我们使用 \u003ca href=\"/front-end/core-modules/executable-code-and-execution-contexts/execution/this#%E9%BB%98%E8%AE%A4%E7%BB%91%E5%AE%9A\"\u003e默认绑定\u003c/a\u003e，\u003ccode\u003ethis\u003c/code\u003e 会指向全局对象。\u003c/p\u003e\n\u003cp\u003e🔧 \u003cstrong\u003e解决方法\u003c/strong\u003e： 在函数内使用严格模式或手动释放全局变量的内存。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e调试方式\u003c/strong\u003e：\u003ccode\u003eMore Tools -\u0026gt; Developer Tools -\u0026gt; Performance/Memory\u003c/code\u003e，一般现在 \u003ccode\u003ePerformance\u003c/code\u003e 面板录制页面内存占用情况随时间变化的图像，对内存泄漏有个直观的判断，然后在 \u003ccode\u003eMemory\u003c/code\u003e 面板定位问题发生的位置\u003c/p\u003e\n\u003ch3\u003e分离的 DOM 引用\u003c/h3\u003e\n\u003cp\u003eDOM 节点的内存被回收要满足两点：DOM 节点在 DOM 树上被移除，并且代码中没有对他的引用。内存泄漏发生在节点从 DOM 上被删除了，但代码中留存着对它的 JS 引用，我们称这种为分离的 DOM 节点。\u003c/p\u003e\n\u003cp\u003e实现分离的 DOM 引用的内存泄漏示例：\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u0026gt;\u003c/span\u003e移除列表\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eid\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;list\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\n    \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u0026gt;\u003c/span\u003e项目1\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eli\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003eul\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"language-javascript\"\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e button = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementById\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;button\u0026#x27;\u003c/span\u003e);\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e list = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementById\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;list\u0026#x27;\u003c/span\u003e);\n\n    button.\u003cspan class=\"hljs-title function_\"\u003eaddEventListener\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;click\u0026#x27;\u003c/span\u003e, \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      list.\u003cspan class=\"hljs-title function_\"\u003eremove\u003c/span\u003e();\n    });\n  \u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以通过堆快照（Heap Snapshot），调试路径 \u003ccode\u003eMemory -\u0026gt; Heap Snapshot -\u0026gt; Take Snapshot\u003c/code\u003e，堆快照可以直接告诉我们是否存在分离的 DOM 节点，只要在顶部过滤框 filter 输入 \u003ccode\u003edetached\u003c/code\u003e，如果过滤出东西，说明存在分离的 DOM 节点。\u003c/p\u003e\n\u003cp\u003e对于上例，可以把 \u003ccode\u003elist\u003c/code\u003e 节点放到点击节点的回调中，这样当回调函数返回后，局部变量会被销毁。\u003c/p\u003e\n\u003ch3\u003e闭包\u003c/h3\u003e\n\u003cp\u003e闭包也会造成内存泄漏，是因为函数实例上的隐式指针会留存实例创建环境下的作用域对象。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-html\"\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003eonclick\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;closure()\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003eClosure\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ebutton\u003c/span\u003e\u0026gt;\u003c/span\u003e\n  \u003cspan class=\"hljs-tag\"\u003e\u0026lt;\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e \u003cspan class=\"hljs-attr\"\u003etype\u003c/span\u003e=\u003cspan class=\"hljs-string\"\u003e\u0026quot;text/javascript\u0026quot;\u003c/span\u003e\u0026gt;\u003c/span\u003e\u003cspan class=\"language-javascript\"\u003e\n    \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e func = [];\n\n    \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eouter\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e someText = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003eArray\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1000_0000\u003c/span\u003e);\n\n      \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003einner\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n        \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e someText;\n      };\n    }\n\n    \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eclosure\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n      funcs.\u003cspan class=\"hljs-title function_\"\u003epush\u003c/span\u003e(\u003cspan class=\"hljs-title function_\"\u003eouter\u003c/span\u003e());\n    }\n  \u003c/span\u003e\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003escript\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003cspan class=\"hljs-tag\"\u003e\u0026lt;/\u003cspan class=\"hljs-name\"\u003ebody\u003c/span\u003e\u0026gt;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e注意：并非该代码一定有什么问题，只是说明闭包会带来内存占用，不合理的内存占用才会被定性为内存泄漏。\u003c/p\u003e\n\u003cp\u003e调试方式：\u003ccode\u003eMore Tools -\u0026gt; Developer Tools -\u0026gt; Memory -\u0026gt; Allocation instrumentation on timeline\u003c/code\u003e。\u003c/p\u003e\n\u003ch3\u003e定时器\u003c/h3\u003e\n\u003cp\u003e当不需要 \u003ccode\u003esetInterval\u003c/code\u003e 或者 \u003ccode\u003esetTimeout\u003c/code\u003e 时，定时器没有被清除，定时器的回调函数以及内部依赖的变量都不能被回收，造成内存泄漏。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode class=\"language-js\"\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e someResource = \u003cspan class=\"hljs-title function_\"\u003egetData\u003c/span\u003e();\n\n\u003cspan class=\"hljs-comment\"\u003e// node、someResource 存储了大量数据 无法回收\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e timerId = \u003cspan class=\"hljs-built_in\"\u003esetInterval\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e node = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementById\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;Node\u0026#x27;\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (node) {\n    \u003cspan class=\"hljs-comment\"\u003e// 定时器也没有清除\u003c/span\u003e\n    node.\u003cspan class=\"hljs-property\"\u003einnerHTML\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eJSON\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003estringify\u003c/span\u003e(someResource);\n  }\n}, \u003cspan class=\"hljs-number\"\u003e1000\u003c/span\u003e);\n\n\u003cspan class=\"hljs-built_in\"\u003eclearInterval\u003c/span\u003e(timerId);\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e🔧 \u003cstrong\u003e解决方法\u003c/strong\u003e：在定时器完成工作的时候，手动清除定时器。\u003c/p\u003e\n\u003ch3\u003e控制台打印\u003c/h3\u003e\n\u003cp\u003e使用 \u003ccode\u003econsole.log\u003c/code\u003e 语句打印调试信息，因为控制台要始终保持他们的引用，以便随时查看，所以他们的内存也无法被回收，所以建议生产环境下去除控制台打印。\u003c/p\u003e\n\u003ch2\u003e参考资料\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://segmentfault.com/a/1190000006104910\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 内存基本知识\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.im/post/5b10ba336fb9a01e66164346\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 JavaScript 内存机制\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 An interesting kind of JavaScript memory leak\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/6909239354418266119\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 V8 引擎垃圾回收与内存分配\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://cloud.tencent.com/developer/article/1444558\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 JS 内存泄漏排查方法\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://sunra.top/2021/08/04/javascript-gc/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 JavaScript 执行机制：垃圾回收机制\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"markdown-body\",\"children\":[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"front-end\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"front-end knowledge\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>