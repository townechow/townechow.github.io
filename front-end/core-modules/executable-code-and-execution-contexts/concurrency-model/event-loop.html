<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/d498c84e4ab246b3.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/485ff6fe79292a08.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/b9d97b2190475167.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/851cdee6d90716dd.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-78112f590b744806.js"/><script src="/_next/static/chunks/4bd1b696-20882bf820444624.js" async=""></script><script src="/_next/static/chunks/517-98ed787e5f259f2c.js" async=""></script><script src="/_next/static/chunks/main-app-f33d3e3aed85e21f.js" async=""></script><meta name="next-size-adjust" content=""/><title>front-end</title><meta name="description" content="front-end knowledge"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><main><div class="markdown-body"><article><h1>事件循环</h1>
<p>为了协调事件、用户交互、脚本、UI 渲染、网络请求，用户代理必须使用 <strong>事件循环机制（Event Loop）</strong>。</p>
<p>这种事件循环机制是由 JavaScript 的宿主环境来实现的，在浏览器运行环境中由浏览器内核引擎实现，而在 NodeJS 中则由 <a href="https://github.com/libuv/libuv" target="_blank" rel="noopener noreferrer nofollow">libuv</a> 引擎实现。</p>
<p>主线程运行时候，产生堆（Heap）和栈（Stack），栈中的代码调用各种外部 API，它们在任务队列中加入各种事件。只要栈中的代码执行完毕，主线程就会通过事件循环机制读取任务队列，依次执行那些事件所对应的回调函数。</p>
<p>运行机制：</p>
<ol>
<li>所有同步任务都在主线程上执行，形成一个 <strong>执行栈</strong>（Execution Context Stack）</li>
<li>主线程之外，还存在一个 <strong>任务队列</strong>（Task Queue）。只要异步任务有了运行结果，就在 <strong>任务队列</strong> 之中放置一个事件</li>
<li>一旦 <strong>执行栈</strong> 中的所有同步任务执行完毕，系统就会读取 <strong>任务队列</strong>，看看里面有哪些待执行事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行</li>
<li>主线程不断重复上面的第三步</li>
</ol>
<h2>浏览器环境</h2>
<p>JavaScript 的异步任务根据事件分类分为两种：宏任务（MacroTask）和微任务（MicroTask）</p>
<ul>
<li><strong>宏任务</strong>：main script、setTimeout、setInterval、setImmediate（Node.js）、I/O（Mouse Events、Keyboard Events、Network Events）、UI Rendering（HTML Parsing）、MessageChannel</li>
<li><strong>微任务</strong>：Promise.then（非 new Promise）、process.nextTick（Node.js）、MutationObserver</li>
</ul>
<p>宏任务与微任务的区别在于队列中事件的执行优先级。进入整体代码（宏任务）后，开始首次事件循环，当执行上下文栈清空后，事件循环机制会优先检测微任务队列中的事件并推至主线程执行，当微任务队列清空后，才会去检测宏任务队列中的事件，再将事件推至主线程中执行，而当执行上下文栈再次清空后，事件循环机制又会检测微任务队列，如此反复循环。</p>
<p><strong>宏任务与微任务的优先级</strong></p>
<ul>
<li>宏任务的优先级高于微任务</li>
<li>每个宏任务执行完毕后都必须将当前的微任务队列清空</li>
<li>第一个 <code>&lt;script&gt;</code> 标签的代码是第一个宏任务</li>
<li><code>process.nextTick</code> 优先级高于 <code>Promise.then</code></li>
</ul>
<img alt="事件循环机制中宏任务和微任务图解" src="../../../assets/event-loop/workflow.jpg" width="720" /><p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>);

<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>);
}, <span class="hljs-number">0</span>);

<span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">3</span>);
  <span class="hljs-title function_">resolve</span>();
})
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">4</span>);
  })
  .<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">5</span>);
  });

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">6</span>);

<span class="hljs-comment">// 1 3 6 4 5 2</span>
</code></pre>
<h2>Node 环境</h2>
<p>在 Node 中，事件循环表现出的状态与浏览器中大致相同。不同的是 Node 中有一套自己的模型。Node 中事件循环的实现是依靠的 <a href="https://github.com/libuv/libuv" target="_blank" rel="noopener noreferrer nofollow">libuv</a> 引擎。我们知道 Node 选择 Chrome V8 引擎作为 JavaScript 解释器，V8 引擎将 JavaScript 代码分析后去调用对应的 Node API，而这些 API 最后则由 libuv 引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上 Node 中的事件循环存在于 libuv 引擎中。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code>     ┌───────────────────────┐
┌─&gt;│        timers         │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     I/O callbacks     │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
│  │     idle, prepare     │
│  └──────────┬────────────┘      ┌───────────────┐
│  ┌──────────┴────────────┐      │   <span class="hljs-attr">incoming</span>:   │
│  │         poll          │&lt;──connections───     │
│  └──────────┬────────────┘      │   data, etc.  │
│  ┌──────────┴────────────┐      └───────────────┘
│  │        check          │
│  └──────────┬────────────┘
│  ┌──────────┴────────────┐
└──┤    close callbacks    │
   └───────────────────────┘
</code></pre>
<ul>
<li>外部输入数据</li>
<li>轮询阶段（Poll）：等待新的 I/O 事件，Node 在一些特殊情况下会阻塞在这里</li>
<li>检查阶段（Check）：<code>setImmediate</code> 的回调会在这个阶段执行</li>
<li>关闭事件回调阶段（Close Callback）</li>
<li>定时器检测阶段（Timer）：这个阶段执行定时器队列中的回调</li>
<li>I/O 事件回调阶段（I/O Callbacks）：这个阶段执行几乎所有的回调，但是不包括 <code>close</code> 事件、定时器和 <code>setImmediate()</code> 的回调</li>
<li>闲置阶段（Idle Prepare）：仅在内部使用，不必理会</li>
</ul>
<p>当一个消息需要太长时间才能处理完毕时，Web 应用就无法处理用户的交互，例如点击或滚动。浏览器用程序需要过长时间运行的对话框来缓解这个问题。一个很好的做法是缩短消息处理，并在可能的情况下将一个消息裁剪成多个消息。</p>
<h2>参考资料</h2>
<ul>
<li><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="noopener noreferrer nofollow">📖 HTML Standard: Processing model</a></li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop" target="_blank" rel="noopener noreferrer nofollow">📖 MDN: EventLoop</a></li>
<li><a href="https://blog.carbonfive.com/2013/10/27/the-javascript-event-loop-explained/" target="_blank" rel="noopener noreferrer nofollow">📝 The JavaScript Event Loop: Explained</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/33058983" target="_blank" rel="noopener noreferrer nofollow">📝 详解 JavaScript 中的 Event Loop（事件循环）机制</a></li>
<li><a href="https://cnodejs.org/topic/5a9108d78d6e16e56bb80882" target="_blank" rel="noopener noreferrer nofollow">📝 不要混淆 Node.js 和浏览器中的 Event Loop</a></li>
<li><a href="https://www.youtube.com/watch?v=u1kqx6AenYw" target="_blank" rel="noopener noreferrer nofollow">🎥 Further Adventure of the Event Loop</a></li>
<li><a href="https://blog.csdn.net/lqyygyss/article/details/102662606" target="_blank" rel="noopener noreferrer nofollow">深度揭秘 Promise 微任务和执行过程</a></li>
<li><a href="https://kongchenglc.github.io/blog/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF20171026/" target="_blank" rel="noopener noreferrer nofollow">事件循环与任务队列</a></li>
<li><a href="https://juejin.cn/post/6844904165462769678" target="_blank" rel="noopener noreferrer nofollow">深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调（动图演示）</a></li>
</ul>
</article></div></main><script src="/_next/static/chunks/webpack-78112f590b744806.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5244,[],\"\"]\n3:I[3866,[],\"\"]\n5:I[6213,[],\"OutletBoundary\"]\n7:I[6213,[],\"MetadataBoundary\"]\n9:I[6213,[],\"ViewportBoundary\"]\nb:I[4835,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/d498c84e4ab246b3.css\",\"style\"]\n:HL[\"/_next/static/css/485ff6fe79292a08.css\",\"style\"]\n:HL[\"/_next/static/css/b9d97b2190475167.css\",\"style\"]\n:HL[\"/_next/static/css/851cdee6d90716dd.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"NFjmtHF2up8B2PpbDjLiS\",\"p\":\"\",\"c\":[\"\",\"front-end\",\"core-modules\",\"executable-code-and-execution-contexts\",\"concurrency-model\",\"event-loop\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"front-end\",{\"children\":[[\"slug\",\"core-modules/executable-code-and-execution-contexts/concurrency-model/event-loop\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d498c84e4ab246b3.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/485ff6fe79292a08.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/b9d97b2190475167.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"front-end\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/851cdee6d90716dd.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"main\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[[\"slug\",\"core-modules/executable-code-and-execution-contexts/concurrency-model/event-loop\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"zzdOAa5BogNPdAE0FJVfp\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:T248e,"])</script><script>self.__next_f.push([1,"\u003ch1\u003e事件循环\u003c/h1\u003e\n\u003cp\u003e为了协调事件、用户交互、脚本、UI 渲染、网络请求，用户代理必须使用 \u003cstrong\u003e事件循环机制（Event Loop）\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e这种事件循环机制是由 JavaScript 的宿主环境来实现的，在浏览器运行环境中由浏览器内核引擎实现，而在 NodeJS 中则由 \u003ca href=\"https://github.com/libuv/libuv\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003elibuv\u003c/a\u003e 引擎实现。\u003c/p\u003e\n\u003cp\u003e主线程运行时候，产生堆（Heap）和栈（Stack），栈中的代码调用各种外部 API，它们在任务队列中加入各种事件。只要栈中的代码执行完毕，主线程就会通过事件循环机制读取任务队列，依次执行那些事件所对应的回调函数。\u003c/p\u003e\n\u003cp\u003e运行机制：\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e所有同步任务都在主线程上执行，形成一个 \u003cstrong\u003e执行栈\u003c/strong\u003e（Execution Context Stack）\u003c/li\u003e\n\u003cli\u003e主线程之外，还存在一个 \u003cstrong\u003e任务队列\u003c/strong\u003e（Task Queue）。只要异步任务有了运行结果，就在 \u003cstrong\u003e任务队列\u003c/strong\u003e 之中放置一个事件\u003c/li\u003e\n\u003cli\u003e一旦 \u003cstrong\u003e执行栈\u003c/strong\u003e 中的所有同步任务执行完毕，系统就会读取 \u003cstrong\u003e任务队列\u003c/strong\u003e，看看里面有哪些待执行事件。那些对应的异步任务，于是结束等待状态，进入执行栈，开始执行\u003c/li\u003e\n\u003cli\u003e主线程不断重复上面的第三步\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e浏览器环境\u003c/h2\u003e\n\u003cp\u003eJavaScript 的异步任务根据事件分类分为两种：宏任务（MacroTask）和微任务（MicroTask）\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003e宏任务\u003c/strong\u003e：main script、setTimeout、setInterval、setImmediate（Node.js）、I/O（Mouse Events、Keyboard Events、Network Events）、UI Rendering（HTML Parsing）、MessageChannel\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003e微任务\u003c/strong\u003e：Promise.then（非 new Promise）、process.nextTick（Node.js）、MutationObserver\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e宏任务与微任务的区别在于队列中事件的执行优先级。进入整体代码（宏任务）后，开始首次事件循环，当执行上下文栈清空后，事件循环机制会优先检测微任务队列中的事件并推至主线程执行，当微任务队列清空后，才会去检测宏任务队列中的事件，再将事件推至主线程中执行，而当执行上下文栈再次清空后，事件循环机制又会检测微任务队列，如此反复循环。\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e宏任务与微任务的优先级\u003c/strong\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e宏任务的优先级高于微任务\u003c/li\u003e\n\u003cli\u003e每个宏任务执行完毕后都必须将当前的微任务队列清空\u003c/li\u003e\n\u003cli\u003e第一个 \u003ccode\u003e\u0026lt;script\u0026gt;\u003c/code\u003e 标签的代码是第一个宏任务\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003eprocess.nextTick\u003c/code\u003e 优先级高于 \u003ccode\u003ePromise.then\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cimg alt=\"事件循环机制中宏任务和微任务图解\" src=\"../../../assets/event-loop/workflow.jpg\" width=\"720\" /\u003e\u003cp\u003e🌰 \u003cstrong\u003e代码示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e);\n\n\u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e() =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n}, \u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e);\n\n\u003cspan class=\"hljs-keyword\"\u003elet\u003c/span\u003e promise = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title class_\"\u003ePromise\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n  \u003cspan class=\"hljs-title function_\"\u003eresolve\u003c/span\u003e();\n})\n  .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e);\n  })\n  .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003eres\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e5\u003c/span\u003e);\n  });\n\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e6\u003c/span\u003e);\n\n\u003cspan class=\"hljs-comment\"\u003e// 1 3 6 4 5 2\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003eNode 环境\u003c/h2\u003e\n\u003cp\u003e在 Node 中，事件循环表现出的状态与浏览器中大致相同。不同的是 Node 中有一套自己的模型。Node 中事件循环的实现是依靠的 \u003ca href=\"https://github.com/libuv/libuv\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003elibuv\u003c/a\u003e 引擎。我们知道 Node 选择 Chrome V8 引擎作为 JavaScript 解释器，V8 引擎将 JavaScript 代码分析后去调用对应的 Node API，而这些 API 最后则由 libuv 引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上 Node 中的事件循环存在于 libuv 引擎中。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e     ┌───────────────────────┐\n┌─\u0026gt;│        timers         │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n│  │     I/O callbacks     │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n│  │     idle, prepare     │\n│  └──────────┬────────────┘      ┌───────────────┐\n│  ┌──────────┴────────────┐      │   \u003cspan class=\"hljs-attr\"\u003eincoming\u003c/span\u003e:   │\n│  │         poll          │\u0026lt;──connections───     │\n│  └──────────┬────────────┘      │   data, etc.  │\n│  ┌──────────┴────────────┐      └───────────────┘\n│  │        check          │\n│  └──────────┬────────────┘\n│  ┌──────────┴────────────┐\n└──┤    close callbacks    │\n   └───────────────────────┘\n\u003c/code\u003e\u003c/pre\u003e\n\u003cul\u003e\n\u003cli\u003e外部输入数据\u003c/li\u003e\n\u003cli\u003e轮询阶段（Poll）：等待新的 I/O 事件，Node 在一些特殊情况下会阻塞在这里\u003c/li\u003e\n\u003cli\u003e检查阶段（Check）：\u003ccode\u003esetImmediate\u003c/code\u003e 的回调会在这个阶段执行\u003c/li\u003e\n\u003cli\u003e关闭事件回调阶段（Close Callback）\u003c/li\u003e\n\u003cli\u003e定时器检测阶段（Timer）：这个阶段执行定时器队列中的回调\u003c/li\u003e\n\u003cli\u003eI/O 事件回调阶段（I/O Callbacks）：这个阶段执行几乎所有的回调，但是不包括 \u003ccode\u003eclose\u003c/code\u003e 事件、定时器和 \u003ccode\u003esetImmediate()\u003c/code\u003e 的回调\u003c/li\u003e\n\u003cli\u003e闲置阶段（Idle Prepare）：仅在内部使用，不必理会\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e当一个消息需要太长时间才能处理完毕时，Web 应用就无法处理用户的交互，例如点击或滚动。浏览器用程序需要过长时间运行的对话框来缓解这个问题。一个很好的做法是缩短消息处理，并在可能的情况下将一个消息裁剪成多个消息。\u003c/p\u003e\n\u003ch2\u003e参考资料\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📖 HTML Standard: Processing model\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📖 MDN: EventLoop\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://blog.carbonfive.com/2013/10/27/the-javascript-event-loop-explained/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 The JavaScript Event Loop: Explained\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/33058983\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 详解 JavaScript 中的 Event Loop（事件循环）机制\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://cnodejs.org/topic/5a9108d78d6e16e56bb80882\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 不要混淆 Node.js 和浏览器中的 Event Loop\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.youtube.com/watch?v=u1kqx6AenYw\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e🎥 Further Adventure of the Event Loop\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://blog.csdn.net/lqyygyss/article/details/102662606\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e深度揭秘 Promise 微任务和执行过程\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://kongchenglc.github.io/blog/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF20171026/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e事件循环与任务队列\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://juejin.cn/post/6844904165462769678\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e深入解析你不知道的 EventLoop 和浏览器渲染、帧动画、空闲回调（动图演示）\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"markdown-body\",\"children\":[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"front-end\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"front-end knowledge\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>