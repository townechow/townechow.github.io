<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/d498c84e4ab246b3.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/485ff6fe79292a08.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/b9d97b2190475167.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/851cdee6d90716dd.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-78112f590b744806.js"/><script src="/_next/static/chunks/4bd1b696-20882bf820444624.js" async=""></script><script src="/_next/static/chunks/517-98ed787e5f259f2c.js" async=""></script><script src="/_next/static/chunks/main-app-f33d3e3aed85e21f.js" async=""></script><meta name="next-size-adjust" content=""/><title>front-end</title><meta name="description" content="front-end knowledge"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><main><div class="markdown-body"><article><h1>当前执行上下文 this</h1>
<p>业界没有 <strong>当前执行上下文</strong> 的叫法，但是笔者私自把 <code>this</code> 的指向理解为执行时所指向的执行上下文。</p>
<h2>调用位置</h2>
<p>在理解 <code>this</code> 的绑定过程之前，首先要理解 <code>this</code> 的<strong>调用位置</strong>：调用位置就是函数在代码中被调用的位置（而不是声明的位置）。</p>
<p>而要理解 <code>this</code> 的调用位置，最重要的是要 <strong>分析调用栈</strong>（就是为了到达当前执行位置所调用的所有函数）。我们关心的调用位置就在当前正在执行的函数的前一个调用中。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">baz</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 当前调用栈是：baz</span>
  <span class="hljs-comment">// 因此，当前调用位置是全局作用域</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;baz&#x27;</span>);
  <span class="hljs-title function_">bar</span>(); <span class="hljs-comment">// &lt;-- bar 的调用的位置</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 当前调用栈是 baz -&gt; bar</span>
  <span class="hljs-comment">// 因此，当前调用调用位置在 baz 中</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;bar&#x27;</span>);
  <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// &lt;-- foo 的调用位置</span>
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 当前调用栈是 baz -&gt; bar -&gt; foo</span>
  <span class="hljs-comment">// 因此，当前调用位置在 bar 中</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;foo&#x27;</span>);
}

<span class="hljs-title function_">baz</span>(); <span class="hljs-comment">// &lt;-- baz 的调用位置</span>
</code></pre>
<p>注意我们是如何从调用栈中分析出真正的调用位置，因为它决定了 <code>this</code> 的绑定。</p>
<h2>绑定规则</h2>
<p>函数的执行过程中调用位置决定 <code>this</code> 的 <strong>绑定对象</strong>。</p>
<p>你必须找到调用位置，然后判断需要应用下面四条规则中的哪一条。我们首先会分别解释这四条规则，然后解释多条规则都可用时它们的优先级如何排列。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code>(调用栈) =&gt; <span class="hljs-function">(<span class="hljs-params">调用位置</span>) =&gt;</span> <span class="hljs-function">(<span class="hljs-params">绑定规则</span>) =&gt;</span> 规则优先级;
</code></pre>
<h3>默认绑定</h3>
<p>首先要介绍的是最常用的函数调用类型：<strong>独立函数调用</strong>。可以把这条规则看作是无法应用其他规则时的默认规则。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);
}

<span class="hljs-comment">// 声明在全局作用域中的变量就是全局对象的一个同名属性</span>
<span class="hljs-comment">// 相当于 window.a = 2</span>
<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;

<span class="hljs-comment">// 调用 foo 函数时 this.a 被解析成了全局变量 a</span>
<span class="hljs-comment">// 因为在本例中，函数调用时应用了 this 的默认绑定</span>
<span class="hljs-comment">// 因此 this 指向全局对象 global objects 或 window objects</span>
<span class="hljs-comment">// 分析调用位置来获知 foo 是如何调用的</span>
<span class="hljs-comment">// foo 函数直接使用不带任何修饰的函数引用进行调用，因此只能使用默认绑定，无法应用其他规则</span>
<span class="hljs-title function_">foo</span>();
<span class="hljs-comment">// 2</span>
</code></pre>
<p>如果使用严格模式（Strict Mode），则不能将全局对象用于默认绑定，因此 <code>this</code> 会绑定到 <code>undefined</code>。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-string">&#x27;use strict&#x27;</span>;

  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);
}

<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;

<span class="hljs-title function_">foo</span>();
<span class="hljs-comment">// TypeError:this is undefined</span>
</code></pre>
<p>这里有一个微妙但是非常重要的细节，虽然 <code>this</code> 的绑定规则完全取决于调用位置，但是只有 <code>foo()</code> 运行在非严格模式下时，默认绑定才能绑定到全局对象；在严格模式下调用 <code>foo</code> 则不受默认绑定影响。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);
}

<span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>;

(<span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-string">&#x27;use strict&#x27;</span>;

  <span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2</span>
})();
</code></pre>
<p>⚠️ <strong>注意</strong>：通常来说你不应该在代码中混合使用严格模式和非严格模式。整个程序要么严格要么非严格。然而，有时候你可能会用到第三方库，其严格程度和你代码有所不同，因此一定要注意这类兼容性细节。</p>
<h3>隐式绑定</h3>
<p>另一条需要考虑的规则是调用位置是否有<strong>上下文对象</strong>，或者说是否<strong>被某个对象拥有或者包含</strong>，不过这种说法可能会造成一些误导。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);
}

<span class="hljs-keyword">const</span> container = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">foo</span>: foo,
};

container.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 2</span>
</code></pre>
<p>首先需要注意的是 <code>foo</code> 的声明方式，及其之后是如何被当作引用属性添加到 <code>container</code> 中的。但是无论是直接在 <code>container</code> 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于 <code>container</code> 对象。</p>
<p>然而，调用位置会使用 <code>container</code> 上下文来引用函数，因此你可以说函数被调用时 <code>container</code> 对象 <strong>拥有</strong> 或者 <strong>包含</strong> 它。</p>
<p>无论你如何称呼这个模式，当 <code>foo</code> 被调用时，它的前面确实加上了对 <code>container</code> 的引用。当函数引用有上下文时，隐式绑定规则会把函数调用中的 <code>this</code> 绑定到这个上下文对象。因为调用 <code>foo</code> 时 <code>this</code> 被绑定到 <code>container</code> 上，因此 <code>this.a</code> 和 <code>container.a</code> 是一样的。</p>
<p>💡 <strong>对象属性引用链中只有上一层或最后一层在调用位置中起作用。</strong></p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);
}

<span class="hljs-keyword">var</span> obj2 = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">42</span>,
  <span class="hljs-attr">foo</span>: foo,
};

<span class="hljs-keyword">var</span> obj1 = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">obj2</span>: obj2,
};

obj1.<span class="hljs-property">obj2</span>.<span class="hljs-title function_">foo</span>(); <span class="hljs-comment">// 42</span>
</code></pre>
<h4>隐式丢失</h4>
<p>一个最常见的 <code>this</code> 绑定问题就是<strong>被隐式绑定的函数会丢失绑定对象</strong>，也就是说它会应用默认绑定，从而把 <code>this</code> 绑定到全局对象或者 <code>undefined</code> 上（这取决于是否是严格模式）。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);
}

<span class="hljs-keyword">const</span> container = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">foo</span>: foo,
};

<span class="hljs-comment">// 函数别名</span>
<span class="hljs-keyword">const</span> bar = container.<span class="hljs-property">foo</span>;

<span class="hljs-comment">// a 是全局对象的属性</span>
<span class="hljs-keyword">const</span> a = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;

<span class="hljs-title function_">bar</span>();
<span class="hljs-comment">// &quot;Hello world!&quot;</span>
</code></pre>
<p>📍 虽然 <code>bar</code> 是 <code>container.foo</code> 的一个引用，但是实际上，它引用的是 <code>foo</code> 函数本身，因此此时的 <code>bar</code> 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。</p>
<p>一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">bar</span>(<span class="hljs-params">fn</span>) {
  <span class="hljs-comment">// fn 其实引用的是 foo</span>
  <span class="hljs-title function_">fn</span>(); <span class="hljs-comment">// &lt;--调用位置</span>
}

<span class="hljs-keyword">var</span> container = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">foo</span>: foo,
};

<span class="hljs-comment">// a 是全局对象的属性</span>
<span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;

<span class="hljs-title function_">bar</span>(container.<span class="hljs-property">foo</span>);
<span class="hljs-comment">// &quot;Hello world!&quot;</span>
</code></pre>
<p>参数传递其实是一种<strong>隐式赋值</strong>，因此我们传入函数时也会被隐式赋值，所以结果和上个示例一样。</p>
<p>如果把函数传入语言内置的函数而不是传入你自己声明的函数，结果是一样的，没有区别。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);
}

<span class="hljs-keyword">const</span> container = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">foo</span>: foo,
};

<span class="hljs-comment">// a 是全局对象的属性</span>
<span class="hljs-keyword">var</span> a = <span class="hljs-string">&#x27;Hello world!&#x27;</span>;

<span class="hljs-built_in">setTimeout</span>(container.<span class="hljs-property">foo</span>, <span class="hljs-number">100</span>);
<span class="hljs-comment">// &#x27;Hello world!&#x27;</span>
</code></pre>
<p>回调函数丢失 <code>this</code> 绑定是非常常见的。</p>
<p>除此之外，还有一种情况 <code>this</code> 的行为会出乎我们意料：调用回调函数的函数可能会修改 <code>this</code>。在一些流行的 JavaScript 库中事件处理器会把回调函数的 <code>this</code> 强制绑定到触发事件的 DOM 元素上。这在一些情况下可能很有用，但是有时它可能会让你感到非常郁闷。遗憾的是，这些工具通常无法选择是否启用这个行为。</p>
<p>无论是哪种情况，<code>this</code> 的改变都是意想不到的，实际上你无法控制回调函数的执行方式，因此就没有办法控制调用位置以得到期望的绑定。之后我们会介绍如何通过固定 <code>this</code> 来修复这个问题。</p>
<h3>显式绑定</h3>
<p>就像我们刚才看到的那样，在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 <code>this</code> 隐式绑定到该对象上。</p>
<p>JavaScript 提供了 <code>apply</code>、<code>call</code> 和 <code>bind</code> 方法，为创建的所有函数 <strong>绑定宿主环境</strong>。通过这些方法绑定函数的 <code>this</code> 指向称为 <strong>显式绑定</strong>。</p>
<h4>硬绑定</h4>
<p>硬绑定可以解决之前提出的丢失绑定的问题。</p>
<p>🌰 <strong>代码示例</strong>：</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(ths.<span class="hljs-property">a</span>);
}

<span class="hljs-keyword">const</span> container = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,
};

<span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) {
  foo.<span class="hljs-title function_">call</span>(container);
};

<span class="hljs-title function_">bar</span>();
<span class="hljs-comment">// 2</span>

<span class="hljs-built_in">setTimeout</span>(bar, <span class="hljs-number">100</span>);
<span class="hljs-comment">// 2</span>

<span class="hljs-comment">// 硬绑定的 bar 不可能再修改它的 this</span>
bar.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">window</span>);
<span class="hljs-comment">// 2</span>
</code></pre>
<p>我们创建了函数 <code>bar</code>，并在它的内部手动调用了 <code>foo.call(container)</code> ，因此强制把 <code>foo</code> 的 <code>this</code> 绑定到了 <code>container</code> 。无论之后如何调用函数 <code>bar</code>，它总会手动在 <code>container</code> 上调用 <code>foo</code>。这种绑定是一种显式（手动）的强制绑定，因此我们称之为<strong>硬绑定</strong>。</p>
<h4>内置函数</h4>
<p>第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为 <strong>上下文（context）</strong>，其作用和 <code>bind</code> 一样，确保你的回调函数使用指定的 <code>this</code> 。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">item</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span>, item);
}

<span class="hljs-keyword">const</span> columns = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;No:&#x27;</span>,
}[
  <span class="hljs-comment">// 调用 foo 时把 this 绑定到 columns</span>
  (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)
].<span class="hljs-title function_">forEach</span>(foo, columns);
<span class="hljs-comment">// No:1 No:2 No:3</span>
</code></pre>
<p>这些函数实际上就是通过 <code>call</code> 或者 <code>apply</code> 实现了显式绑定，这样代码会更加优雅。</p>
<h3>构造调用绑定</h3>
<p>在 JavaScript 中，构造函数只是使用 <code>new</code> 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类，实际上，它们甚至都不能说是一种特殊的函数类型，它们只是被 <code>new</code> 操作符调用的普通函数而已。</p>
<p>举例来说，思考一下 <code>Number()</code> 作为构造函数时的行为，ES5.1 中这样描述它：</p>
<blockquote>
<p>15.7.2 Number 构造函数</p>
<p>当 Number 在 <code>new</code> 表达式中被调用时，它是一个构造函数：它会初始化新创建的对象。</p>
</blockquote>
<p>所以，包括内置对象函数在内的所有函数都可以用 <code>new</code> 来调用，这种函数调用被称为 <strong>构造函数调用</strong>。这里有一个重要但是非常细微的区别：实际上并不存在所谓的构造函数，只是对于函数的 <strong>构造调用</strong>。</p>
<p>🎉 使用 <code>new</code> 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</p>
<ol>
<li>创建全新的空对象</li>
<li>将新对象的隐式原型对象关联构造函数的显式原型对象</li>
<li>执行对象类的构造函数，同时该实例的属性和方法被 <code>this</code> 所引用，即 <code>this</code> 指向新构造的实例</li>
<li>如果构造函数执行后没有返回其他对象，那么 <code>new</code> 表达式中的函数调用会自动返回这个新对象</li>
</ol>
<p>🎯 <strong>模拟过程：</strong></p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">objectFactory</span>(<span class="hljs-params">constructor, ...rest</span>) {
  <span class="hljs-comment">// 创建空对象，空对象关联构造函数的原型对象</span>
  <span class="hljs-keyword">const</span> instance = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);

  <span class="hljs-comment">// 执行对象类的构造函数，同时该实例的属性和方法被 this 所引用，即 this 指向新构造的实例</span>
  <span class="hljs-keyword">const</span> result = constructor.<span class="hljs-title function_">apply</span>(instance, rest);

  <span class="hljs-comment">// 判断构造函数的运行结果是否对象类型</span>
  <span class="hljs-keyword">if</span> (result !== <span class="hljs-literal">null</span> &amp;&amp; <span class="hljs-regexp">/^(object|function)$/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-keyword">typeof</span> result)) {
    <span class="hljs-keyword">return</span> result;
  }

  <span class="hljs-keyword">return</span> instance;
}
</code></pre>
<p>解剖内部操作后，我们能得出结论 <code>new</code> 操作符是为了实现该过程的一种<strong>语法糖</strong>。</p>
<h2>优先级</h2>
<p>上文介绍了函数调用中 <code>this</code> 绑定的四条规则，你需要做的就是找到函数的调用位置并判断应用哪条规则。但是，如果某个调用位置应用多条规则，则必须给这些规则设定优先级。</p>
<p>毫无疑问，默认绑定的优先级是四条规则中最低的，所以我们先不考虑它。</p>
<pre class="hljs"><code>显式绑定 &gt; 构造调用绑定 &gt; 隐式绑定;
</code></pre>
<h3>隐式绑定和显式绑定</h3>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);
}

<span class="hljs-keyword">const</span> container1 = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">foo</span>: foo,
};

<span class="hljs-keyword">const</span> container2 = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">foo</span>: foo,
};

container1.<span class="hljs-title function_">foo</span>();
<span class="hljs-comment">// 1</span>
container2.<span class="hljs-title function_">foo</span>();
<span class="hljs-comment">// 2</span>

container1.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>(container2);
<span class="hljs-comment">// 2</span>
container2.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>(container1);
<span class="hljs-comment">// 1</span>
</code></pre>
<p>可以看到，显式绑定优先级更高，也就是说在判断时应当先考虑是否可以存在显式绑定。</p>
<h3>构造调用绑定和隐式绑定</h3>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = something;
}

<span class="hljs-keyword">const</span> container1 = {
  <span class="hljs-attr">foo</span>: foo,
};

<span class="hljs-keyword">const</span> container2 = {};

container1.<span class="hljs-title function_">foo</span>(<span class="hljs-number">2</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(container1.<span class="hljs-property">a</span>);
<span class="hljs-comment">// 2</span>

container1.<span class="hljs-property">foo</span>.<span class="hljs-title function_">call</span>(container2, <span class="hljs-number">3</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(container2.<span class="hljs-property">a</span>);
<span class="hljs-comment">// 3</span>

<span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> container1.<span class="hljs-title function_">foo</span>(<span class="hljs-number">4</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(container1.<span class="hljs-property">a</span>);
<span class="hljs-comment">// 2</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(bar.<span class="hljs-property">a</span>);
<span class="hljs-comment">// 4</span>
</code></pre>
<p>可以看到 <code>new</code> 绑定比隐式绑定优先级高。但是 <code>new</code> 绑定和显式绑定谁的优先级更高呢？</p>
<p><code>new</code> 和 <code>call/apply</code> 无法一起使用，因此无法通过 <code>new foo.call(obj1)</code> 来直接进行测试。但是我们可以使用硬绑定来测试他俩的优先级。</p>
<p>在看代码之前先回忆一下硬绑定是如何工作的。<code>Function.prototype.bind</code> 会创建一个新的包装函数，这个函数会忽略它当前的 <code>this</code> 绑定（无论绑定的对象是什么），并把我们提供的对象绑定到 <code>this</code> 上。</p>
<p>这样看起来硬绑定（也是显式绑定的一种）似乎比 <code>new</code> 绑定的优先级更高，无法使用 <code>new</code> 来控制 <code>this</code> 绑定。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>) {
  <span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = something;
}

<span class="hljs-keyword">var</span> container1 = {};

<span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>(container1);
<span class="hljs-title function_">bar</span>(<span class="hljs-number">2</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(container1.<span class="hljs-property">a</span>);
<span class="hljs-comment">// 2</span>

<span class="hljs-keyword">var</span> baz = <span class="hljs-keyword">new</span> <span class="hljs-title function_">bar</span>(<span class="hljs-number">3</span>);
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(container1.<span class="hljs-property">a</span>);
<span class="hljs-comment">// 2</span>
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(baz.<span class="hljs-property">a</span>);
<span class="hljs-comment">// 3</span>
</code></pre>
<h2>绑定例外</h2>
<h3>忽略指向</h3>
<p>如果将 <code>null</code> 或 <code>undefined</code> 作为 <code>this</code> 的绑定对象传入 <code>call</code>、<code>apply</code> 或 <code>bind</code>，这些值在调用时会被忽略，实际应用的是默认绑定规则。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);
}

<span class="hljs-keyword">const</span> a = <span class="hljs-number">2</span>;

foo.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>);
<span class="hljs-comment">// 2</span>
</code></pre>
<p>此类写法常用于 <code>apply</code> 来展开数组，并当作参数传入一个函数，类似地，<code>bind</code> 可以对参数进行柯里化（预先设置一些参数）。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">a, b</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a:&#x27;</span> + a + <span class="hljs-string">&#x27;,b:&#x27;</span> + b);
}

<span class="hljs-comment">// 把数组展开成参数</span>
foo.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);
<span class="hljs-comment">// a:2, b:3</span>

<span class="hljs-comment">// 使用 bind 进行柯里化</span>
<span class="hljs-keyword">var</span> bar = foo.<span class="hljs-title function_">bind</span>(<span class="hljs-literal">null</span>, <span class="hljs-number">2</span>);
<span class="hljs-title function_">bar</span>(<span class="hljs-number">3</span>);
<span class="hljs-comment">// a:2, b:3</span>
</code></pre>
<p>这两种方法都需要传入一个参数当作 <code>this</code> 的绑定对象。如果函数并不关心 <code>this</code> 的话，你
仍然需要传入一个占位值，这时 <code>null</code> 可能是一个不错的选择。</p>
<h3>软绑定</h3>
<p>硬绑定这种方式可以把 <code>this</code> 强制绑定到指定的对象（除了使用 <code>new</code> 时），防止函数调用应用默认绑定规则。问题在于，硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 <code>this</code>。</p>
<p>如果可以给默认绑定指定一个全局对象和 <code>undefined</code> 以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改 <code>this</code> 的能力。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">if</span> (!<span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">softBind</span>) { <span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">softBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) {
<span class="hljs-keyword">var</span> fn = <span class="hljs-variable language_">this</span>;
<span class="hljs-comment">// 捕获所有 curried 参数</span>
<span class="hljs-keyword">var</span> curried = [].<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>( <span class="hljs-variable language_">arguments</span>, <span class="hljs-number">1</span> ); <span class="hljs-keyword">var</span> bound = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) {
<span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(
(!<span class="hljs-variable language_">this</span> || <span class="hljs-variable language_">this</span> === (<span class="hljs-variable language_">window</span> || <span class="hljs-variable language_">global</span>)) ?
obj : <span class="hljs-variable language_">this</span>
curried.<span class="hljs-property">concat</span>.<span class="hljs-title function_">apply</span>( curried, <span class="hljs-variable language_">arguments</span> )
); };
             bound.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>( fn.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> );
<span class="hljs-keyword">return</span> bound; };
}
</code></pre>
<h3>指向变更</h3>
<p>如下列出四种方法可以在编码中改变 <code>this</code> 指向。</p>
<ul>
<li>使用 ES6 的箭头函数</li>
<li>在函数内部使用 <code>_this = this</code></li>
<li>使用 <code>apply</code>、<code>call</code> 和 <code>bind</code></li>
<li><code>new</code> 实例化一个对象</li>
</ul>
<h3>箭头函数</h3>
<p>箭头函数并不是使用 <code>function</code> 关键字定义的，而是使用被称为胖箭头的操作符 <code>=&gt;</code> 定义的。箭头函数不使用 <code>this</code> 的四种标准规则，而是根据外层（函数或者全局）作用域来决定 <code>this</code> 的指向。并且，箭头函数拥有静态的上下文，即一次绑定之后，便不可再修改。</p>
<p><code>this</code> 指向的固定化，并不是因为箭头函数内部有绑定 <code>this</code> 的机制，实际原因是箭头函数根本没有自己的 <code>this</code>，导致内部的 <code>this</code> 就是外层代码块的 <code>this</code>。正是因为它没有 <code>this</code>，所以也就不能用作构造函数。</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-comment">// 返回一个箭头函数</span>
  <span class="hljs-keyword">return</span> <span class="hljs-function">(<span class="hljs-params">a</span>) =&gt;</span> {
    <span class="hljs-comment">// this 继承自 foo()</span>
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span>);
  };
}
<span class="hljs-keyword">const</span> container1 = { <span class="hljs-attr">a</span>: <span class="hljs-number">1</span> };

<span class="hljs-keyword">const</span> container2 = { <span class="hljs-attr">a</span>: <span class="hljs-number">2</span> };

<span class="hljs-keyword">const</span> bar = foo.<span class="hljs-title function_">call</span>(container1);

bar.<span class="hljs-title function_">call</span>(container2);
<span class="hljs-comment">// 1</span>
</code></pre>
<p><code>foo</code> 内部创建的箭头函数会捕获调用时 <code>foo</code> 的 <code>this</code>。由于 <code>foo</code> 的 <code>this</code> 绑定到 <code>container1</code>，<code>bar</code>（引用箭头函数）的 <code>this</code> 也会绑定到 <code>container1</code>，箭头函数的绑定无法被修改。</p>
<p>箭头函数可以像 <code>bind</code> 一样确保函数的 <code>this</code> 被绑定到指定对象，此外，其重要性还体现在它用更常见的词法作用域取代了传统的 <code>this</code> 机制。实际上，在 ES6 之前我们就已经在使用一种几乎和箭头函数完全一样的模式。</p>
<p>虽然 <code>const self = this</code> 和箭头函数看起来都可以取代 <code>bind</code>，但是从本质上来说，它们想替代的是 <code>this</code> 机制。</p>
<p>如果你经常编写 <code>this</code> 风格的代码，但是绝大部分时候都会使用 <code>const self = this</code> 或者箭头函数来否定 <code>this</code> 机制，那你或许应当:</p>
<ul>
<li>只使用词法作用域并完全抛弃错误 <code>this</code> 风格的代码</li>
<li>完全采用 <code>this</code> 风格，在必要时使用 <code>bind</code>，尽量避免使用 <code>const self = this</code> 和箭头函数</li>
</ul>
<h2>应用场景总结</h2>
<ol>
<li>函数的普通调用</li>
<li>函数作为对象方法调用</li>
<li>函数作为构造函数调用</li>
<li>函数通过 <code>call</code>、<code>apply</code>、<code>bind</code> 间接调用</li>
<li>箭头函数的调用</li>
</ol>
<h2>参考资料</h2>
<ul>
<li><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/README" target="_blank" rel="noopener noreferrer nofollow">📚 你不知道的 JavaScript（上卷）</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/23804247" target="_blank" rel="noopener noreferrer nofollow">📝 this 的值到底是什么？一次说清楚</a></li>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/7" target="_blank" rel="noopener noreferrer nofollow">📝 JavaScript 深入之从 ECMAScript 规范解读 this</a></li>
<li><a href="https://github.com/logan70/Blog/issues/27" target="_blank" rel="noopener noreferrer nofollow">作用域与闭包 - this 的原理以及几种不同使用场景的取值</a></li>
</ul>
</article></div></main><script src="/_next/static/chunks/webpack-78112f590b744806.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5244,[],\"\"]\n3:I[3866,[],\"\"]\n5:I[6213,[],\"OutletBoundary\"]\n7:I[6213,[],\"MetadataBoundary\"]\n9:I[6213,[],\"ViewportBoundary\"]\nb:I[4835,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/d498c84e4ab246b3.css\",\"style\"]\n:HL[\"/_next/static/css/485ff6fe79292a08.css\",\"style\"]\n:HL[\"/_next/static/css/b9d97b2190475167.css\",\"style\"]\n:HL[\"/_next/static/css/851cdee6d90716dd.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"NFjmtHF2up8B2PpbDjLiS\",\"p\":\"\",\"c\":[\"\",\"front-end\",\"core-modules\",\"executable-code-and-execution-contexts\",\"execution\",\"this\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"front-end\",{\"children\":[[\"slug\",\"core-modules/executable-code-and-execution-contexts/execution/this\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d498c84e4ab246b3.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/485ff6fe79292a08.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/b9d97b2190475167.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"front-end\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/851cdee6d90716dd.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"main\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[[\"slug\",\"core-modules/executable-code-and-execution-contexts/execution/this\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"front-end\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"ohUYV9igzRbfqgyTlNPr5\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:T8e41,"])</script><script>self.__next_f.push([1,"\u003ch1\u003e当前执行上下文 this\u003c/h1\u003e\n\u003cp\u003e业界没有 \u003cstrong\u003e当前执行上下文\u003c/strong\u003e 的叫法，但是笔者私自把 \u003ccode\u003ethis\u003c/code\u003e 的指向理解为执行时所指向的执行上下文。\u003c/p\u003e\n\u003ch2\u003e调用位置\u003c/h2\u003e\n\u003cp\u003e在理解 \u003ccode\u003ethis\u003c/code\u003e 的绑定过程之前，首先要理解 \u003ccode\u003ethis\u003c/code\u003e 的\u003cstrong\u003e调用位置\u003c/strong\u003e：调用位置就是函数在代码中被调用的位置（而不是声明的位置）。\u003c/p\u003e\n\u003cp\u003e而要理解 \u003ccode\u003ethis\u003c/code\u003e 的调用位置，最重要的是要 \u003cstrong\u003e分析调用栈\u003c/strong\u003e（就是为了到达当前执行位置所调用的所有函数）。我们关心的调用位置就在当前正在执行的函数的前一个调用中。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebaz\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 当前调用栈是：baz\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 因此，当前调用位置是全局作用域\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;baz\u0026#x27;\u003c/span\u003e);\n  \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// \u0026lt;-- bar 的调用的位置\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 当前调用栈是 baz -\u0026gt; bar\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 因此，当前调用调用位置在 baz 中\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;bar\u0026#x27;\u003c/span\u003e);\n  \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// \u0026lt;-- foo 的调用位置\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 当前调用栈是 baz -\u0026gt; bar -\u0026gt; foo\u003c/span\u003e\n  \u003cspan class=\"hljs-comment\"\u003e// 因此，当前调用位置在 bar 中\u003c/span\u003e\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;foo\u0026#x27;\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-title function_\"\u003ebaz\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// \u0026lt;-- baz 的调用位置\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e注意我们是如何从调用栈中分析出真正的调用位置，因为它决定了 \u003ccode\u003ethis\u003c/code\u003e 的绑定。\u003c/p\u003e\n\u003ch2\u003e绑定规则\u003c/h2\u003e\n\u003cp\u003e函数的执行过程中调用位置决定 \u003ccode\u003ethis\u003c/code\u003e 的 \u003cstrong\u003e绑定对象\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e你必须找到调用位置，然后判断需要应用下面四条规则中的哪一条。我们首先会分别解释这四条规则，然后解释多条规则都可用时它们的优先级如何排列。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e(调用栈) =\u0026gt; \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e调用位置\u003c/span\u003e) =\u0026gt;\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003e绑定规则\u003c/span\u003e) =\u0026gt;\u003c/span\u003e 规则优先级;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e默认绑定\u003c/h3\u003e\n\u003cp\u003e首先要介绍的是最常用的函数调用类型：\u003cstrong\u003e独立函数调用\u003c/strong\u003e。可以把这条规则看作是无法应用其他规则时的默认规则。\u003c/p\u003e\n\u003cp\u003e🌰 \u003cstrong\u003e代码示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 声明在全局作用域中的变量就是全局对象的一个同名属性\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 相当于 window.a = 2\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e a = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// 调用 foo 函数时 this.a 被解析成了全局变量 a\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 因为在本例中，函数调用时应用了 this 的默认绑定\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 因此 this 指向全局对象 global objects 或 window objects\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// 分析调用位置来获知 foo 是如何调用的\u003c/span\u003e\n\u003cspan class=\"hljs-comment\"\u003e// foo 函数直接使用不带任何修饰的函数引用进行调用，因此只能使用默认绑定，无法应用其他规则\u003c/span\u003e\n\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e如果使用严格模式（Strict Mode），则不能将全局对象用于默认绑定，因此 \u003ccode\u003ethis\u003c/code\u003e 会绑定到 \u003ccode\u003eundefined\u003c/code\u003e。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-string\"\u003e\u0026#x27;use strict\u0026#x27;\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e a = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n\n\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// TypeError:this is undefined\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这里有一个微妙但是非常重要的细节，虽然 \u003ccode\u003ethis\u003c/code\u003e 的绑定规则完全取决于调用位置，但是只有 \u003ccode\u003efoo()\u003c/code\u003e 运行在非严格模式下时，默认绑定才能绑定到全局对象；在严格模式下调用 \u003ccode\u003efoo\u003c/code\u003e 则不受默认绑定影响。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e a = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n\n(\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-string\"\u003e\u0026#x27;use strict\u0026#x27;\u003c/span\u003e;\n\n  \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n})();\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e⚠️ \u003cstrong\u003e注意\u003c/strong\u003e：通常来说你不应该在代码中混合使用严格模式和非严格模式。整个程序要么严格要么非严格。然而，有时候你可能会用到第三方库，其严格程度和你代码有所不同，因此一定要注意这类兼容性细节。\u003c/p\u003e\n\u003ch3\u003e隐式绑定\u003c/h3\u003e\n\u003cp\u003e另一条需要考虑的规则是调用位置是否有\u003cstrong\u003e上下文对象\u003c/strong\u003e，或者说是否\u003cstrong\u003e被某个对象拥有或者包含\u003c/strong\u003e，不过这种说法可能会造成一些误导。\u003c/p\u003e\n\u003cp\u003e🌰 \u003cstrong\u003e代码示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e container = {\n  \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003efoo\u003c/span\u003e: foo,\n};\n\ncontainer.\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e首先需要注意的是 \u003ccode\u003efoo\u003c/code\u003e 的声明方式，及其之后是如何被当作引用属性添加到 \u003ccode\u003econtainer\u003c/code\u003e 中的。但是无论是直接在 \u003ccode\u003econtainer\u003c/code\u003e 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于 \u003ccode\u003econtainer\u003c/code\u003e 对象。\u003c/p\u003e\n\u003cp\u003e然而，调用位置会使用 \u003ccode\u003econtainer\u003c/code\u003e 上下文来引用函数，因此你可以说函数被调用时 \u003ccode\u003econtainer\u003c/code\u003e 对象 \u003cstrong\u003e拥有\u003c/strong\u003e 或者 \u003cstrong\u003e包含\u003c/strong\u003e 它。\u003c/p\u003e\n\u003cp\u003e无论你如何称呼这个模式，当 \u003ccode\u003efoo\u003c/code\u003e 被调用时，它的前面确实加上了对 \u003ccode\u003econtainer\u003c/code\u003e 的引用。当函数引用有上下文时，隐式绑定规则会把函数调用中的 \u003ccode\u003ethis\u003c/code\u003e 绑定到这个上下文对象。因为调用 \u003ccode\u003efoo\u003c/code\u003e 时 \u003ccode\u003ethis\u003c/code\u003e 被绑定到 \u003ccode\u003econtainer\u003c/code\u003e 上，因此 \u003ccode\u003ethis.a\u003c/code\u003e 和 \u003ccode\u003econtainer.a\u003c/code\u003e 是一样的。\u003c/p\u003e\n\u003cp\u003e💡 \u003cstrong\u003e对象属性引用链中只有上一层或最后一层在调用位置中起作用。\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e obj2 = {\n  \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e42\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003efoo\u003c/span\u003e: foo,\n};\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e obj1 = {\n  \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003eobj2\u003c/span\u003e: obj2,\n};\n\nobj1.\u003cspan class=\"hljs-property\"\u003eobj2\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// 42\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e隐式丢失\u003c/h4\u003e\n\u003cp\u003e一个最常见的 \u003ccode\u003ethis\u003c/code\u003e 绑定问题就是\u003cstrong\u003e被隐式绑定的函数会丢失绑定对象\u003c/strong\u003e，也就是说它会应用默认绑定，从而把 \u003ccode\u003ethis\u003c/code\u003e 绑定到全局对象或者 \u003ccode\u003eundefined\u003c/code\u003e 上（这取决于是否是严格模式）。\u003c/p\u003e\n\u003cp\u003e🌰 \u003cstrong\u003e代码示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e container = {\n  \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003efoo\u003c/span\u003e: foo,\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// 函数别名\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e bar = container.\u003cspan class=\"hljs-property\"\u003efoo\u003c/span\u003e;\n\n\u003cspan class=\"hljs-comment\"\u003e// a 是全局对象的属性\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e a = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;Hello world!\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// \u0026quot;Hello world!\u0026quot;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e📍 虽然 \u003ccode\u003ebar\u003c/code\u003e 是 \u003ccode\u003econtainer.foo\u003c/code\u003e 的一个引用，但是实际上，它引用的是 \u003ccode\u003efoo\u003c/code\u003e 函数本身，因此此时的 \u003ccode\u003ebar\u003c/code\u003e 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。\u003c/p\u003e\n\u003cp\u003e一种更微妙、更常见并且更出乎意料的情况发生在传入回调函数时。\u003c/p\u003e\n\u003cp\u003e🌰 \u003cstrong\u003e代码示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003efn\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// fn 其实引用的是 foo\u003c/span\u003e\n  \u003cspan class=\"hljs-title function_\"\u003efn\u003c/span\u003e(); \u003cspan class=\"hljs-comment\"\u003e// \u0026lt;--调用位置\u003c/span\u003e\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e container = {\n  \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003efoo\u003c/span\u003e: foo,\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// a 是全局对象的属性\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e a = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;Hello world!\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(container.\u003cspan class=\"hljs-property\"\u003efoo\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// \u0026quot;Hello world!\u0026quot;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e参数传递其实是一种\u003cstrong\u003e隐式赋值\u003c/strong\u003e，因此我们传入函数时也会被隐式赋值，所以结果和上个示例一样。\u003c/p\u003e\n\u003cp\u003e如果把函数传入语言内置的函数而不是传入你自己声明的函数，结果是一样的，没有区别。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e container = {\n  \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003efoo\u003c/span\u003e: foo,\n};\n\n\u003cspan class=\"hljs-comment\"\u003e// a 是全局对象的属性\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e a = \u003cspan class=\"hljs-string\"\u003e\u0026#x27;Hello world!\u0026#x27;\u003c/span\u003e;\n\n\u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(container.\u003cspan class=\"hljs-property\"\u003efoo\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// \u0026#x27;Hello world!\u0026#x27;\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e回调函数丢失 \u003ccode\u003ethis\u003c/code\u003e 绑定是非常常见的。\u003c/p\u003e\n\u003cp\u003e除此之外，还有一种情况 \u003ccode\u003ethis\u003c/code\u003e 的行为会出乎我们意料：调用回调函数的函数可能会修改 \u003ccode\u003ethis\u003c/code\u003e。在一些流行的 JavaScript 库中事件处理器会把回调函数的 \u003ccode\u003ethis\u003c/code\u003e 强制绑定到触发事件的 DOM 元素上。这在一些情况下可能很有用，但是有时它可能会让你感到非常郁闷。遗憾的是，这些工具通常无法选择是否启用这个行为。\u003c/p\u003e\n\u003cp\u003e无论是哪种情况，\u003ccode\u003ethis\u003c/code\u003e 的改变都是意想不到的，实际上你无法控制回调函数的执行方式，因此就没有办法控制调用位置以得到期望的绑定。之后我们会介绍如何通过固定 \u003ccode\u003ethis\u003c/code\u003e 来修复这个问题。\u003c/p\u003e\n\u003ch3\u003e显式绑定\u003c/h3\u003e\n\u003cp\u003e就像我们刚才看到的那样，在分析隐式绑定时，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性间接引用函数，从而把 \u003ccode\u003ethis\u003c/code\u003e 隐式绑定到该对象上。\u003c/p\u003e\n\u003cp\u003eJavaScript 提供了 \u003ccode\u003eapply\u003c/code\u003e、\u003ccode\u003ecall\u003c/code\u003e 和 \u003ccode\u003ebind\u003c/code\u003e 方法，为创建的所有函数 \u003cstrong\u003e绑定宿主环境\u003c/strong\u003e。通过这些方法绑定函数的 \u003ccode\u003ethis\u003c/code\u003e 指向称为 \u003cstrong\u003e显式绑定\u003c/strong\u003e。\u003c/p\u003e\n\u003ch4\u003e硬绑定\u003c/h4\u003e\n\u003cp\u003e硬绑定可以解决之前提出的丢失绑定的问题。\u003c/p\u003e\n\u003cp\u003e🌰 \u003cstrong\u003e代码示例\u003c/strong\u003e：\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(ths.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e container = {\n  \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\n};\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e bar = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  foo.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(container);\n};\n\n\u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\n\u003cspan class=\"hljs-built_in\"\u003esetTimeout\u003c/span\u003e(bar, \u003cspan class=\"hljs-number\"\u003e100\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 硬绑定的 bar 不可能再修改它的 this\u003c/span\u003e\nbar.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e我们创建了函数 \u003ccode\u003ebar\u003c/code\u003e，并在它的内部手动调用了 \u003ccode\u003efoo.call(container)\u003c/code\u003e ，因此强制把 \u003ccode\u003efoo\u003c/code\u003e 的 \u003ccode\u003ethis\u003c/code\u003e 绑定到了 \u003ccode\u003econtainer\u003c/code\u003e 。无论之后如何调用函数 \u003ccode\u003ebar\u003c/code\u003e，它总会手动在 \u003ccode\u003econtainer\u003c/code\u003e 上调用 \u003ccode\u003efoo\u003c/code\u003e。这种绑定是一种显式（手动）的强制绑定，因此我们称之为\u003cstrong\u003e硬绑定\u003c/strong\u003e。\u003c/p\u003e\n\u003ch4\u003e内置函数\u003c/h4\u003e\n\u003cp\u003e第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一个可选的参数，通常被称为 \u003cstrong\u003e上下文（context）\u003c/strong\u003e，其作用和 \u003ccode\u003ebind\u003c/code\u003e 一样，确保你的回调函数使用指定的 \u003ccode\u003ethis\u003c/code\u003e 。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eitem\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003etitle\u003c/span\u003e, item);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e columns = {\n  \u003cspan class=\"hljs-attr\"\u003etitle\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;No:\u0026#x27;\u003c/span\u003e,\n}[\n  \u003cspan class=\"hljs-comment\"\u003e// 调用 foo 时把 this 绑定到 columns\u003c/span\u003e\n  (\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e)\n].\u003cspan class=\"hljs-title function_\"\u003eforEach\u003c/span\u003e(foo, columns);\n\u003cspan class=\"hljs-comment\"\u003e// No:1 No:2 No:3\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这些函数实际上就是通过 \u003ccode\u003ecall\u003c/code\u003e 或者 \u003ccode\u003eapply\u003c/code\u003e 实现了显式绑定，这样代码会更加优雅。\u003c/p\u003e\n\u003ch3\u003e构造调用绑定\u003c/h3\u003e\n\u003cp\u003e在 JavaScript 中，构造函数只是使用 \u003ccode\u003enew\u003c/code\u003e 操作符时被调用的函数。它们并不会属于某个类，也不会实例化一个类，实际上，它们甚至都不能说是一种特殊的函数类型，它们只是被 \u003ccode\u003enew\u003c/code\u003e 操作符调用的普通函数而已。\u003c/p\u003e\n\u003cp\u003e举例来说，思考一下 \u003ccode\u003eNumber()\u003c/code\u003e 作为构造函数时的行为，ES5.1 中这样描述它：\u003c/p\u003e\n\u003cblockquote\u003e\n\u003cp\u003e15.7.2 Number 构造函数\u003c/p\u003e\n\u003cp\u003e当 Number 在 \u003ccode\u003enew\u003c/code\u003e 表达式中被调用时，它是一个构造函数：它会初始化新创建的对象。\u003c/p\u003e\n\u003c/blockquote\u003e\n\u003cp\u003e所以，包括内置对象函数在内的所有函数都可以用 \u003ccode\u003enew\u003c/code\u003e 来调用，这种函数调用被称为 \u003cstrong\u003e构造函数调用\u003c/strong\u003e。这里有一个重要但是非常细微的区别：实际上并不存在所谓的构造函数，只是对于函数的 \u003cstrong\u003e构造调用\u003c/strong\u003e。\u003c/p\u003e\n\u003cp\u003e🎉 使用 \u003ccode\u003enew\u003c/code\u003e 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e创建全新的空对象\u003c/li\u003e\n\u003cli\u003e将新对象的隐式原型对象关联构造函数的显式原型对象\u003c/li\u003e\n\u003cli\u003e执行对象类的构造函数，同时该实例的属性和方法被 \u003ccode\u003ethis\u003c/code\u003e 所引用，即 \u003ccode\u003ethis\u003c/code\u003e 指向新构造的实例\u003c/li\u003e\n\u003cli\u003e如果构造函数执行后没有返回其他对象，那么 \u003ccode\u003enew\u003c/code\u003e 表达式中的函数调用会自动返回这个新对象\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e🎯 \u003cstrong\u003e模拟过程：\u003c/strong\u003e\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003eobjectFactory\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003econstructor, ...rest\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 创建空对象，空对象关联构造函数的原型对象\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e instance = \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e(constructor.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 执行对象类的构造函数，同时该实例的属性和方法被 this 所引用，即 this 指向新构造的实例\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e result = constructor.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(instance, rest);\n\n  \u003cspan class=\"hljs-comment\"\u003e// 判断构造函数的运行结果是否对象类型\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (result !== \u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e \u0026amp;\u0026amp; \u003cspan class=\"hljs-regexp\"\u003e/^(object|function)$/\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003etest\u003c/span\u003e(\u003cspan class=\"hljs-keyword\"\u003etypeof\u003c/span\u003e result)) {\n    \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e result;\n  }\n\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e instance;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e解剖内部操作后，我们能得出结论 \u003ccode\u003enew\u003c/code\u003e 操作符是为了实现该过程的一种\u003cstrong\u003e语法糖\u003c/strong\u003e。\u003c/p\u003e\n\u003ch2\u003e优先级\u003c/h2\u003e\n\u003cp\u003e上文介绍了函数调用中 \u003ccode\u003ethis\u003c/code\u003e 绑定的四条规则，你需要做的就是找到函数的调用位置并判断应用哪条规则。但是，如果某个调用位置应用多条规则，则必须给这些规则设定优先级。\u003c/p\u003e\n\u003cp\u003e毫无疑问，默认绑定的优先级是四条规则中最低的，所以我们先不考虑它。\u003c/p\u003e\n\u003cpre class=\"hljs\"\u003e\u003ccode\u003e显式绑定 \u0026gt; 构造调用绑定 \u0026gt; 隐式绑定;\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e隐式绑定和显式绑定\u003c/h3\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e container1 = {\n  \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003efoo\u003c/span\u003e: foo,\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e container2 = {\n  \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e,\n  \u003cspan class=\"hljs-attr\"\u003efoo\u003c/span\u003e: foo,\n};\n\ncontainer1.\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\ncontainer2.\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e();\n\u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\ncontainer1.\u003cspan class=\"hljs-property\"\u003efoo\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(container2);\n\u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\ncontainer2.\u003cspan class=\"hljs-property\"\u003efoo\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(container1);\n\u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到，显式绑定优先级更高，也就是说在判断时应当先考虑是否可以存在显式绑定。\u003c/p\u003e\n\u003ch3\u003e构造调用绑定和隐式绑定\u003c/h3\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003esomething\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e = something;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e container1 = {\n  \u003cspan class=\"hljs-attr\"\u003efoo\u003c/span\u003e: foo,\n};\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e container2 = {};\n\ncontainer1.\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(container1.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\ncontainer1.\u003cspan class=\"hljs-property\"\u003efoo\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(container2, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(container2.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 3\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e bar = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e container1.\u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e4\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(container1.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(bar.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 4\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e可以看到 \u003ccode\u003enew\u003c/code\u003e 绑定比隐式绑定优先级高。但是 \u003ccode\u003enew\u003c/code\u003e 绑定和显式绑定谁的优先级更高呢？\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003enew\u003c/code\u003e 和 \u003ccode\u003ecall/apply\u003c/code\u003e 无法一起使用，因此无法通过 \u003ccode\u003enew foo.call(obj1)\u003c/code\u003e 来直接进行测试。但是我们可以使用硬绑定来测试他俩的优先级。\u003c/p\u003e\n\u003cp\u003e在看代码之前先回忆一下硬绑定是如何工作的。\u003ccode\u003eFunction.prototype.bind\u003c/code\u003e 会创建一个新的包装函数，这个函数会忽略它当前的 \u003ccode\u003ethis\u003c/code\u003e 绑定（无论绑定的对象是什么），并把我们提供的对象绑定到 \u003ccode\u003ethis\u003c/code\u003e 上。\u003c/p\u003e\n\u003cp\u003e这样看起来硬绑定（也是显式绑定的一种）似乎比 \u003ccode\u003enew\u003c/code\u003e 绑定的优先级更高，无法使用 \u003ccode\u003enew\u003c/code\u003e 来控制 \u003ccode\u003ethis\u003c/code\u003e 绑定。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003esomething\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e = something;\n}\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e container1 = {};\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e bar = foo.\u003cspan class=\"hljs-title function_\"\u003ebind\u003c/span\u003e(container1);\n\u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(container1.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e baz = \u003cspan class=\"hljs-keyword\"\u003enew\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(container1.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(baz.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 3\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch2\u003e绑定例外\u003c/h2\u003e\n\u003ch3\u003e忽略指向\u003c/h3\u003e\n\u003cp\u003e如果将 \u003ccode\u003enull\u003c/code\u003e 或 \u003ccode\u003eundefined\u003c/code\u003e 作为 \u003ccode\u003ethis\u003c/code\u003e 的绑定对象传入 \u003ccode\u003ecall\u003c/code\u003e、\u003ccode\u003eapply\u003c/code\u003e 或 \u003ccode\u003ebind\u003c/code\u003e，这些值在调用时会被忽略，实际应用的是默认绑定规则。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e);\n}\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e a = \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e;\n\nfoo.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// 2\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e此类写法常用于 \u003ccode\u003eapply\u003c/code\u003e 来展开数组，并当作参数传入一个函数，类似地，\u003ccode\u003ebind\u003c/code\u003e 可以对参数进行柯里化（预先设置一些参数）。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ea, b\u003c/span\u003e) {\n  \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;a:\u0026#x27;\u003c/span\u003e + a + \u003cspan class=\"hljs-string\"\u003e\u0026#x27;,b:\u0026#x27;\u003c/span\u003e + b);\n}\n\n\u003cspan class=\"hljs-comment\"\u003e// 把数组展开成参数\u003c/span\u003e\nfoo.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, [\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e]);\n\u003cspan class=\"hljs-comment\"\u003e// a:2, b:3\u003c/span\u003e\n\n\u003cspan class=\"hljs-comment\"\u003e// 使用 bind 进行柯里化\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e bar = foo.\u003cspan class=\"hljs-title function_\"\u003ebind\u003c/span\u003e(\u003cspan class=\"hljs-literal\"\u003enull\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e);\n\u003cspan class=\"hljs-title function_\"\u003ebar\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3\u003c/span\u003e);\n\u003cspan class=\"hljs-comment\"\u003e// a:2, b:3\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e这两种方法都需要传入一个参数当作 \u003ccode\u003ethis\u003c/code\u003e 的绑定对象。如果函数并不关心 \u003ccode\u003ethis\u003c/code\u003e 的话，你\n仍然需要传入一个占位值，这时 \u003ccode\u003enull\u003c/code\u003e 可能是一个不错的选择。\u003c/p\u003e\n\u003ch3\u003e软绑定\u003c/h3\u003e\n\u003cp\u003e硬绑定这种方式可以把 \u003ccode\u003ethis\u003c/code\u003e 强制绑定到指定的对象（除了使用 \u003ccode\u003enew\u003c/code\u003e 时），防止函数调用应用默认绑定规则。问题在于，硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 \u003ccode\u003ethis\u003c/code\u003e。\u003c/p\u003e\n\u003cp\u003e如果可以给默认绑定指定一个全局对象和 \u003ccode\u003eundefined\u003c/code\u003e 以外的值，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改 \u003ccode\u003ethis\u003c/code\u003e 的能力。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003eif\u003c/span\u003e (!\u003cspan class=\"hljs-title class_\"\u003eFunction\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esoftBind\u003c/span\u003e) { \u003cspan class=\"hljs-title class_\"\u003eFunction\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003esoftBind\u003c/span\u003e = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003eobj\u003c/span\u003e) {\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e fn = \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e;\n\u003cspan class=\"hljs-comment\"\u003e// 捕获所有 curried 参数\u003c/span\u003e\n\u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e curried = [].\u003cspan class=\"hljs-property\"\u003eslice\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e( \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e, \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e ); \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e bound = \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e fn.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e(\n(!\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e || \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e === (\u003cspan class=\"hljs-variable language_\"\u003ewindow\u003c/span\u003e || \u003cspan class=\"hljs-variable language_\"\u003eglobal\u003c/span\u003e)) ?\nobj : \u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e\ncurried.\u003cspan class=\"hljs-property\"\u003econcat\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003eapply\u003c/span\u003e( curried, \u003cspan class=\"hljs-variable language_\"\u003earguments\u003c/span\u003e )\n); };\n             bound.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e = \u003cspan class=\"hljs-title class_\"\u003eObject\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreate\u003c/span\u003e( fn.\u003cspan class=\"hljs-property\"\u003e\u003cspan class=\"hljs-keyword\"\u003eprototype\u003c/span\u003e\u003c/span\u003e );\n\u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e bound; };\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch3\u003e指向变更\u003c/h3\u003e\n\u003cp\u003e如下列出四种方法可以在编码中改变 \u003ccode\u003ethis\u003c/code\u003e 指向。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e使用 ES6 的箭头函数\u003c/li\u003e\n\u003cli\u003e在函数内部使用 \u003ccode\u003e_this = this\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e使用 \u003ccode\u003eapply\u003c/code\u003e、\u003ccode\u003ecall\u003c/code\u003e 和 \u003ccode\u003ebind\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003enew\u003c/code\u003e 实例化一个对象\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch3\u003e箭头函数\u003c/h3\u003e\n\u003cp\u003e箭头函数并不是使用 \u003ccode\u003efunction\u003c/code\u003e 关键字定义的，而是使用被称为胖箭头的操作符 \u003ccode\u003e=\u0026gt;\u003c/code\u003e 定义的。箭头函数不使用 \u003ccode\u003ethis\u003c/code\u003e 的四种标准规则，而是根据外层（函数或者全局）作用域来决定 \u003ccode\u003ethis\u003c/code\u003e 的指向。并且，箭头函数拥有静态的上下文，即一次绑定之后，便不可再修改。\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ethis\u003c/code\u003e 指向的固定化，并不是因为箭头函数内部有绑定 \u003ccode\u003ethis\u003c/code\u003e 的机制，实际原因是箭头函数根本没有自己的 \u003ccode\u003ethis\u003c/code\u003e，导致内部的 \u003ccode\u003ethis\u003c/code\u003e 就是外层代码块的 \u003ccode\u003ethis\u003c/code\u003e。正是因为它没有 \u003ccode\u003ethis\u003c/code\u003e，所以也就不能用作构造函数。\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003efoo\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n  \u003cspan class=\"hljs-comment\"\u003e// 返回一个箭头函数\u003c/span\u003e\n  \u003cspan class=\"hljs-keyword\"\u003ereturn\u003c/span\u003e \u003cspan class=\"hljs-function\"\u003e(\u003cspan class=\"hljs-params\"\u003ea\u003c/span\u003e) =\u0026gt;\u003c/span\u003e {\n    \u003cspan class=\"hljs-comment\"\u003e// this 继承自 foo()\u003c/span\u003e\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(\u003cspan class=\"hljs-variable language_\"\u003ethis\u003c/span\u003e.\u003cspan class=\"hljs-property\"\u003ea\u003c/span\u003e);\n  };\n}\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e container1 = { \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e };\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e container2 = { \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e: \u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e };\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e bar = foo.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(container1);\n\nbar.\u003cspan class=\"hljs-title function_\"\u003ecall\u003c/span\u003e(container2);\n\u003cspan class=\"hljs-comment\"\u003e// 1\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003efoo\u003c/code\u003e 内部创建的箭头函数会捕获调用时 \u003ccode\u003efoo\u003c/code\u003e 的 \u003ccode\u003ethis\u003c/code\u003e。由于 \u003ccode\u003efoo\u003c/code\u003e 的 \u003ccode\u003ethis\u003c/code\u003e 绑定到 \u003ccode\u003econtainer1\u003c/code\u003e，\u003ccode\u003ebar\u003c/code\u003e（引用箭头函数）的 \u003ccode\u003ethis\u003c/code\u003e 也会绑定到 \u003ccode\u003econtainer1\u003c/code\u003e，箭头函数的绑定无法被修改。\u003c/p\u003e\n\u003cp\u003e箭头函数可以像 \u003ccode\u003ebind\u003c/code\u003e 一样确保函数的 \u003ccode\u003ethis\u003c/code\u003e 被绑定到指定对象，此外，其重要性还体现在它用更常见的词法作用域取代了传统的 \u003ccode\u003ethis\u003c/code\u003e 机制。实际上，在 ES6 之前我们就已经在使用一种几乎和箭头函数完全一样的模式。\u003c/p\u003e\n\u003cp\u003e虽然 \u003ccode\u003econst self = this\u003c/code\u003e 和箭头函数看起来都可以取代 \u003ccode\u003ebind\u003c/code\u003e，但是从本质上来说，它们想替代的是 \u003ccode\u003ethis\u003c/code\u003e 机制。\u003c/p\u003e\n\u003cp\u003e如果你经常编写 \u003ccode\u003ethis\u003c/code\u003e 风格的代码，但是绝大部分时候都会使用 \u003ccode\u003econst self = this\u003c/code\u003e 或者箭头函数来否定 \u003ccode\u003ethis\u003c/code\u003e 机制，那你或许应当:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e只使用词法作用域并完全抛弃错误 \u003ccode\u003ethis\u003c/code\u003e 风格的代码\u003c/li\u003e\n\u003cli\u003e完全采用 \u003ccode\u003ethis\u003c/code\u003e 风格，在必要时使用 \u003ccode\u003ebind\u003c/code\u003e，尽量避免使用 \u003ccode\u003econst self = this\u003c/code\u003e 和箭头函数\u003c/li\u003e\n\u003c/ul\u003e\n\u003ch2\u003e应用场景总结\u003c/h2\u003e\n\u003col\u003e\n\u003cli\u003e函数的普通调用\u003c/li\u003e\n\u003cli\u003e函数作为对象方法调用\u003c/li\u003e\n\u003cli\u003e函数作为构造函数调用\u003c/li\u003e\n\u003cli\u003e函数通过 \u003ccode\u003ecall\u003c/code\u003e、\u003ccode\u003eapply\u003c/code\u003e、\u003ccode\u003ebind\u003c/code\u003e 间接调用\u003c/li\u003e\n\u003cli\u003e箭头函数的调用\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2\u003e参考资料\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/this%20%26%20object%20prototypes/README\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📚 你不知道的 JavaScript（上卷）\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://zhuanlan.zhihu.com/p/23804247\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 this 的值到底是什么？一次说清楚\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/mqyqingfeng/Blog/issues/7\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e📝 JavaScript 深入之从 ECMAScript 规范解读 this\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/logan70/Blog/issues/27\" target=\"_blank\" rel=\"noopener noreferrer nofollow\"\u003e作用域与闭包 - this 的原理以及几种不同使用场景的取值\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"markdown-body\",\"children\":[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"front-end\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"front-end knowledge\"}],[\"$\",\"link\",\"3\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>