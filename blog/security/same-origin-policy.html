<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/569ce4b8f30dc480-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/93f479601ee12b01-s.p.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/css/d498c84e4ab246b3.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/485ff6fe79292a08.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/bcf94c9592804980.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/css/0ff121a467c0636f.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/webpack-9bda2a94a940c3a3.js"/><script src="/_next/static/chunks/4bd1b696-0227e3df1a7e0387.js" async=""></script><script src="/_next/static/chunks/517-3d6a37207f70deb4.js" async=""></script><script src="/_next/static/chunks/main-app-f33d3e3aed85e21f.js" async=""></script><meta name="next-size-adjust" content=""/><title>blog | adog</title><meta name="description" content="some  my blog"/><meta name="keywords" content="前端,react,web3,区块链,数字货币,加密货币"/><link rel="icon" href="/favicon.ico" type="image/x-icon" sizes="16x16"/><script src="/_next/static/chunks/polyfills-42372ed130431b0a.js" noModule=""></script></head><body class="__variable_4d318d __variable_ea5f4b antialiased"><main><div class="markdown-body"><h1>同源策略</h1><article><h2>3.2 同源策略</h2>
<h3>3.2.1 定义</h3>
<ul>
<li>禁止一个源（origin）的脚本&amp;文档和另一个源的脚本&amp;文档交互
<ul>
<li>两个URL的protocol，port和host相同，那么同源</li>
<li>思考：如果两个源产生过多交换有什么问题？</li>
</ul>
</li>
</ul>
<p><img src="/blog/imgs/someorigin.png" alt=""></p>
<p>思考：</p>
<ul>
<li>为什么不禁用不同源的js？</li>
</ul>
<p>因为有时候需要把js放到cdn上，那么可能就不同源了，所以行不通。</p>
<ul>
<li>应不应该允许不同源的js修改dom？</li>
</ul>
<p>允许</p>
<ul>
<li>应不应该允许网站提交数据到不同源的的服务器？</li>
</ul>
<p>不允许</p>
<ul>
<li>应不应该允许网站提交cookie到不同源的服务器？</li>
</ul>
<p>不允许</p>
<h3>3.2.2 跨域的N种方法</h3>
<h4>1.JSONP</h4>
<ul>
<li>利用不限制跨越脚本执行的特点</li>
</ul>
<pre class="hljs language-js"  style=--lang:"js" ><code> <span class="hljs-comment">// 服务端数据（data.js）</span>
 <span class="hljs-title function_">jsonp</span>(<span class="hljs-string">&quot;example&quot;</span>,{
    <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,
    <span class="hljs-attr">b</span>:<span class="hljs-number">2</span>
 })

 <span class="hljs-comment">// index.html</span>
 <span class="hljs-keyword">function</span> <span class="hljs-title function_">jsonp</span> (<span class="hljs-params"></span>) {
    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(topic,data)
 }
 <span class="hljs-comment">// 加载跨域数据脚本</span>
 <span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>)
 script.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&#x27;src&#x27;</span>,<span class="hljs-string">&#x27;data.js&#x27;</span>)
 <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementdByTagName</span>(<span class="hljs-string">&#x27;head&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-title function_">appendChild</span>(script)
</code></pre>
<p>思考</p>
<ul>
<li>jsonp可以用来提交数据吗？</li>
</ul>
<p>可以在url上，但只能get请求；服务端可以通过判断返回不同的脚本</p>
<ul>
<li>尝试为fetch函数扩展jsonp功能</li>
</ul>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-title function_">fetch</span>(&lt;jsonp-url&gt;,{<span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;jsonp&#x27;</span>})
      .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>{
         <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data)
      })
</code></pre>
<h4>2. 跨域资源共用 &lt;Badge text=&quot;重要&quot; type=&quot;tip&quot;/&gt;</h4>
<ul>
<li>跨域资源共用（Cross-Origin Resource Sharing）使用额外HTTP头允许指定的源和另一个源进行交互
服务端设置 Access-control-Allow-Origin:https://a.com</li>
</ul>
<p><img src="/blog/imgs/corss.png" alt=""></p>
<p>get、post我们称之为简单请求，简单请求在同源策略中会简单的处理,如果b.com返回了这个头<code>Access-control-Allow-Origin:https://a.com</code>，那么我们认为
这个请求是可以通过的。</p>
<p>预检</p>
<p>但是还有复杂一点的请求，我们需要先发OPTIONS请求，a.com想请求b.com它需要发一个自定义的Headers：X-ABC和content-type，这个时候就不是简单请求了，
a.com要给b.com 发一个options请求，它其实在问b.com我用post行不行，还想在Headers中带X-ABC和content-type；并不是所有的headers都发这个OPTIONS请求，因为X-ABC是自定义的，所以需要发；b.com看到OPTIONS请求，先不会返回数据，先检查自己的策略，看看能不能支持这次请求，如果支持就返回200。</p>
<p>OPTIONS请求返回以下报文</p>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-variable constant_">HTTP</span>/<span class="hljs-number">2.0</span> <span class="hljs-number">20</span> <span class="hljs-variable constant_">OK</span>
<span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Origin</span>:<span class="hljs-attr">https</span>:<span class="hljs-comment">//a.com</span>
<span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Methods</span>:<span class="hljs-variable constant_">POST</span>,<span class="hljs-variable constant_">GET</span>,<span class="hljs-variable constant_">OPTIONS</span>
<span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Allow</span>-<span class="hljs-title class_">Headers</span>:X-<span class="hljs-variable constant_">ABC</span>,<span class="hljs-title class_">Content</span>-<span class="hljs-title class_">Type</span>
     <span class="hljs-title class_">Access</span>-<span class="hljs-title class_">Control</span>-<span class="hljs-title class_">Max</span>-<span class="hljs-title class_">Age</span>:<span class="hljs-number">86400</span> <span class="hljs-comment">// 告诉浏览器这个策略生效时间为一个小时，在一个小时之内发送类似的请求，不用在问服务端了，相当于缓存了</span>
</code></pre>
<p>浏览器收到了OPTIONS的返回，会在发一次，这一次才是真正的请求数据，这次headers会带上X-ABC、contentType。</p>
<p>整体的过程cors将请求分为2种，简单请求和复杂请求，需不需要发送OPTIONS浏览器说的算，浏览器判断是简单请求还是复杂请求，cors是非常广泛的跨域手段
这里的缺点是OPTIONS请求也是一次请求，消耗带宽，真正的请求也会延迟。</p>
<h4>3.反向代理 &lt;Badge text=&quot;重要&quot; type=&quot;tip&quot;/&gt;</h4>
<p><img src="/blog/imgs/proxy.png" alt=""></p>
<p>因为跨越是浏览器的限制，所以可以用同源的服务器去代理请求，代理服务使链路变的更长。</p>
<h3>3.2.3 实战-CORS（fetch+node.js）</h3>
<ul>
<li>观察node.js在服务端的实现CORS跨域</li>
<li>观察浏览器器fetch的使用方法</li>
<li>观察OPTIONS预检请求</li>
</ul>
<p>项目地址：/examples/computerNetwork/3.2</p>
<ol>
<li>用express起2个服务</li>
</ol>
<pre class="hljs language-js"  style=--lang:"js" ><code><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);
<span class="hljs-keyword">const</span> app1 = <span class="hljs-title function_">express</span>();

app1.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>){
    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)
})

app1.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>)

<span class="hljs-keyword">const</span> app2 = <span class="hljs-title function_">express</span>()
app2.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/api&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>){
    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;go&#x27;</span>)
})

app2.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/api&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">req,res</span>){
    res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&#x27;go&#x27;</span>)
})
app2.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3001</span>)
</code></pre>
<p>启动node服务 nodeman cors.js</p>
<ol start="2">
<li>用<code>whislte</code>做代理</li>
</ol>
<pre class="hljs language-bash"  style=--lang:"bash" ><code>    npm i whistle -g <span class="hljs-comment"># 下载，mac电脑：sudo npm i whistle -g </span>
    whistle start <span class="hljs-comment"># 启动</span>
    http://localhost:8899/ <span class="hljs-comment"># 浏览器查看</span>
    SwitchOmega <span class="hljs-comment"># 谷歌代理插件，可以配置127.0.0.1:8899的服务上</span>
</code></pre>
<p>配置whislte进行代理的域名</p>
<p><img src="/blog/imgs/whistle.png" alt=""></p>
<p>谷歌代理插件SwitchOmega，配置代理服务器127.0.0.1:8899的服务</p>
<p><img src="/blog/imgs/switchOmega.png" alt=""></p>
<p>SwitchOmega 选择 proxy进行代理</p>
<p><img src="/blog/imgs/webresquest.png" alt=""></p>
<ol start="3">
<li>在<code>dev.com</code>网站上请求<code>dev1.com/api</code></li>
</ol>
<p>从上面看到在<code>dev.com</code>网站上请求<code>dev1.com/api</code>有跨域的报错信息，告诉我们可以用CORS加请求头,以下是解决方法。</p>
<pre class="hljs language-diff"  style=--lang:"diff" ><code>const express = require(&#x27;express&#x27;);
const app1 = express();

app1.get(&#x27;/&#x27;,function(req,res){
    res.send(&#x27;hello&#x27;)
})

app1.listen(3000)

const app2 = express()
app2.get(&#x27;/api&#x27;,function(req,res){
<span class="hljs-addition">+    res.set(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;http://www.dev.com&#x27;)</span>
    res.send(&#x27;go&#x27;)
})

app2.post(&#x27;/api&#x27;,function(req,res){
    res.send(&#x27;go&#x27;)
})

app2.put(&#x27;/api&#x27;,function(req,res){
    res.set(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;http://www.dev.com&#x27;)
    res.send(&#x27;go&#x27;)
})
app2.listen(3001)
</code></pre>
<p>在浏览器控制面板输入fetch('http://www.dev1.com/api',{method:'POST',headers:{'Content-Type':'application/json'}})进行请求；
再次请求并加content-type字段，如果我们用post请求并在headers里加字段content-type:'application/json'，因为这是复杂请求，浏览器会先发送一个options请求，我们需要设置响应的headers允许添加某个字段。</p>
<p><img src="/blog/imgs/options.png" alt=""></p>
<pre class="hljs language-diff"  style=--lang:"diff" ><code>app1.listen(3000)

const app2 = express()
app2.get(&#x27;/api&#x27;,function(req,res){
    res.set(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;http://www.dev.com&#x27;)
    res.send(&#x27;go&#x27;)
})
<span class="hljs-addition">+ app2.options(&#x27;/api&#x27;,function(req,res){</span>
<span class="hljs-addition">+   res.set(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;http://www.dev.com&#x27;)</span>
<span class="hljs-addition">+   res.set(&#x27;Access-Control-Allow-Headers&#x27;,&#x27;content-type&#x27;)</span>
<span class="hljs-addition">+  res.sendStatus(200)</span>
<span class="hljs-addition">+ })</span>
app2.post(&#x27;/api&#x27;,function(req,res){
<span class="hljs-addition">+    res.set(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;http://www.dev.com&#x27;)</span>
    res.send(&#x27;go&#x27;)
})

app2.put(&#x27;/api&#x27;,function(req,res){
    res.set(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;http://www.dev.com&#x27;)
    res.send(&#x27;go&#x27;)
})
app2.listen(3001)
</code></pre>
<p>用<code>put</code>请求看看，报错信息中可以看出是要在响应前加上允许<code>PUT</code>的请求</p>
<p><img src="/blog/imgs/put.png" alt=""></p>
<p>GET/POST/HEAD这种简单请求不会受这种影响,<code>put</code>、<code>delete</code>属于复杂请求，我们添加上以下代码来允许<code>PUT</code>请求</p>
<pre class="hljs language-diff"  style=--lang:"diff" ><code> app2.options(&#x27;/api&#x27;,function(req,res){
  res.set(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;http://www.dev.com&#x27;)
  res.set(&#x27;Access-Control-Allow-Headers&#x27;,&#x27;content-type&#x27;)
<span class="hljs-addition">+ res.set(&#x27;Access-Control-Allow-Methods&#x27;,&#x27;PUT&#x27;)</span>
  res.sendStatus(200)
 })
</code></pre>
<p>我们在请求的时候在headers添加自定义字段 token,需要添加以下代码允许自定义</p>
<pre class="hljs language-diff"  style=--lang:"diff" ><code> app2.options(&#x27;/api&#x27;,function(req,res){
  res.set(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;http://www.dev.com&#x27;)
<span class="hljs-addition">+ res.set(&#x27;Access-Control-Allow-Headers&#x27;,&#x27;content-type,token&#x27;)</span>
  res.set(&#x27;Access-Control-Allow-Methods&#x27;,&#x27;PUT&#x27;)
  res.sendStatus(200)
 })
</code></pre>
<p>&lt;font color=&quot;red&quot;&gt;子域名下请求父域名、父域名下请求子域名、子域名下请求子域名 都属于跨域，服务端通常通过判断是不是同一个一级域名，然后在origin里加上通过的域名&lt;/font&gt;</p>
<p>fetch('http://www.dev1.com/api',{method:'POST',mode:'no-cors'}) 这种加上no-cors，会显示请求成功了，但是拿不到数据，这种请求属于透明请求。</p>
<p><img src="/blog/dog.jpg" alt="dog">
<img src="/blog/security/penguin.jpg" alt="penguin"></p>
</article></div></main><script src="/_next/static/chunks/webpack-9bda2a94a940c3a3.js" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[5244,[],\"\"]\n3:I[3866,[],\"\"]\n5:I[6213,[],\"OutletBoundary\"]\n7:I[6213,[],\"MetadataBoundary\"]\n9:I[6213,[],\"ViewportBoundary\"]\nb:I[4835,[],\"\"]\n:HL[\"/_next/static/media/569ce4b8f30dc480-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/93f479601ee12b01-s.p.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/css/d498c84e4ab246b3.css\",\"style\"]\n:HL[\"/_next/static/css/485ff6fe79292a08.css\",\"style\"]\n:HL[\"/_next/static/css/bcf94c9592804980.css\",\"style\"]\n:HL[\"/_next/static/css/0ff121a467c0636f.css\",\"style\"]\n"])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"tFUPXF070WIEe-cY5-wPP\",\"p\":\"\",\"c\":[\"\",\"blog\",\"security\",\"same-origin-policy\"],\"i\":false,\"f\":[[[\"\",{\"children\":[\"blog\",{\"children\":[[\"slug\",\"security/same-origin-policy\",\"oc\"],{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[\"\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/d498c84e4ab246b3.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/485ff6fe79292a08.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"2\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/bcf94c9592804980.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"__variable_4d318d __variable_ea5f4b antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[],[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[\"blog\",[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/css/0ff121a467c0636f.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"main\",null,{\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]]}],{\"children\":[[\"slug\",\"security/same-origin-policy\",\"oc\"],[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"segmentPath\":[\"children\",\"blog\",\"children\",\"$0:f:0:1:2:children:2:children:0\",\"children\"],\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[\"__PAGE__\",[\"$\",\"$1\",\"c\",{\"children\":[\"$L4\",null,[\"$\",\"$L5\",null,{\"children\":\"$L6\"}]]}],{},null,false]},null,false]},null,false]},null,false],[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$1\",\"6zseUNLpuRPu8DCmvs0Yh\",{\"children\":[[\"$\",\"$L7\",null,{\"children\":\"$L8\"}],[\"$\",\"$L9\",null,{\"children\":\"$La\"}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]]}],false]],\"m\":\"$undefined\",\"G\":[\"$b\",\"$undefined\"],\"s\":false,\"S\":true}\n"])</script><script>self.__next_f.push([1,"c:T34a6,"])</script><script>self.__next_f.push([1,"\u003ch2\u003e3.2 同源策略\u003c/h2\u003e\n\u003ch3\u003e3.2.1 定义\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e禁止一个源（origin）的脚本\u0026amp;文档和另一个源的脚本\u0026amp;文档交互\n\u003cul\u003e\n\u003cli\u003e两个URL的protocol，port和host相同，那么同源\u003c/li\u003e\n\u003cli\u003e思考：如果两个源产生过多交换有什么问题？\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/blog/imgs/someorigin.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e思考：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e为什么不禁用不同源的js？\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e因为有时候需要把js放到cdn上，那么可能就不同源了，所以行不通。\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e应不应该允许不同源的js修改dom？\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e允许\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e应不应该允许网站提交数据到不同源的的服务器？\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e不允许\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e应不应该允许网站提交cookie到不同源的服务器？\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e不允许\u003c/p\u003e\n\u003ch3\u003e3.2.2 跨域的N种方法\u003c/h3\u003e\n\u003ch4\u003e1.JSONP\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e利用不限制跨越脚本执行的特点\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e \u003cspan class=\"hljs-comment\"\u003e// 服务端数据（data.js）\u003c/span\u003e\n \u003cspan class=\"hljs-title function_\"\u003ejsonp\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026quot;example\u0026quot;\u003c/span\u003e,{\n    \u003cspan class=\"hljs-attr\"\u003ea\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e1\u003c/span\u003e,\n    \u003cspan class=\"hljs-attr\"\u003eb\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e2\u003c/span\u003e\n })\n\n \u003cspan class=\"hljs-comment\"\u003e// index.html\u003c/span\u003e\n \u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e \u003cspan class=\"hljs-title function_\"\u003ejsonp\u003c/span\u003e (\u003cspan class=\"hljs-params\"\u003e\u003c/span\u003e) {\n    \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(topic,data)\n }\n \u003cspan class=\"hljs-comment\"\u003e// 加载跨域数据脚本\u003c/span\u003e\n \u003cspan class=\"hljs-keyword\"\u003evar\u003c/span\u003e script = \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003ecreateElement\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;script\u0026#x27;\u003c/span\u003e)\n script.\u003cspan class=\"hljs-title function_\"\u003esetAttribute\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;src\u0026#x27;\u003c/span\u003e,\u003cspan class=\"hljs-string\"\u003e\u0026#x27;data.js\u0026#x27;\u003c/span\u003e)\n \u003cspan class=\"hljs-variable language_\"\u003edocument\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003egetElementdByTagName\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;head\u0026#x27;\u003c/span\u003e)[\u003cspan class=\"hljs-number\"\u003e0\u003c/span\u003e].\u003cspan class=\"hljs-title function_\"\u003eappendChild\u003c/span\u003e(script)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e思考\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003ejsonp可以用来提交数据吗？\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e可以在url上，但只能get请求；服务端可以通过判断返回不同的脚本\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e尝试为fetch函数扩展jsonp功能\u003c/li\u003e\n\u003c/ul\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-title function_\"\u003efetch\u003c/span\u003e(\u0026lt;jsonp-url\u0026gt;,{\u003cspan class=\"hljs-attr\"\u003emethod\u003c/span\u003e: \u003cspan class=\"hljs-string\"\u003e\u0026#x27;jsonp\u0026#x27;\u003c/span\u003e})\n      .\u003cspan class=\"hljs-title function_\"\u003ethen\u003c/span\u003e(\u003cspan class=\"hljs-function\"\u003e\u003cspan class=\"hljs-params\"\u003edata\u003c/span\u003e=\u0026gt;\u003c/span\u003e{\n         \u003cspan class=\"hljs-variable language_\"\u003econsole\u003c/span\u003e.\u003cspan class=\"hljs-title function_\"\u003elog\u003c/span\u003e(data)\n      })\n\u003c/code\u003e\u003c/pre\u003e\n\u003ch4\u003e2. 跨域资源共用 \u0026lt;Badge text=\u0026quot;重要\u0026quot; type=\u0026quot;tip\u0026quot;/\u0026gt;\u003c/h4\u003e\n\u003cul\u003e\n\u003cli\u003e跨域资源共用（Cross-Origin Resource Sharing）使用额外HTTP头允许指定的源和另一个源进行交互\n服务端设置 Access-control-Allow-Origin:https://a.com\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cimg src=\"/blog/imgs/corss.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eget、post我们称之为简单请求，简单请求在同源策略中会简单的处理,如果b.com返回了这个头\u003ccode\u003eAccess-control-Allow-Origin:https://a.com\u003c/code\u003e，那么我们认为\n这个请求是可以通过的。\u003c/p\u003e\n\u003cp\u003e预检\u003c/p\u003e\n\u003cp\u003e但是还有复杂一点的请求，我们需要先发OPTIONS请求，a.com想请求b.com它需要发一个自定义的Headers：X-ABC和content-type，这个时候就不是简单请求了，\na.com要给b.com 发一个options请求，它其实在问b.com我用post行不行，还想在Headers中带X-ABC和content-type；并不是所有的headers都发这个OPTIONS请求，因为X-ABC是自定义的，所以需要发；b.com看到OPTIONS请求，先不会返回数据，先检查自己的策略，看看能不能支持这次请求，如果支持就返回200。\u003c/p\u003e\n\u003cp\u003eOPTIONS请求返回以下报文\u003c/p\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-variable constant_\"\u003eHTTP\u003c/span\u003e/\u003cspan class=\"hljs-number\"\u003e2.0\u003c/span\u003e \u003cspan class=\"hljs-number\"\u003e20\u003c/span\u003e \u003cspan class=\"hljs-variable constant_\"\u003eOK\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eAccess\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eControl\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eAllow\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eOrigin\u003c/span\u003e:\u003cspan class=\"hljs-attr\"\u003ehttps\u003c/span\u003e:\u003cspan class=\"hljs-comment\"\u003e//a.com\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eAccess\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eControl\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eAllow\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eMethods\u003c/span\u003e:\u003cspan class=\"hljs-variable constant_\"\u003ePOST\u003c/span\u003e,\u003cspan class=\"hljs-variable constant_\"\u003eGET\u003c/span\u003e,\u003cspan class=\"hljs-variable constant_\"\u003eOPTIONS\u003c/span\u003e\n\u003cspan class=\"hljs-title class_\"\u003eAccess\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eControl\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eAllow\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eHeaders\u003c/span\u003e:X-\u003cspan class=\"hljs-variable constant_\"\u003eABC\u003c/span\u003e,\u003cspan class=\"hljs-title class_\"\u003eContent\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eType\u003c/span\u003e\n     \u003cspan class=\"hljs-title class_\"\u003eAccess\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eControl\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eMax\u003c/span\u003e-\u003cspan class=\"hljs-title class_\"\u003eAge\u003c/span\u003e:\u003cspan class=\"hljs-number\"\u003e86400\u003c/span\u003e \u003cspan class=\"hljs-comment\"\u003e// 告诉浏览器这个策略生效时间为一个小时，在一个小时之内发送类似的请求，不用在问服务端了，相当于缓存了\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e浏览器收到了OPTIONS的返回，会在发一次，这一次才是真正的请求数据，这次headers会带上X-ABC、contentType。\u003c/p\u003e\n\u003cp\u003e整体的过程cors将请求分为2种，简单请求和复杂请求，需不需要发送OPTIONS浏览器说的算，浏览器判断是简单请求还是复杂请求，cors是非常广泛的跨域手段\n这里的缺点是OPTIONS请求也是一次请求，消耗带宽，真正的请求也会延迟。\u003c/p\u003e\n\u003ch4\u003e3.反向代理 \u0026lt;Badge text=\u0026quot;重要\u0026quot; type=\u0026quot;tip\u0026quot;/\u0026gt;\u003c/h4\u003e\n\u003cp\u003e\u003cimg src=\"/blog/imgs/proxy.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e因为跨越是浏览器的限制，所以可以用同源的服务器去代理请求，代理服务使链路变的更长。\u003c/p\u003e\n\u003ch3\u003e3.2.3 实战-CORS（fetch+node.js）\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e观察node.js在服务端的实现CORS跨域\u003c/li\u003e\n\u003cli\u003e观察浏览器器fetch的使用方法\u003c/li\u003e\n\u003cli\u003e观察OPTIONS预检请求\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e项目地址：/examples/computerNetwork/3.2\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003e用express起2个服务\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre class=\"hljs language-js\"  style=--lang:\"js\" \u003e\u003ccode\u003e\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e express = \u003cspan class=\"hljs-built_in\"\u003erequire\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;express\u0026#x27;\u003c/span\u003e);\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app1 = \u003cspan class=\"hljs-title function_\"\u003eexpress\u003c/span\u003e();\n\napp1.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;/\u0026#x27;\u003c/span\u003e,\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ereq,res\u003c/span\u003e){\n    res.\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;hello\u0026#x27;\u003c/span\u003e)\n})\n\napp1.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3000\u003c/span\u003e)\n\n\u003cspan class=\"hljs-keyword\"\u003econst\u003c/span\u003e app2 = \u003cspan class=\"hljs-title function_\"\u003eexpress\u003c/span\u003e()\napp2.\u003cspan class=\"hljs-title function_\"\u003eget\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;/api\u0026#x27;\u003c/span\u003e,\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ereq,res\u003c/span\u003e){\n    res.\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;go\u0026#x27;\u003c/span\u003e)\n})\n\napp2.\u003cspan class=\"hljs-title function_\"\u003epost\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;/api\u0026#x27;\u003c/span\u003e,\u003cspan class=\"hljs-keyword\"\u003efunction\u003c/span\u003e(\u003cspan class=\"hljs-params\"\u003ereq,res\u003c/span\u003e){\n    res.\u003cspan class=\"hljs-title function_\"\u003esend\u003c/span\u003e(\u003cspan class=\"hljs-string\"\u003e\u0026#x27;go\u0026#x27;\u003c/span\u003e)\n})\napp2.\u003cspan class=\"hljs-title function_\"\u003elisten\u003c/span\u003e(\u003cspan class=\"hljs-number\"\u003e3001\u003c/span\u003e)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e启动node服务 nodeman cors.js\u003c/p\u003e\n\u003col start=\"2\"\u003e\n\u003cli\u003e用\u003ccode\u003ewhislte\u003c/code\u003e做代理\u003c/li\u003e\n\u003c/ol\u003e\n\u003cpre class=\"hljs language-bash\"  style=--lang:\"bash\" \u003e\u003ccode\u003e    npm i whistle -g \u003cspan class=\"hljs-comment\"\u003e# 下载，mac电脑：sudo npm i whistle -g \u003c/span\u003e\n    whistle start \u003cspan class=\"hljs-comment\"\u003e# 启动\u003c/span\u003e\n    http://localhost:8899/ \u003cspan class=\"hljs-comment\"\u003e# 浏览器查看\u003c/span\u003e\n    SwitchOmega \u003cspan class=\"hljs-comment\"\u003e# 谷歌代理插件，可以配置127.0.0.1:8899的服务上\u003c/span\u003e\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e配置whislte进行代理的域名\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/blog/imgs/whistle.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003e谷歌代理插件SwitchOmega，配置代理服务器127.0.0.1:8899的服务\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/blog/imgs/switchOmega.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eSwitchOmega 选择 proxy进行代理\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/blog/imgs/webresquest.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003col start=\"3\"\u003e\n\u003cli\u003e在\u003ccode\u003edev.com\u003c/code\u003e网站上请求\u003ccode\u003edev1.com/api\u003c/code\u003e\u003c/li\u003e\n\u003c/ol\u003e\n\u003cp\u003e从上面看到在\u003ccode\u003edev.com\u003c/code\u003e网站上请求\u003ccode\u003edev1.com/api\u003c/code\u003e有跨域的报错信息，告诉我们可以用CORS加请求头,以下是解决方法。\u003c/p\u003e\n\u003cpre class=\"hljs language-diff\"  style=--lang:\"diff\" \u003e\u003ccode\u003econst express = require(\u0026#x27;express\u0026#x27;);\nconst app1 = express();\n\napp1.get(\u0026#x27;/\u0026#x27;,function(req,res){\n    res.send(\u0026#x27;hello\u0026#x27;)\n})\n\napp1.listen(3000)\n\nconst app2 = express()\napp2.get(\u0026#x27;/api\u0026#x27;,function(req,res){\n\u003cspan class=\"hljs-addition\"\u003e+    res.set(\u0026#x27;Access-Control-Allow-Origin\u0026#x27;,\u0026#x27;http://www.dev.com\u0026#x27;)\u003c/span\u003e\n    res.send(\u0026#x27;go\u0026#x27;)\n})\n\napp2.post(\u0026#x27;/api\u0026#x27;,function(req,res){\n    res.send(\u0026#x27;go\u0026#x27;)\n})\n\napp2.put(\u0026#x27;/api\u0026#x27;,function(req,res){\n    res.set(\u0026#x27;Access-Control-Allow-Origin\u0026#x27;,\u0026#x27;http://www.dev.com\u0026#x27;)\n    res.send(\u0026#x27;go\u0026#x27;)\n})\napp2.listen(3001)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e在浏览器控制面板输入fetch('http://www.dev1.com/api',{method:'POST',headers:{'Content-Type':'application/json'}})进行请求；\n再次请求并加content-type字段，如果我们用post请求并在headers里加字段content-type:'application/json'，因为这是复杂请求，浏览器会先发送一个options请求，我们需要设置响应的headers允许添加某个字段。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/blog/imgs/options.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cpre class=\"hljs language-diff\"  style=--lang:\"diff\" \u003e\u003ccode\u003eapp1.listen(3000)\n\nconst app2 = express()\napp2.get(\u0026#x27;/api\u0026#x27;,function(req,res){\n    res.set(\u0026#x27;Access-Control-Allow-Origin\u0026#x27;,\u0026#x27;http://www.dev.com\u0026#x27;)\n    res.send(\u0026#x27;go\u0026#x27;)\n})\n\u003cspan class=\"hljs-addition\"\u003e+ app2.options(\u0026#x27;/api\u0026#x27;,function(req,res){\u003c/span\u003e\n\u003cspan class=\"hljs-addition\"\u003e+   res.set(\u0026#x27;Access-Control-Allow-Origin\u0026#x27;,\u0026#x27;http://www.dev.com\u0026#x27;)\u003c/span\u003e\n\u003cspan class=\"hljs-addition\"\u003e+   res.set(\u0026#x27;Access-Control-Allow-Headers\u0026#x27;,\u0026#x27;content-type\u0026#x27;)\u003c/span\u003e\n\u003cspan class=\"hljs-addition\"\u003e+  res.sendStatus(200)\u003c/span\u003e\n\u003cspan class=\"hljs-addition\"\u003e+ })\u003c/span\u003e\napp2.post(\u0026#x27;/api\u0026#x27;,function(req,res){\n\u003cspan class=\"hljs-addition\"\u003e+    res.set(\u0026#x27;Access-Control-Allow-Origin\u0026#x27;,\u0026#x27;http://www.dev.com\u0026#x27;)\u003c/span\u003e\n    res.send(\u0026#x27;go\u0026#x27;)\n})\n\napp2.put(\u0026#x27;/api\u0026#x27;,function(req,res){\n    res.set(\u0026#x27;Access-Control-Allow-Origin\u0026#x27;,\u0026#x27;http://www.dev.com\u0026#x27;)\n    res.send(\u0026#x27;go\u0026#x27;)\n})\napp2.listen(3001)\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e用\u003ccode\u003eput\u003c/code\u003e请求看看，报错信息中可以看出是要在响应前加上允许\u003ccode\u003ePUT\u003c/code\u003e的请求\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/blog/imgs/put.png\" alt=\"\"\u003e\u003c/p\u003e\n\u003cp\u003eGET/POST/HEAD这种简单请求不会受这种影响,\u003ccode\u003eput\u003c/code\u003e、\u003ccode\u003edelete\u003c/code\u003e属于复杂请求，我们添加上以下代码来允许\u003ccode\u003ePUT\u003c/code\u003e请求\u003c/p\u003e\n\u003cpre class=\"hljs language-diff\"  style=--lang:\"diff\" \u003e\u003ccode\u003e app2.options(\u0026#x27;/api\u0026#x27;,function(req,res){\n  res.set(\u0026#x27;Access-Control-Allow-Origin\u0026#x27;,\u0026#x27;http://www.dev.com\u0026#x27;)\n  res.set(\u0026#x27;Access-Control-Allow-Headers\u0026#x27;,\u0026#x27;content-type\u0026#x27;)\n\u003cspan class=\"hljs-addition\"\u003e+ res.set(\u0026#x27;Access-Control-Allow-Methods\u0026#x27;,\u0026#x27;PUT\u0026#x27;)\u003c/span\u003e\n  res.sendStatus(200)\n })\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e我们在请求的时候在headers添加自定义字段 token,需要添加以下代码允许自定义\u003c/p\u003e\n\u003cpre class=\"hljs language-diff\"  style=--lang:\"diff\" \u003e\u003ccode\u003e app2.options(\u0026#x27;/api\u0026#x27;,function(req,res){\n  res.set(\u0026#x27;Access-Control-Allow-Origin\u0026#x27;,\u0026#x27;http://www.dev.com\u0026#x27;)\n\u003cspan class=\"hljs-addition\"\u003e+ res.set(\u0026#x27;Access-Control-Allow-Headers\u0026#x27;,\u0026#x27;content-type,token\u0026#x27;)\u003c/span\u003e\n  res.set(\u0026#x27;Access-Control-Allow-Methods\u0026#x27;,\u0026#x27;PUT\u0026#x27;)\n  res.sendStatus(200)\n })\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u0026lt;font color=\u0026quot;red\u0026quot;\u0026gt;子域名下请求父域名、父域名下请求子域名、子域名下请求子域名 都属于跨域，服务端通常通过判断是不是同一个一级域名，然后在origin里加上通过的域名\u0026lt;/font\u0026gt;\u003c/p\u003e\n\u003cp\u003efetch('http://www.dev1.com/api',{method:'POST',mode:'no-cors'}) 这种加上no-cors，会显示请求成功了，但是拿不到数据，这种请求属于透明请求。\u003c/p\u003e\n\u003cp\u003e\u003cimg src=\"/blog/dog.jpg\" alt=\"dog\"\u003e\n\u003cimg src=\"/blog/security/penguin.jpg\" alt=\"penguin\"\u003e\u003c/p\u003e\n"])</script><script>self.__next_f.push([1,"4:[\"$\",\"div\",null,{\"className\":\"markdown-body\",\"children\":[[\"$\",\"h1\",null,{\"children\":\"同源策略\"}],[\"$\",\"article\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"$c\"}}]]}]\n"])</script><script>self.__next_f.push([1,"a:[[\"$\",\"meta\",\"0\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n8:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"title\",\"1\",{\"children\":\"blog | adog\"}],[\"$\",\"meta\",\"2\",{\"name\":\"description\",\"content\":\"some  my blog\"}],[\"$\",\"meta\",\"3\",{\"name\":\"keywords\",\"content\":\"前端,react,web3,区块链,数字货币,加密货币\"}],[\"$\",\"link\",\"4\",{\"rel\":\"icon\",\"href\":\"/favicon.ico\",\"type\":\"image/x-icon\",\"sizes\":\"16x16\"}]]\n"])</script><script>self.__next_f.push([1,"6:null\n"])</script></body></html>